<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Code::Blocks: Parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Code::Blocks
   &#160;<span id="projectnumber">SVN r10603</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated"><span>Classes</span></a></li>
      <li><a href="files"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated"><span>Class&#160;List</span></a></li>
      <li><a href="classes"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classParser-members">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Parser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> class holds all the tokens of a C::B project.  
 <a href="classParser#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="parser_8h_source">parser.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Parser:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classParser__inherit__graph.svg" width="194" height="1087"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for Parser:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classParser__coll__graph.svg" width="2950" height="3328"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:l5-Parser"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#l5-Parser">Parser</a> (wxEvtHandler *parent, <a class="el" href="classcbProject">cbProject</a> *project)</td></tr>
<tr class="memdesc:l5-Parser"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="#l5-Parser">More...</a><br /></td></tr>
<tr class="separator:l5-Parser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ij-Parser"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#ij-Parser">~Parser</a> ()</td></tr>
<tr class="memdesc:ij-Parser"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="#ij-Parser">More...</a><br /></td></tr>
<tr class="separator:ij-Parser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:uw-AddBatchParse"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#uw-AddBatchParse">AddBatchParse</a> (const <a class="el" href="parser__base_8h#ks-StringList">StringList</a> &amp;filenames)</td></tr>
<tr class="memdesc:uw-AddBatchParse"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add files to batch parse mode, internally.  <a href="#uw-AddBatchParse">More...</a><br /></td></tr>
<tr class="separator:uw-AddBatchParse"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:g2-AddParse"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#g2-AddParse">AddParse</a> (const wxString &amp;filename)</td></tr>
<tr class="memdesc:g2-AddParse"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add one file to Batch mode Parsing, this is the bridge between the main thread and the thread pool, after this function call, the file(Parserthread) will be run from the thread pool.  <a href="#g2-AddParse">More...</a><br /></td></tr>
<tr class="separator:g2-AddParse"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lv-AddPredefinedMacros"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#lv-AddPredefinedMacros">AddPredefinedMacros</a> (const wxString &amp;defs)</td></tr>
<tr class="memdesc:lv-AddPredefinedMacros"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the predefined macro definition string was collected from the GCC command line, this function adds the string to an internal m_PredefinedMacros, and switch the ParserState  <a href="#lv-AddPredefinedMacros">More...</a><br /></td></tr>
<tr class="separator:lv-AddPredefinedMacros"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vk-ClearPredefinedMacros"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#vk-ClearPredefinedMacros">ClearPredefinedMacros</a> ()</td></tr>
<tr class="memdesc:vk-ClearPredefinedMacros"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears the list of predefined macros after it has been parsed  <a href="#vk-ClearPredefinedMacros">More...</a><br /></td></tr>
<tr class="separator:vk-ClearPredefinedMacros"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:s5-GetPredefinedMacros"><td class="memItemLeft" align="right" valign="top">virtual const wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#s5-GetPredefinedMacros">GetPredefinedMacros</a> () const </td></tr>
<tr class="memdesc:s5-GetPredefinedMacros"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the predefined macro definition string that has been collected  <a href="#s5-GetPredefinedMacros">More...</a><br /></td></tr>
<tr class="separator:s5-GetPredefinedMacros"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rn-UpdateParsingProject"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#rn-UpdateParsingProject">UpdateParsingProject</a> (<a class="el" href="classcbProject">cbProject</a> *project)</td></tr>
<tr class="memdesc:rn-UpdateParsingProject"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the associated C::B project pointer.  <a href="#rn-UpdateParsingProject">More...</a><br /></td></tr>
<tr class="separator:rn-UpdateParsingProject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:or-ParseBuffer"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#or-ParseBuffer">ParseBuffer</a> (const wxString &amp;buffer, bool isLocal, bool bufferSkipBlocks=false, bool isTemp=false, const wxString &amp;filename=wxEmptyString, int parentIdx=-1, int initLine=0)</td></tr>
<tr class="memdesc:or-ParseBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must add a locker before call all named ParseBufferXXX functions, ParseBuffer function will directly run the parsing in the same thread as the caller.  <a href="#or-ParseBuffer">More...</a><br /></td></tr>
<tr class="separator:or-ParseBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nz-ParseBufferForFunctions"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#nz-ParseBufferForFunctions">ParseBufferForFunctions</a> (const wxString &amp;buffer)</td></tr>
<tr class="memdesc:nz-ParseBufferForFunctions"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser the current editor control, this function is used to list all the functions in the current code editor  <a href="#nz-ParseBufferForFunctions">More...</a><br /></td></tr>
<tr class="separator:nz-ParseBufferForFunctions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jn-ParseBufferForNamespaces"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#jn-ParseBufferForNamespaces">ParseBufferForNamespaces</a> (const wxString &amp;buffer, <a class="el" href="parserthread_8h#ia-NameSpaceVec">NameSpaceVec</a> &amp;result)</td></tr>
<tr class="memdesc:jn-ParseBufferForNamespaces"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse the buffer for collecting exposed namespace scopes  <a href="#jn-ParseBufferForNamespaces">More...</a><br /></td></tr>
<tr class="separator:jn-ParseBufferForNamespaces"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:u4-ParseBufferForUsingNamespace"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#u4-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace</a> (const wxString &amp;buffer, wxArrayString &amp;result, bool bufferSkipBlocks=true)</td></tr>
<tr class="memdesc:u4-ParseBufferForUsingNamespace"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse the buffer for collecting using namespace directive  <a href="#u4-ParseBufferForUsingNamespace">More...</a><br /></td></tr>
<tr class="separator:u4-ParseBufferForUsingNamespace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zd-Reparse"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#zd-Reparse">Reparse</a> (const wxString &amp;filename, bool isLocal=true)</td></tr>
<tr class="memdesc:zd-Reparse"><td class="mdescLeft">&#160;</td><td class="mdescRight">mark this file to be re-parsed in the <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a>, tick the reparse timer, note it looks like the isLocal parameter is not used in <a class="el" href="classParser#zd-Reparse" title="mark this file to be re-parsed in the TokenTree, tick the reparse timer, note it looks like the isLoc...">Parser::Reparse</a> function.  <a href="#zd-Reparse">More...</a><br /></td></tr>
<tr class="separator:zd-Reparse"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sc-AddFile"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#sc-AddFile">AddFile</a> (const wxString &amp;filename, <a class="el" href="classcbProject">cbProject</a> *project, bool isLocal=true)</td></tr>
<tr class="memdesc:sc-AddFile"><td class="mdescLeft">&#160;</td><td class="mdescRight">this usually happens when user adds some files to an existing project, it just use <a class="el" href="classParser#g2-AddParse" title="Add one file to Batch mode Parsing, this is the bridge between the main thread and the thread pool...">AddParse()</a> function internally to add the file.  <a href="#sc-AddFile">More...</a><br /></td></tr>
<tr class="separator:sc-AddFile"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ve-RemoveFile"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#ve-RemoveFile">RemoveFile</a> (const wxString &amp;filename)</td></tr>
<tr class="memdesc:ve-RemoveFile"><td class="mdescLeft">&#160;</td><td class="mdescRight">this usually happens when the user removes a file from the existing project, it will remove all the tokens belong to the file.  <a href="#ve-RemoveFile">More...</a><br /></td></tr>
<tr class="separator:ve-RemoveFile"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pg-IsFileParsed"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#pg-IsFileParsed">IsFileParsed</a> (const wxString &amp;filename)</td></tr>
<tr class="memdesc:pg-IsFileParsed"><td class="mdescLeft">&#160;</td><td class="mdescRight">check to see a file is parsed already, it first check the <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> to see whether it has the specified file, but if a file is already queued (put in m_BatchParseFiles), we regard it as already parsed.  <a href="#pg-IsFileParsed">More...</a><br /></td></tr>
<tr class="separator:pg-IsFileParsed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:hu-Done"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#hu-Done">Done</a> ()</td></tr>
<tr class="memdesc:hu-Done"><td class="mdescLeft">&#160;</td><td class="mdescRight">check to see whether <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> is in Idle mode, there is no work need to be done in the <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a>  <a href="#hu-Done">More...</a><br /></td></tr>
<tr class="separator:hu-Done"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:wi-NotDoneReason"><td class="memItemLeft" align="right" valign="top">virtual wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#wi-NotDoneReason">NotDoneReason</a> ()</td></tr>
<tr class="memdesc:wi-NotDoneReason"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> is not in Idle mode, show which need to be done  <a href="#wi-NotDoneReason">More...</a><br /></td></tr>
<tr class="separator:wi-NotDoneReason"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classParserBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classParserBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classParserBase">ParserBase</a></td></tr>
<tr class="memitem:ro-ParserBase inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#ro-ParserBase">ParserBase</a> ()</td></tr>
<tr class="separator:ro-ParserBase inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:no-ParserBase inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#no-ParserBase">~ParserBase</a> ()</td></tr>
<tr class="separator:no-ParserBase inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:fq-AddBatchParse inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#fq-AddBatchParse">AddBatchParse</a> (cb_unused const <a class="el" href="parser__base_8h#ks-StringList">StringList</a> &amp;filenames)</td></tr>
<tr class="separator:fq-AddBatchParse inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:fd-AddParse inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#fd-AddParse">AddParse</a> (cb_unused const wxString &amp;filename)</td></tr>
<tr class="separator:fd-AddParse inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:eo-AddPredefinedMacros inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#eo-AddPredefinedMacros">AddPredefinedMacros</a> (cb_unused const wxString &amp;defs)</td></tr>
<tr class="separator:eo-AddPredefinedMacros inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:xo-UpdateParsingProject inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#xo-UpdateParsingProject">UpdateParsingProject</a> (cb_unused <a class="el" href="classcbProject">cbProject</a> *project)</td></tr>
<tr class="separator:xo-UpdateParsingProject inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:j4-ParseBufferForFunctions inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#j4-ParseBufferForFunctions">ParseBufferForFunctions</a> (cb_unused const wxString &amp;buffer)</td></tr>
<tr class="separator:j4-ParseBufferForFunctions inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:kv-ParseBufferForNamespaces inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#kv-ParseBufferForNamespaces">ParseBufferForNamespaces</a> (cb_unused const wxString &amp;buffer, cb_unused <a class="el" href="parserthread_8h#ia-NameSpaceVec">NameSpaceVec</a> &amp;result)</td></tr>
<tr class="separator:kv-ParseBufferForNamespaces inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qo-ParseBufferForUsingNamespace inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#qo-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace</a> (cb_unused const wxString &amp;buffer, cb_unused wxArrayString &amp;result, cb_unused bool bufferSkipBlocks=true)</td></tr>
<tr class="separator:qo-ParseBufferForUsingNamespace inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:bz-Reparse inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#bz-Reparse">Reparse</a> (cb_unused const wxString &amp;filename, cb_unused bool isLocal=true)</td></tr>
<tr class="separator:bz-Reparse inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:uh-AddFile inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#uh-AddFile">AddFile</a> (cb_unused const wxString &amp;filename, cb_unused <a class="el" href="classcbProject">cbProject</a> *project, cb_unused bool isLocal=true)</td></tr>
<tr class="separator:uh-AddFile inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mb-RemoveFile inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#mb-RemoveFile">RemoveFile</a> (cb_unused const wxString &amp;filename)</td></tr>
<tr class="separator:mb-RemoveFile inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gk-IsFileParsed inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#gk-IsFileParsed">IsFileParsed</a> (cb_unused const wxString &amp;filename)</td></tr>
<tr class="separator:gk-IsFileParsed inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:kx-GetTokenTree inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTokenTree">TokenTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#kx-GetTokenTree">GetTokenTree</a> () const </td></tr>
<tr class="separator:kx-GetTokenTree inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:yt-GetTempTokenTree inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#yt-GetTempTokenTree">GetTempTokenTree</a> ()</td></tr>
<tr class="separator:yt-GetTempTokenTree inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nl-AddIncludeDir inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#nl-AddIncludeDir">AddIncludeDir</a> (const wxString &amp;dir)</td></tr>
<tr class="memdesc:nl-AddIncludeDir inherit pub_methods_classParserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a directory to the <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a>'s include path database  <a href="#nl-AddIncludeDir">More...</a><br /></td></tr>
<tr class="separator:nl-AddIncludeDir inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pb-GetIncludeDirs inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">const wxArrayString &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#pb-GetIncludeDirs">GetIncludeDirs</a> () const </td></tr>
<tr class="separator:pb-GetIncludeDirs inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:je-GetFullFileName inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#je-GetFullFileName">GetFullFileName</a> (const wxString &amp;src, const wxString &amp;tgt, bool isGlobal)</td></tr>
<tr class="separator:je-GetFullFileName inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:l4-FindFileInIncludeDirs inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">wxArrayString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#l4-FindFileInIncludeDirs">FindFileInIncludeDirs</a> (const wxString &amp;file, bool firstonly=false)</td></tr>
<tr class="memdesc:l4-FindFileInIncludeDirs inherit pub_methods_classParserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">it mimics what a compiler does to find an include header files, if the firstonly option is true, it will return the first found header file, otherwise, the complete database of the <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a>'s include paths will be searched.  <a href="#l4-FindFileInIncludeDirs">More...</a><br /></td></tr>
<tr class="separator:l4-FindFileInIncludeDirs inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:w4-Options inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structParserOptions">ParserOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#w4-Options">Options</a> ()</td></tr>
<tr class="separator:w4-Options inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tq-ClassBrowserOptions inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structBrowserOptions">BrowserOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#tq-ClassBrowserOptions">ClassBrowserOptions</a> ()</td></tr>
<tr class="separator:tq-ClassBrowserOptions inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gc-FindTokensInFile inherit pub_methods_classParserBase"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#gc-FindTokensInFile">FindTokensInFile</a> (const wxString &amp;filename, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;result, short int kindMask)</td></tr>
<tr class="separator:gc-FindTokensInFile inherit pub_methods_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:zj-StartStopWatch"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#zj-StartStopWatch">StartStopWatch</a> ()</td></tr>
<tr class="separator:zj-StartStopWatch"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qu-EndStopWatch"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#qu-EndStopWatch">EndStopWatch</a> ()</td></tr>
<tr class="separator:qu-EndStopWatch"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:it-GetMaxThreads"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#it-GetMaxThreads">GetMaxThreads</a> () const </td></tr>
<tr class="memdesc:it-GetMaxThreads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node: Currently, the max.  <a href="#it-GetMaxThreads">More...</a><br /></td></tr>
<tr class="separator:it-GetMaxThreads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vn-SetMaxThreads"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#vn-SetMaxThreads">SetMaxThreads</a> (unsigned int max)</td></tr>
<tr class="memdesc:vn-SetMaxThreads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not used, because the ThreadPool only support running ONE <a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a> concurrently.  <a href="#vn-SetMaxThreads">More...</a><br /></td></tr>
<tr class="separator:vn-SetMaxThreads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:o1-Parse"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#o1-Parse">Parse</a> (const wxString &amp;filename, bool isLocal=true, bool locked=false)</td></tr>
<tr class="memdesc:o1-Parse"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse the file, either immediately or delayed.  <a href="#o1-Parse">More...</a><br /></td></tr>
<tr class="separator:o1-Parse"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qq-ReparseModifiedFiles"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#qq-ReparseModifiedFiles">ReparseModifiedFiles</a> ()</td></tr>
<tr class="memdesc:qq-ReparseModifiedFiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete those files from the <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a>, and add them again through <a class="el" href="classParser#g2-AddParse" title="Add one file to Batch mode Parsing, this is the bridge between the main thread and the thread pool...">AddParse()</a> function  <a href="#qq-ReparseModifiedFiles">More...</a><br /></td></tr>
<tr class="separator:qq-ReparseModifiedFiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:i0-TerminateAllThreads"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#i0-TerminateAllThreads">TerminateAllThreads</a> ()</td></tr>
<tr class="memdesc:i0-TerminateAllThreads"><td class="mdescLeft">&#160;</td><td class="mdescRight">cancel all the tasks in the thread pool m_Pool  <a href="#i0-TerminateAllThreads">More...</a><br /></td></tr>
<tr class="separator:i0-TerminateAllThreads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dq-OnAllThreadsDone"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone</a> (<a class="el" href="classCodeBlocksEvent">CodeBlocksEvent</a> &amp;event)</td></tr>
<tr class="memdesc:dq-OnAllThreadsDone"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a ThreadPool batch parse stage is done, it will issue a cbEVT_THREADTASK_ALLDONE message.  <a href="#dq-OnAllThreadsDone">More...</a><br /></td></tr>
<tr class="separator:dq-OnAllThreadsDone"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ya-OnReparseTimer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#ya-OnReparseTimer">OnReparseTimer</a> (wxTimerEvent &amp;event)</td></tr>
<tr class="memdesc:ya-OnReparseTimer"><td class="mdescLeft">&#160;</td><td class="mdescRight">some files in the Tokentree is marked as need to be reparsed, this can be done by a call of <a class="el" href="classParser#zd-Reparse" title="mark this file to be re-parsed in the TokenTree, tick the reparse timer, note it looks like the isLoc...">Reparse()</a> before.  <a href="#ya-OnReparseTimer">More...</a><br /></td></tr>
<tr class="separator:ya-OnReparseTimer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qb-OnBatchTimer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer</a> (wxTimerEvent &amp;event)</td></tr>
<tr class="memdesc:qb-OnBatchTimer"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timer is used to optimized the event handling for parsing, e.g.  <a href="#qb-OnBatchTimer">More...</a><br /></td></tr>
<tr class="separator:qb-OnBatchTimer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jo-ProcessParserEvent"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#jo-ProcessParserEvent">ProcessParserEvent</a> (<a class="el" href="namespaceParserCommon#a0-ParserState">ParserCommon::ParserState</a> state, int id, const wxString &amp;info=wxEmptyString)</td></tr>
<tr class="memdesc:jo-ProcessParserEvent"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parser will let its parent (<a class="el" href="classNativeParser" title="NativeParser class is just like a manager class to control Parser objects. ">NativeParser</a>) to handle the event, as the <a class="el" href="classCodeCompletion" title="Code completion plugin has those features: show tool-tip when the mouse hover over the variables/func...">CodeCompletion</a> instance was set as the next handler of the <a class="el" href="classNativeParser" title="NativeParser class is just like a manager class to control Parser objects. ">NativeParser</a>.  <a href="#jo-ProcessParserEvent">More...</a><br /></td></tr>
<tr class="separator:jo-ProcessParserEvent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gu-ReadOptions"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#gu-ReadOptions">ReadOptions</a> ()</td></tr>
<tr class="memdesc:gu-ReadOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">read <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> options from configure file  <a href="#gu-ReadOptions">More...</a><br /></td></tr>
<tr class="separator:gu-ReadOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:v3-WriteOptions"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#v3-WriteOptions">WriteOptions</a> ()</td></tr>
<tr class="memdesc:v3-WriteOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">write Parse options to configure file  <a href="#v3-WriteOptions">More...</a><br /></td></tr>
<tr class="separator:v3-WriteOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:vd-m_UsingCache"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#vd-m_UsingCache">m_UsingCache</a></td></tr>
<tr class="memdesc:vd-m_UsingCache"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to detect changes between in-memory data and cache, true if loaded from cache  <a href="#vd-m_UsingCache">More...</a><br /></td></tr>
<tr class="separator:vd-m_UsingCache"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:l6-m_Pool"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcbThreadPool">cbThreadPool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#l6-m_Pool">m_Pool</a></td></tr>
<tr class="memdesc:l6-m_Pool"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread Pool, executing all the <a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a>, used in batch parse mode.  <a href="#l6-m_Pool">More...</a><br /></td></tr>
<tr class="separator:l6-m_Pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oc-m_IsParsing"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#oc-m_IsParsing">m_IsParsing</a></td></tr>
<tr class="memdesc:oc-m_IsParsing"><td class="mdescLeft">&#160;</td><td class="mdescRight">true, if the parser is still busy with parsing, false if the parsing stage has finished this value is set in parserthreadedtask after putting all the batchFiles to pool(task) it was reset after the last stage (mark tokens as local)  <a href="#oc-m_IsParsing">More...</a><br /></td></tr>
<tr class="separator:oc-m_IsParsing"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:b7-m_NeedsReparse"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#b7-m_NeedsReparse">m_NeedsReparse</a></td></tr>
<tr class="memdesc:b7-m_NeedsReparse"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates some files in the current project need to be re-parsed, this is commonly caused that the "real-time parsing option" is enabled, and user is editing source file.  <a href="#b7-m_NeedsReparse">More...</a><br /></td></tr>
<tr class="separator:b7-m_NeedsReparse"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cz-m_IsFirstBatch"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#cz-m_IsFirstBatch">m_IsFirstBatch</a></td></tr>
<tr class="memdesc:cz-m_IsFirstBatch"><td class="mdescLeft">&#160;</td><td class="mdescRight">batch Parse mode flag.  <a href="#cz-m_IsFirstBatch">More...</a><br /></td></tr>
<tr class="separator:cz-m_IsFirstBatch"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classParserBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classParserBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classParserBase">ParserBase</a></td></tr>
<tr class="memitem:cr-m_TokenTree inherit pro_attribs_classParserBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#cr-m_TokenTree">m_TokenTree</a></td></tr>
<tr class="memdesc:cr-m_TokenTree inherit pro_attribs_classParserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">each <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> class contains a <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> object which used to record tokens per project this tree will be created in the constructor and destroyed in destructor.  <a href="#cr-m_TokenTree">More...</a><br /></td></tr>
<tr class="separator:cr-m_TokenTree inherit pro_attribs_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ow-m_TempTokenTree inherit pro_attribs_classParserBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#ow-m_TempTokenTree">m_TempTokenTree</a></td></tr>
<tr class="memdesc:ow-m_TempTokenTree inherit pro_attribs_classParserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">a temp <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> tree hold some temporary tokens, e.g.  <a href="#ow-m_TempTokenTree">More...</a><br /></td></tr>
<tr class="separator:ow-m_TempTokenTree inherit pro_attribs_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:em-m_Options inherit pro_attribs_classParserBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structParserOptions">ParserOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#em-m_Options">m_Options</a></td></tr>
<tr class="memdesc:em-m_Options inherit pro_attribs_classParserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">options for how the parser try to parse files  <a href="#em-m_Options">More...</a><br /></td></tr>
<tr class="separator:em-m_Options inherit pro_attribs_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:b5-m_BrowserOptions inherit pro_attribs_classParserBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBrowserOptions">BrowserOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserBase#b5-m_BrowserOptions">m_BrowserOptions</a></td></tr>
<tr class="memdesc:b5-m_BrowserOptions inherit pro_attribs_classParserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">options for how the symbol browser was shown  <a href="#b5-m_BrowserOptions">More...</a><br /></td></tr>
<tr class="separator:b5-m_BrowserOptions inherit pro_attribs_classParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:xu-TasksQueue"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="classcbThreadedTask">cbThreadedTask</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#xu-TasksQueue">TasksQueue</a></td></tr>
<tr class="memdesc:xu-TasksQueue"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list to contain pointers to internal running threads.  <a href="#xu-TasksQueue">More...</a><br /></td></tr>
<tr class="separator:xu-TasksQueue"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:rp-ParseFile"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#rp-ParseFile">ParseFile</a> (const wxString &amp;filename, bool isGlobal, bool locked=false)</td></tr>
<tr class="memdesc:rp-ParseFile"><td class="mdescLeft">&#160;</td><td class="mdescRight">the only usage of this function is in the Parserthread class, when handling include directives the parserthread use some call like m_Parent-&gt;<a class="el" href="classParser#rp-ParseFile" title="the only usage of this function is in the Parserthread class, when handling include directives the pa...">ParseFile()</a> to call this function, but this function just call <a class="el" href="classParser#o1-Parse" title="parse the file, either immediately or delayed. ">Parser::Parse()</a> function, which either run the syntax analysis immediately or create a parsing task in the Pool.  <a href="#rp-ParseFile">More...</a><br /></td></tr>
<tr class="separator:rp-ParseFile"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rz-ConnectEvents"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#rz-ConnectEvents">ConnectEvents</a> ()</td></tr>
<tr class="memdesc:rz-ConnectEvents"><td class="mdescLeft">&#160;</td><td class="mdescRight">connect event handlers of the timers and thread pool  <a href="#rz-ConnectEvents">More...</a><br /></td></tr>
<tr class="separator:rz-ConnectEvents"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:f8-DisconnectEvents"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#f8-DisconnectEvents">DisconnectEvents</a> ()</td></tr>
<tr class="memdesc:f8-DisconnectEvents"><td class="mdescLeft">&#160;</td><td class="mdescRight">connect event handlers of the timers and thread pool  <a href="#f8-DisconnectEvents">More...</a><br /></td></tr>
<tr class="separator:f8-DisconnectEvents"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ov-AddParserThread"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#ov-AddParserThread">AddParserThread</a> (<a class="el" href="classcbThreadedTask">cbThreadedTask</a> *task)</td></tr>
<tr class="memdesc:ov-AddParserThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remember a newly created internal running threads.  <a href="#ov-AddParserThread">More...</a><br /></td></tr>
<tr class="separator:ov-AddParserThread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:z8-RemoveParserThread"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#z8-RemoveParserThread">RemoveParserThread</a> (<a class="el" href="classcbThreadedTask">cbThreadedTask</a> *task)</td></tr>
<tr class="memdesc:z8-RemoveParserThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a completed internal running threads.  <a href="#z8-RemoveParserThread">More...</a><br /></td></tr>
<tr class="separator:z8-RemoveParserThread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:x2-AbortParserThreads"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#x2-AbortParserThreads">AbortParserThreads</a> ()</td></tr>
<tr class="memdesc:x2-AbortParserThreads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell internal running threads to abort further processing.  <a href="#x2-AbortParserThreads">More...</a><br /></td></tr>
<tr class="separator:x2-AbortParserThreads"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:px-m_Parent"><td class="memItemLeft" align="right" valign="top">wxEvtHandler *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#px-m_Parent">m_Parent</a></td></tr>
<tr class="memdesc:px-m_Parent"><td class="mdescLeft">&#160;</td><td class="mdescRight">when initialized, this variable will be an instance of a <a class="el" href="classNativeParser" title="NativeParser class is just like a manager class to control Parser objects. ">NativeParser</a>  <a href="#px-m_Parent">More...</a><br /></td></tr>
<tr class="separator:px-m_Parent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:p6-m_Project"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcbProject">cbProject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#p6-m_Project">m_Project</a></td></tr>
<tr class="memdesc:p6-m_Project"><td class="mdescLeft">&#160;</td><td class="mdescRight">referring to the C::B cbp project currently parsing in one parser per workspace mode  <a href="#p6-m_Project">More...</a><br /></td></tr>
<tr class="separator:p6-m_Project"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rx-m_ReparseTimer"><td class="memItemLeft" align="right" valign="top">wxTimer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#rx-m_ReparseTimer">m_ReparseTimer</a></td></tr>
<tr class="memdesc:rx-m_ReparseTimer"><td class="mdescLeft">&#160;</td><td class="mdescRight">a file is need to be reparsed, maybe another file will to be reparsed very soon, so use a timer to collect all the files need to be reparsed.  <a href="#rx-m_ReparseTimer">More...</a><br /></td></tr>
<tr class="separator:rx-m_ReparseTimer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga-m_BatchTimer"><td class="memItemLeft" align="right" valign="top">wxTimer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#ga-m_BatchTimer">m_BatchTimer</a></td></tr>
<tr class="memdesc:ga-m_BatchTimer"><td class="mdescLeft">&#160;</td><td class="mdescRight">a timer to delay the operation of batch parsing, see <a class="el" href="classParser#qb-OnBatchTimer" title="A timer is used to optimized the event handling for parsing, e.g. ">OnBatchTimer()</a> member function as a reference  <a href="#ga-m_BatchTimer">More...</a><br /></td></tr>
<tr class="separator:ga-m_BatchTimer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:re-m_StopWatch"><td class="memItemLeft" align="right" valign="top">wxStopWatch&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#re-m_StopWatch">m_StopWatch</a></td></tr>
<tr class="memdesc:re-m_StopWatch"><td class="mdescLeft">&#160;</td><td class="mdescRight">a stop watch to measure parsing time  <a href="#re-m_StopWatch">More...</a><br /></td></tr>
<tr class="separator:re-m_StopWatch"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:hu-m_StopWatchRunning"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#hu-m_StopWatchRunning">m_StopWatchRunning</a></td></tr>
<tr class="separator:hu-m_StopWatchRunning"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sf-m_LastStopWatchTime"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#sf-m_LastStopWatchTime">m_LastStopWatchTime</a></td></tr>
<tr class="separator:sf-m_LastStopWatchTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:we-m_IgnoreThreadEvents"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#we-m_IgnoreThreadEvents">m_IgnoreThreadEvents</a></td></tr>
<tr class="memdesc:we-m_IgnoreThreadEvents"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classParser#dq-OnAllThreadsDone" title="When a ThreadPool batch parse stage is done, it will issue a cbEVT_THREADTASK_ALLDONE message...">Parser::OnAllThreadsDone</a> will be called when m_Pool finished its job, but when we run a batch parsing, we may receive several such event from the m_Pool, because 1, when <a class="el" href="classParserThreadedTask">ParserThreadedTask</a> finished 2, when batchFiles get finished 3, mark C::B project files's token as local.  <a href="#we-m_IgnoreThreadEvents">More...</a><br /></td></tr>
<tr class="separator:we-m_IgnoreThreadEvents"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:x1-m_BatchParseFiles"><td class="memItemLeft" align="right" valign="top"><a class="el" href="parser__base_8h#ks-StringList">StringList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#x1-m_BatchParseFiles">m_BatchParseFiles</a></td></tr>
<tr class="memdesc:x1-m_BatchParseFiles"><td class="mdescLeft">&#160;</td><td class="mdescRight">All other batch parse files, like the normal headers/sources.  <a href="#x1-m_BatchParseFiles">More...</a><br /></td></tr>
<tr class="separator:x1-m_BatchParseFiles"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ck-m_PredefinedMacros"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#ck-m_PredefinedMacros">m_PredefinedMacros</a></td></tr>
<tr class="memdesc:ck-m_PredefinedMacros"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-defined macros, its a buffer queried from the compiler command line.  <a href="#ck-m_PredefinedMacros">More...</a><br /></td></tr>
<tr class="separator:ck-m_PredefinedMacros"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:su-m_LastPredefinedMacros"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#su-m_LastPredefinedMacros">m_LastPredefinedMacros</a></td></tr>
<tr class="separator:su-m_LastPredefinedMacros"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ph-m_IsBatchParseDone"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#ph-m_IsBatchParseDone">m_IsBatchParseDone</a></td></tr>
<tr class="memdesc:ph-m_IsBatchParseDone"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to measure batch parse time  <a href="#ph-m_IsBatchParseDone">More...</a><br /></td></tr>
<tr class="separator:ph-m_IsBatchParseDone"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:g0-m_ParserState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceParserCommon#a0-ParserState">ParserCommon::ParserState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#g0-m_ParserState">m_ParserState</a></td></tr>
<tr class="memdesc:g0-m_ParserState"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicated the current state the parser  <a href="#g0-m_ParserState">More...</a><br /></td></tr>
<tr class="separator:g0-m_ParserState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:k3-m_NeedMarkFileAsLocal"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#k3-m_NeedMarkFileAsLocal">m_NeedMarkFileAsLocal</a></td></tr>
<tr class="memdesc:k3-m_NeedMarkFileAsLocal"><td class="mdescLeft">&#160;</td><td class="mdescRight">if true, all the files of the current project will be labeled as "local"  <a href="#k3-m_NeedMarkFileAsLocal">More...</a><br /></td></tr>
<tr class="separator:k3-m_NeedMarkFileAsLocal"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rp-m_tasksQueue"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParser#xu-TasksQueue">TasksQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#rp-m_tasksQueue">m_tasksQueue</a></td></tr>
<tr class="separator:rp-m_tasksQueue"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:es-ParserThreadedTask"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser#es-ParserThreadedTask">ParserThreadedTask</a></td></tr>
<tr class="separator:es-ParserThreadedTask"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> class holds all the tokens of a C::B project. </p>
<p><a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> class contains the <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> which is a trie structure to record the token information. For details about trie, see <a href="http://en.wikipedia.org/wiki/Trie">http://en.wikipedia.org/wiki/Trie</a> The parser class manages <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> threaded Tasks in a ThreadPool. A <a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a> object is associated with a single source file. Batch parse mode means we have a lot of files to be parsed, so a lot of ParserThreads were generated and added to the ThreadPool, and finally, the <a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a> was executed by ThreadPool. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="xu-TasksQueue"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="classcbThreadedTask">cbThreadedTask</a>*&gt; <a class="el" href="classParser#xu-TasksQueue">Parser::TasksQueue</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list to contain pointers to internal running threads. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="l5-Parser"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parser::Parser </td>
          <td>(</td>
          <td class="paramtype">wxEvtHandler *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcbProject">cbProject</a> *&#160;</td>
          <td class="paramname"><em>project</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>which is actually a <a class="el" href="classNativeParser" title="NativeParser class is just like a manager class to control Parser objects. ">NativeParser</a> object </td></tr>
    <tr><td class="paramname">project</td><td>the C::B project associated with the current <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classParser#rz-ConnectEvents">ConnectEvents()</a>, and <a class="el" href="classParser#gu-ReadOptions">ReadOptions()</a>.</p>

</div>
</div>
<a class="anchor" id="ij-Parser"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parser::~Parser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>

<p>References <a class="el" href="cclogger_8h#ir-CC_LOCKER_TRACK_P_MTX_LOCK">CC_LOCKER_TRACK_P_MTX_LOCK</a>, <a class="el" href="cclogger_8h#iw-CC_LOCKER_TRACK_P_MTX_UNLOCK">CC_LOCKER_TRACK_P_MTX_UNLOCK</a>, <a class="el" href="classParser#f8-DisconnectEvents">DisconnectEvents()</a>, <a class="el" href="namespaceParserCommon#el-s_CurrentParser">ParserCommon::s_CurrentParser</a>, <a class="el" href="namespaceParserCommon#ir-s_ParserMutex">ParserCommon::s_ParserMutex</a>, and <a class="el" href="classParser#i0-TerminateAllThreads">TerminateAllThreads()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="x2-AbortParserThreads"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::AbortParserThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell internal running threads to abort further processing. </p>

<p>References <a class="el" href="classParser#rp-m_tasksQueue">m_tasksQueue</a>.</p>

<p>Referenced by <a class="el" href="classParser#i0-TerminateAllThreads">TerminateAllThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="uw-AddBatchParse"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::AddBatchParse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="parser__base_8h#ks-StringList">StringList</a> &amp;&#160;</td>
          <td class="paramname"><em>filenames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add files to batch parse mode, internally. </p>
<p>The files will be parsed sequentially. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filenames</td><td>input files name array </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="cclogger_8h#ir-CC_LOCKER_TRACK_P_MTX_LOCK">CC_LOCKER_TRACK_P_MTX_LOCK</a>, <a class="el" href="cclogger_8h#iw-CC_LOCKER_TRACK_P_MTX_UNLOCK">CC_LOCKER_TRACK_P_MTX_UNLOCK</a>, <a class="el" href="classParser#x1-m_BatchParseFiles">m_BatchParseFiles</a>, <a class="el" href="classParser#ga-m_BatchTimer">m_BatchTimer</a>, <a class="el" href="classParser#oc-m_IsParsing">m_IsParsing</a>, <a class="el" href="classParser#g0-m_ParserState">m_ParserState</a>, <a class="el" href="namespaceParserCommon#fm-PARSER_BATCHPARSE_TIMER_DELAY">ParserCommon::PARSER_BATCHPARSE_TIMER_DELAY</a>, <a class="el" href="namespaceParserCommon#a0-ParserState:ptCreateParser">ParserCommon::ptCreateParser</a>, <a class="el" href="namespaceParserCommon#a0-ParserState:ptUndefined">ParserCommon::ptUndefined</a>, <a class="el" href="namespaceParserCommon#ir-s_ParserMutex">ParserCommon::s_ParserMutex</a>, and <a class="el" href="parser_8cpp#qa-TRACE">TRACE</a>.</p>

</div>
</div>
<a class="anchor" id="sc-AddFile"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::AddFile </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcbProject">cbProject</a> *&#160;</td>
          <td class="paramname"><em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLocal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this usually happens when user adds some files to an existing project, it just use <a class="el" href="classParser#g2-AddParse" title="Add one file to Batch mode Parsing, this is the bridge between the main thread and the thread pool...">AddParse()</a> function internally to add the file. </p>
<p>and switch the ParserState to <a class="el" href="namespaceParserCommon#a0-ParserState:ptAddFileToParser" title="the user has add some files to the cbproject, so we are parsing the new added files ...">ParserCommon::ptAddFileToParser</a>. </p>

<p>References <a class="el" href="classParser#g2-AddParse">AddParse()</a>, <a class="el" href="classParser#pg-IsFileParsed">IsFileParsed()</a>, <a class="el" href="classParser#k3-m_NeedMarkFileAsLocal">m_NeedMarkFileAsLocal</a>, <a class="el" href="classParser#g0-m_ParserState">m_ParserState</a>, <a class="el" href="classParser#p6-m_Project">m_Project</a>, <a class="el" href="namespaceParserCommon#a0-ParserState:ptAddFileToParser">ParserCommon::ptAddFileToParser</a>, and <a class="el" href="namespaceParserCommon#a0-ParserState:ptUndefined">ParserCommon::ptUndefined</a>.</p>

</div>
</div>
<a class="anchor" id="g2-AddParse"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::AddParse </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add one file to Batch mode Parsing, this is the bridge between the main thread and the thread pool, after this function call, the file(Parserthread) will be run from the thread pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filenames</td><td>input file name </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="cclogger_8h#ir-CC_LOCKER_TRACK_P_MTX_LOCK">CC_LOCKER_TRACK_P_MTX_LOCK</a>, <a class="el" href="cclogger_8h#iw-CC_LOCKER_TRACK_P_MTX_UNLOCK">CC_LOCKER_TRACK_P_MTX_UNLOCK</a>, <a class="el" href="classParser#x1-m_BatchParseFiles">m_BatchParseFiles</a>, <a class="el" href="classParser#ga-m_BatchTimer">m_BatchTimer</a>, <a class="el" href="classParser#oc-m_IsParsing">m_IsParsing</a>, <a class="el" href="namespaceParserCommon#fm-PARSER_BATCHPARSE_TIMER_DELAY">ParserCommon::PARSER_BATCHPARSE_TIMER_DELAY</a>, <a class="el" href="namespaceParserCommon#ir-s_ParserMutex">ParserCommon::s_ParserMutex</a>, and <a class="el" href="parser_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParser#sc-AddFile">AddFile()</a>, and <a class="el" href="classParser#qq-ReparseModifiedFiles">ReparseModifiedFiles()</a>.</p>

</div>
</div>
<a class="anchor" id="ov-AddParserThread"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::AddParserThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcbThreadedTask">cbThreadedTask</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remember a newly created internal running threads. </p>

<p>References <a class="el" href="classParser#rp-m_tasksQueue">m_tasksQueue</a>.</p>

<p>Referenced by <a class="el" href="classParser#o1-Parse">Parse()</a>.</p>

</div>
</div>
<a class="anchor" id="lv-AddPredefinedMacros"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::AddPredefinedMacros </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>defs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the predefined macro definition string was collected from the GCC command line, this function adds the string to an internal m_PredefinedMacros, and switch the ParserState </p>

<p>References <a class="el" href="cclogger_8h#ir-CC_LOCKER_TRACK_P_MTX_LOCK">CC_LOCKER_TRACK_P_MTX_LOCK</a>, <a class="el" href="cclogger_8h#iw-CC_LOCKER_TRACK_P_MTX_UNLOCK">CC_LOCKER_TRACK_P_MTX_UNLOCK</a>, <a class="el" href="classParser#ga-m_BatchTimer">m_BatchTimer</a>, <a class="el" href="classParser#oc-m_IsParsing">m_IsParsing</a>, <a class="el" href="classParser#g0-m_ParserState">m_ParserState</a>, <a class="el" href="classParser#ck-m_PredefinedMacros">m_PredefinedMacros</a>, <a class="el" href="namespaceParserCommon#fm-PARSER_BATCHPARSE_TIMER_DELAY">ParserCommon::PARSER_BATCHPARSE_TIMER_DELAY</a>, <a class="el" href="namespaceParserCommon#a0-ParserState:ptCreateParser">ParserCommon::ptCreateParser</a>, <a class="el" href="namespaceParserCommon#a0-ParserState:ptUndefined">ParserCommon::ptUndefined</a>, <a class="el" href="namespaceParserCommon#ir-s_ParserMutex">ParserCommon::s_ParserMutex</a>, and <a class="el" href="parser_8cpp#qa-TRACE">TRACE</a>.</p>

</div>
</div>
<a class="anchor" id="vk-ClearPredefinedMacros"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::ClearPredefinedMacros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clears the list of predefined macros after it has been parsed </p>

<p>References <a class="el" href="cclogger_8h#ir-CC_LOCKER_TRACK_P_MTX_LOCK">CC_LOCKER_TRACK_P_MTX_LOCK</a>, <a class="el" href="cclogger_8h#iw-CC_LOCKER_TRACK_P_MTX_UNLOCK">CC_LOCKER_TRACK_P_MTX_UNLOCK</a>, <a class="el" href="classParser#su-m_LastPredefinedMacros">m_LastPredefinedMacros</a>, <a class="el" href="classParser#ck-m_PredefinedMacros">m_PredefinedMacros</a>, and <a class="el" href="namespaceParserCommon#ir-s_ParserMutex">ParserCommon::s_ParserMutex</a>.</p>

<p>Referenced by <a class="el" href="classParserThreadedTask#fr-Execute">ParserThreadedTask::Execute()</a>.</p>

</div>
</div>
<a class="anchor" id="rz-ConnectEvents"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::ConnectEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>connect event handlers of the timers and thread pool </p>

<p>References <a class="el" href="sdk__events_8h#p3-cbEVT_THREADTASK_ALLDONE">cbEVT_THREADTASK_ALLDONE</a>, <a class="el" href="classcbThreadPool#pl-GetId">cbThreadPool::GetId()</a>, <a class="el" href="classParser#ga-m_BatchTimer">m_BatchTimer</a>, <a class="el" href="classParser#l6-m_Pool">m_Pool</a>, <a class="el" href="classParser#rx-m_ReparseTimer">m_ReparseTimer</a>, <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>, <a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer()</a>, and <a class="el" href="classParser#ya-OnReparseTimer">OnReparseTimer()</a>.</p>

<p>Referenced by <a class="el" href="classParser#l5-Parser">Parser()</a>.</p>

</div>
</div>
<a class="anchor" id="f8-DisconnectEvents"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::DisconnectEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>connect event handlers of the timers and thread pool </p>

<p>References <a class="el" href="sdk__events_8h#p3-cbEVT_THREADTASK_ALLDONE">cbEVT_THREADTASK_ALLDONE</a>, <a class="el" href="classcbThreadPool#pl-GetId">cbThreadPool::GetId()</a>, <a class="el" href="classParser#ga-m_BatchTimer">m_BatchTimer</a>, <a class="el" href="classParser#l6-m_Pool">m_Pool</a>, <a class="el" href="classParser#rx-m_ReparseTimer">m_ReparseTimer</a>, <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>, <a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer()</a>, and <a class="el" href="classParser#ya-OnReparseTimer">OnReparseTimer()</a>.</p>

<p>Referenced by <a class="el" href="classParser#ij-Parser">~Parser()</a>.</p>

</div>
</div>
<a class="anchor" id="hu-Done"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check to see whether <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> is in Idle mode, there is no work need to be done in the <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> </p>

<p>Reimplemented from <a class="el" href="classParserBase#ck-Done">ParserBase</a>.</p>

<p>References <a class="el" href="cclogger_8h#ir-CC_LOCKER_TRACK_P_MTX_LOCK">CC_LOCKER_TRACK_P_MTX_LOCK</a>, <a class="el" href="cclogger_8h#iw-CC_LOCKER_TRACK_P_MTX_UNLOCK">CC_LOCKER_TRACK_P_MTX_UNLOCK</a>, <a class="el" href="classcbThreadPool#lj-Done">cbThreadPool::Done()</a>, <a class="el" href="classParser#x1-m_BatchParseFiles">m_BatchParseFiles</a>, <a class="el" href="classParser#k3-m_NeedMarkFileAsLocal">m_NeedMarkFileAsLocal</a>, <a class="el" href="classParser#l6-m_Pool">m_Pool</a>, <a class="el" href="classParser#ck-m_PredefinedMacros">m_PredefinedMacros</a>, and <a class="el" href="namespaceParserCommon#ir-s_ParserMutex">ParserCommon::s_ParserMutex</a>.</p>

<p>Referenced by <a class="el" href="classParser#zd-Reparse">Reparse()</a>, <a class="el" href="classParser#qq-ReparseModifiedFiles">ReparseModifiedFiles()</a>, and <a class="el" href="classParser#rn-UpdateParsingProject">UpdateParsingProject()</a>.</p>

</div>
</div>
<a class="anchor" id="qu-EndStopWatch"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::EndStopWatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classParser#ph-m_IsBatchParseDone">m_IsBatchParseDone</a>, <a class="el" href="classParser#sf-m_LastStopWatchTime">m_LastStopWatchTime</a>, <a class="el" href="classParser#re-m_StopWatch">m_StopWatch</a>, and <a class="el" href="classParser#hu-m_StopWatchRunning">m_StopWatchRunning</a>.</p>

<p>Referenced by <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>.</p>

</div>
</div>
<a class="anchor" id="it-GetMaxThreads"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Parser::GetMaxThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Node: Currently, the max. </p>
<p>concurrent <a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a> number should be ONE, CC does not support multiply threads parsing. </p>

<p>References <a class="el" href="classcbThreadPool#ck-GetConcurrentThreads">cbThreadPool::GetConcurrentThreads()</a>, and <a class="el" href="classParser#l6-m_Pool">m_Pool</a>.</p>

</div>
</div>
<a class="anchor" id="s5-GetPredefinedMacros"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wxString Parser::GetPredefinedMacros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the predefined macro definition string that has been collected </p>

<p>Reimplemented from <a class="el" href="classParserBase#r7-GetPredefinedMacros">ParserBase</a>.</p>

<p>References <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, and <a class="el" href="classParser#su-m_LastPredefinedMacros">m_LastPredefinedMacros</a>.</p>

</div>
</div>
<a class="anchor" id="pg-IsFileParsed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::IsFileParsed </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check to see a file is parsed already, it first check the <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> to see whether it has the specified file, but if a file is already queued (put in m_BatchParseFiles), we regard it as already parsed. </p>

<p>References <a class="el" href="cclogger_8h#ir-CC_LOCKER_TRACK_P_MTX_LOCK">CC_LOCKER_TRACK_P_MTX_LOCK</a>, <a class="el" href="cclogger_8h#iw-CC_LOCKER_TRACK_P_MTX_UNLOCK">CC_LOCKER_TRACK_P_MTX_UNLOCK</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classTokenTree#vv-IsFileParsed">TokenTree::IsFileParsed()</a>, <a class="el" href="classParser#x1-m_BatchParseFiles">m_BatchParseFiles</a>, <a class="el" href="classParserBase#cr-m_TokenTree">ParserBase::m_TokenTree</a>, <a class="el" href="namespaceParserCommon#ir-s_ParserMutex">ParserCommon::s_ParserMutex</a>, and <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>.</p>

<p>Referenced by <a class="el" href="classParser#sc-AddFile">AddFile()</a>.</p>

</div>
</div>
<a class="anchor" id="wi-NotDoneReason"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Parser::NotDoneReason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if the <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> is not in Idle mode, show which need to be done </p>

<p>Reimplemented from <a class="el" href="classParserBase#ek-NotDoneReason">ParserBase</a>.</p>

<p>References <a class="el" href="cclogger_8h#ir-CC_LOCKER_TRACK_P_MTX_LOCK">CC_LOCKER_TRACK_P_MTX_LOCK</a>, <a class="el" href="cclogger_8h#iw-CC_LOCKER_TRACK_P_MTX_UNLOCK">CC_LOCKER_TRACK_P_MTX_UNLOCK</a>, <a class="el" href="classcbThreadPool#lj-Done">cbThreadPool::Done()</a>, <a class="el" href="classParser#x1-m_BatchParseFiles">m_BatchParseFiles</a>, <a class="el" href="classParser#k3-m_NeedMarkFileAsLocal">m_NeedMarkFileAsLocal</a>, <a class="el" href="classParser#l6-m_Pool">m_Pool</a>, <a class="el" href="classParser#ck-m_PredefinedMacros">m_PredefinedMacros</a>, and <a class="el" href="namespaceParserCommon#ir-s_ParserMutex">ParserCommon::s_ParserMutex</a>.</p>

<p>Referenced by <a class="el" href="classParser#zd-Reparse">Reparse()</a>, <a class="el" href="classParser#qq-ReparseModifiedFiles">ReparseModifiedFiles()</a>, and <a class="el" href="classParser#rn-UpdateParsingProject">UpdateParsingProject()</a>.</p>

</div>
</div>
<a class="anchor" id="dq-OnAllThreadsDone"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::OnAllThreadsDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCodeBlocksEvent">CodeBlocksEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When a ThreadPool batch parse stage is done, it will issue a cbEVT_THREADTASK_ALLDONE message. </p>
<p>In some situations this event will be triggered, such as:</p><ul>
<li>batch parsing for cpp source files</li>
<li>mark tokens belong to the cb project as local tokens </li>
</ul>

<p>References <a class="el" href="classcbThreadPool#rm-AddTask">cbThreadPool::AddTask()</a>, <a class="el" href="cbexception_8h#g4-cbThrow">cbThrow</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="classParser#qu-EndStopWatch">EndStopWatch()</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, <a class="el" href="classTokenTree#fi-GetFileMapSize">TokenTree::GetFileMapSize()</a>, <a class="el" href="classcbThreadPool#pl-GetId">cbThreadPool::GetId()</a>, <a class="el" href="classCompileTargetBase#fk-GetTitle">CompileTargetBase::GetTitle()</a>, <a class="el" href="namespaceParserCommon#sw-idParserEnd">ParserCommon::idParserEnd</a>, <a class="el" href="classManager#li-IsAppShuttingDown">Manager::IsAppShuttingDown()</a>, <a class="el" href="classParser#x1-m_BatchParseFiles">m_BatchParseFiles</a>, <a class="el" href="classParser#ga-m_BatchTimer">m_BatchTimer</a>, <a class="el" href="classParser#we-m_IgnoreThreadEvents">m_IgnoreThreadEvents</a>, <a class="el" href="classParser#ph-m_IsBatchParseDone">m_IsBatchParseDone</a>, <a class="el" href="classParser#oc-m_IsParsing">m_IsParsing</a>, <a class="el" href="classParser#sf-m_LastStopWatchTime">m_LastStopWatchTime</a>, <a class="el" href="classParser#k3-m_NeedMarkFileAsLocal">m_NeedMarkFileAsLocal</a>, <a class="el" href="classParser#b7-m_NeedsReparse">m_NeedsReparse</a>, <a class="el" href="classParser#g0-m_ParserState">m_ParserState</a>, <a class="el" href="classParser#l6-m_Pool">m_Pool</a>, <a class="el" href="classParser#ck-m_PredefinedMacros">m_PredefinedMacros</a>, <a class="el" href="classParser#p6-m_Project">m_Project</a>, <a class="el" href="classParserBase#cr-m_TokenTree">ParserBase::m_TokenTree</a>, <a class="el" href="namespaceParserCommon#al-PARSER_BATCHPARSE_TIMER_RUN_I">ParserCommon::PARSER_BATCHPARSE_TIMER_RUN_IMMEDIATELY</a>, <a class="el" href="classParser#jo-ProcessParserEvent">ProcessParserEvent()</a>, <a class="el" href="namespaceParserCommon#a0-ParserState:ptAddFileToParser">ParserCommon::ptAddFileToParser</a>, <a class="el" href="namespaceParserCommon#a0-ParserState:ptCreateParser">ParserCommon::ptCreateParser</a>, <a class="el" href="namespaceParserCommon#a0-ParserState:ptUndefined">ParserCommon::ptUndefined</a>, <a class="el" href="classTokenTree#rf-realsize">TokenTree::realsize()</a>, <a class="el" href="namespaceParserCommon#el-s_CurrentParser">ParserCommon::s_CurrentParser</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, and <a class="el" href="parser_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParser#rz-ConnectEvents">ConnectEvents()</a>, and <a class="el" href="classParser#f8-DisconnectEvents">DisconnectEvents()</a>.</p>

</div>
</div>
<a class="anchor" id="qb-OnBatchTimer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::OnBatchTimer </td>
          <td>(</td>
          <td class="paramtype">wxTimerEvent &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A timer is used to optimized the event handling for parsing, e.g. </p>
<p>several files/projects were added to the project, so we don't start the real parsing stage until the last file/project was added, </p>

<p>References <a class="el" href="classcbThreadPool#rm-AddTask">cbThreadPool::AddTask()</a>, <a class="el" href="cclogger_8h#ir-CC_LOCKER_TRACK_P_MTX_LOCK">CC_LOCKER_TRACK_P_MTX_LOCK</a>, <a class="el" href="cclogger_8h#iw-CC_LOCKER_TRACK_P_MTX_UNLOCK">CC_LOCKER_TRACK_P_MTX_UNLOCK</a>, <a class="el" href="namespaceParserCommon#da-idParserStart">ParserCommon::idParserStart</a>, <a class="el" href="classManager#li-IsAppShuttingDown">Manager::IsAppShuttingDown()</a>, <a class="el" href="classParser#x1-m_BatchParseFiles">m_BatchParseFiles</a>, <a class="el" href="classParser#ga-m_BatchTimer">m_BatchTimer</a>, <a class="el" href="classParser#g0-m_ParserState">m_ParserState</a>, <a class="el" href="classParser#l6-m_Pool">m_Pool</a>, <a class="el" href="classParser#ck-m_PredefinedMacros">m_PredefinedMacros</a>, <a class="el" href="classParser#re-m_StopWatch">m_StopWatch</a>, <a class="el" href="namespaceParserCommon#id-PARSER_BATCHPARSE_TIMER_DELAY">ParserCommon::PARSER_BATCHPARSE_TIMER_DELAY_LONG</a>, <a class="el" href="classParser#es-ParserThreadedTask">ParserThreadedTask</a>, <a class="el" href="classParser#jo-ProcessParserEvent">ProcessParserEvent()</a>, <a class="el" href="namespaceParserCommon#a0-ParserState:ptUndefined">ParserCommon::ptUndefined</a>, <a class="el" href="namespaceParserCommon#el-s_CurrentParser">ParserCommon::s_CurrentParser</a>, <a class="el" href="namespaceParserCommon#ir-s_ParserMutex">ParserCommon::s_ParserMutex</a>, <a class="el" href="classParser#zj-StartStopWatch">StartStopWatch()</a>, and <a class="el" href="parser_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParser#rz-ConnectEvents">ConnectEvents()</a>, and <a class="el" href="classParser#f8-DisconnectEvents">DisconnectEvents()</a>.</p>

</div>
</div>
<a class="anchor" id="ya-OnReparseTimer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::OnReparseTimer </td>
          <td>(</td>
          <td class="paramtype">wxTimerEvent &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>some files in the Tokentree is marked as need to be reparsed, this can be done by a call of <a class="el" href="classParser#zd-Reparse" title="mark this file to be re-parsed in the TokenTree, tick the reparse timer, note it looks like the isLoc...">Reparse()</a> before. </p>
<p>So, in this timer event handler, we need to remove all the tokens of files in the Tree, and then re-parse them again. This is done by <a class="el" href="classParser#g2-AddParse" title="Add one file to Batch mode Parsing, this is the bridge between the main thread and the thread pool...">AddParse()</a> again. the <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> status now switch to <a class="el" href="namespaceParserCommon#a0-ParserState:ptReparseFile" title="some files are changed by the user, so we are parsing the changed files ">ParserCommon::ptReparseFile</a>. </p>

<p>References <a class="el" href="classParser#qq-ReparseModifiedFiles">ReparseModifiedFiles()</a>.</p>

<p>Referenced by <a class="el" href="classParser#rz-ConnectEvents">ConnectEvents()</a>, and <a class="el" href="classParser#f8-DisconnectEvents">DisconnectEvents()</a>.</p>

</div>
</div>
<a class="anchor" id="o1-Parse"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Parse </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLocal</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>locked</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parse the file, either immediately or delayed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isLocal</td><td>true if the file belong to a C::B project </td></tr>
    <tr><td class="paramname">locked</td><td>give the status of the Tokentree, false means the tree is not locked </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classParser#ov-AddParserThread">AddParserThread()</a>, <a class="el" href="classcbThreadPool#rm-AddTask">cbThreadPool::AddTask()</a>, <a class="el" href="structParserThreadOptions#m7-bufferSkipBlocks">ParserThreadOptions::bufferSkipBlocks</a>, <a class="el" href="structParserThreadOptions#mc-bufferSkipOuterBlocks">ParserThreadOptions::bufferSkipOuterBlocks</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="structParserThreadOptions#k0-followGlobalIncludes">ParserThreadOptions::followGlobalIncludes</a>, <a class="el" href="structParserOptions#r4-followGlobalIncludes">ParserOptions::followGlobalIncludes</a>, <a class="el" href="structParserThreadOptions#zu-followLocalIncludes">ParserThreadOptions::followLocalIncludes</a>, <a class="el" href="structParserOptions#rw-followLocalIncludes">ParserOptions::followLocalIncludes</a>, <a class="el" href="classManager#rz-Get">Manager::Get()</a>, <a class="el" href="classManager#ez-GetFileManager">Manager::GetFileManager()</a>, <a class="el" href="classTokenTree#vv-IsFileParsed">TokenTree::IsFileParsed()</a>, <a class="el" href="classFileManager#cn-Load">FileManager::Load()</a>, <a class="el" href="structParserThreadOptions#li-loader">ParserThreadOptions::loader</a>, <a class="el" href="classParser#b7-m_NeedsReparse">m_NeedsReparse</a>, <a class="el" href="classParserBase#em-m_Options">ParserBase::m_Options</a>, <a class="el" href="classParser#l6-m_Pool">m_Pool</a>, <a class="el" href="classParserBase#cr-m_TokenTree">ParserBase::m_TokenTree</a>, <a class="el" href="classParserThread#te-Parse">ParserThread::Parse()</a>, <a class="el" href="structParserThreadOptions#y8-parseComplexMacros">ParserThreadOptions::parseComplexMacros</a>, <a class="el" href="structParserOptions#q8-parseComplexMacros">ParserOptions::parseComplexMacros</a>, <a class="el" href="classParserBase#ne-ParserThread">ParserBase::ParserThread</a>, <a class="el" href="structParserThreadOptions#kw-platformCheck">ParserThreadOptions::platformCheck</a>, <a class="el" href="structParserOptions#a3-platformCheck">ParserOptions::platformCheck</a>, <a class="el" href="classParser#z8-RemoveParserThread">RemoveParserThread()</a>, <a class="el" href="classTokenTree#na-ReserveFileForParsing">TokenTree::ReserveFileForParsing()</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, <a class="el" href="structParserThreadOptions#x0-storeDocumentation">ParserThreadOptions::storeDocumentation</a>, <a class="el" href="structParserOptions#wh-storeDocumentation">ParserOptions::storeDocumentation</a>, <a class="el" href="parser_8cpp#qa-TRACE">TRACE</a>, <a class="el" href="structParserThreadOptions#du-useBuffer">ParserThreadOptions::useBuffer</a>, <a class="el" href="structParserThreadOptions#ju-wantPreprocessor">ParserThreadOptions::wantPreprocessor</a>, and <a class="el" href="structParserOptions#qw-wantPreprocessor">ParserOptions::wantPreprocessor</a>.</p>

<p>Referenced by <a class="el" href="classParserThreadedTask#fr-Execute">ParserThreadedTask::Execute()</a>, and <a class="el" href="classParser#rp-ParseFile">ParseFile()</a>.</p>

</div>
</div>
<a class="anchor" id="or-ParseBuffer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::ParseBuffer </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLocal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bufferSkipBlocks</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isTemp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>wxEmptyString</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parentIdx</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initLine</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must add a locker before call all named ParseBufferXXX functions, ParseBuffer function will directly run the parsing in the same thread as the caller. </p>
<p>So, take care if the time is limited. this function usually used to parse the function body to fetch the local variable information. </p>

<p>Reimplemented from <a class="el" href="classParserBase#kd-ParseBuffer">ParserBase</a>.</p>

<p>References <a class="el" href="structParserThreadOptions#m7-bufferSkipBlocks">ParserThreadOptions::bufferSkipBlocks</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="structParserThreadOptions#pm-fileOfBuffer">ParserThreadOptions::fileOfBuffer</a>, <a class="el" href="structParserThreadOptions#k0-followGlobalIncludes">ParserThreadOptions::followGlobalIncludes</a>, <a class="el" href="structParserThreadOptions#zu-followLocalIncludes">ParserThreadOptions::followLocalIncludes</a>, <a class="el" href="structParserThreadOptions#wc-handleFunctions">ParserThreadOptions::handleFunctions</a>, <a class="el" href="structParserThreadOptions#ui-initLineOfBuffer">ParserThreadOptions::initLineOfBuffer</a>, <a class="el" href="structParserThreadOptions#s3-isTemp">ParserThreadOptions::isTemp</a>, <a class="el" href="classParserBase#em-m_Options">ParserBase::m_Options</a>, <a class="el" href="classParserBase#cr-m_TokenTree">ParserBase::m_TokenTree</a>, <a class="el" href="structParserThreadOptions#ud-parentIdxOfBuffer">ParserThreadOptions::parentIdxOfBuffer</a>, <a class="el" href="classParserThread#te-Parse">ParserThread::Parse()</a>, <a class="el" href="structParserThreadOptions#y8-parseComplexMacros">ParserThreadOptions::parseComplexMacros</a>, <a class="el" href="structParserOptions#q8-parseComplexMacros">ParserOptions::parseComplexMacros</a>, <a class="el" href="structParserThreadOptions#kw-platformCheck">ParserThreadOptions::platformCheck</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, <a class="el" href="structParserThreadOptions#x0-storeDocumentation">ParserThreadOptions::storeDocumentation</a>, <a class="el" href="structParserOptions#wh-storeDocumentation">ParserOptions::storeDocumentation</a>, <a class="el" href="structParserThreadOptions#du-useBuffer">ParserThreadOptions::useBuffer</a>, <a class="el" href="structParserThreadOptions#ju-wantPreprocessor">ParserThreadOptions::wantPreprocessor</a>, and <a class="el" href="structParserOptions#qw-wantPreprocessor">ParserOptions::wantPreprocessor</a>.</p>

<p>Referenced by <a class="el" href="classParserThreadedTask#fr-Execute">ParserThreadedTask::Execute()</a>.</p>

</div>
</div>
<a class="anchor" id="nz-ParseBufferForFunctions"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::ParseBufferForFunctions </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parser the current editor control, this function is used to list all the functions in the current code editor </p>

<p>References <a class="el" href="structParserThreadOptions#m7-bufferSkipBlocks">ParserThreadOptions::bufferSkipBlocks</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="structParserThreadOptions#k0-followGlobalIncludes">ParserThreadOptions::followGlobalIncludes</a>, <a class="el" href="structParserThreadOptions#zu-followLocalIncludes">ParserThreadOptions::followLocalIncludes</a>, <a class="el" href="structParserThreadOptions#wc-handleFunctions">ParserThreadOptions::handleFunctions</a>, <a class="el" href="classParserBase#em-m_Options">ParserBase::m_Options</a>, <a class="el" href="classParserBase#ow-m_TempTokenTree">ParserBase::m_TempTokenTree</a>, <a class="el" href="classParserThread#te-Parse">ParserThread::Parse()</a>, <a class="el" href="structParserThreadOptions#y8-parseComplexMacros">ParserThreadOptions::parseComplexMacros</a>, <a class="el" href="structParserOptions#q8-parseComplexMacros">ParserOptions::parseComplexMacros</a>, <a class="el" href="structParserThreadOptions#kw-platformCheck">ParserThreadOptions::platformCheck</a>, <a class="el" href="structParserOptions#a3-platformCheck">ParserOptions::platformCheck</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, <a class="el" href="structParserThreadOptions#x0-storeDocumentation">ParserThreadOptions::storeDocumentation</a>, <a class="el" href="structParserOptions#wh-storeDocumentation">ParserOptions::storeDocumentation</a>, <a class="el" href="structParserThreadOptions#du-useBuffer">ParserThreadOptions::useBuffer</a>, <a class="el" href="structParserThreadOptions#ju-wantPreprocessor">ParserThreadOptions::wantPreprocessor</a>, and <a class="el" href="structParserOptions#qw-wantPreprocessor">ParserOptions::wantPreprocessor</a>.</p>

</div>
</div>
<a class="anchor" id="jn-ParseBufferForNamespaces"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::ParseBufferForNamespaces </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parserthread_8h#ia-NameSpaceVec">NameSpaceVec</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parse the buffer for collecting exposed namespace scopes </p>

<p>References <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="structParserThreadOptions#k0-followGlobalIncludes">ParserThreadOptions::followGlobalIncludes</a>, <a class="el" href="structParserThreadOptions#zu-followLocalIncludes">ParserThreadOptions::followLocalIncludes</a>, <a class="el" href="classParserBase#em-m_Options">ParserBase::m_Options</a>, <a class="el" href="classParserBase#ow-m_TempTokenTree">ParserBase::m_TempTokenTree</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, <a class="el" href="structParserThreadOptions#y8-parseComplexMacros">ParserThreadOptions::parseComplexMacros</a>, <a class="el" href="structParserThreadOptions#kw-platformCheck">ParserThreadOptions::platformCheck</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, <a class="el" href="structParserThreadOptions#x0-storeDocumentation">ParserThreadOptions::storeDocumentation</a>, <a class="el" href="structParserOptions#wh-storeDocumentation">ParserOptions::storeDocumentation</a>, <a class="el" href="structParserThreadOptions#du-useBuffer">ParserThreadOptions::useBuffer</a>, <a class="el" href="structParserThreadOptions#ju-wantPreprocessor">ParserThreadOptions::wantPreprocessor</a>, and <a class="el" href="structParserOptions#qw-wantPreprocessor">ParserOptions::wantPreprocessor</a>.</p>

</div>
</div>
<a class="anchor" id="u4-ParseBufferForUsingNamespace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::ParseBufferForUsingNamespace </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxArrayString &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bufferSkipBlocks</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parse the buffer for collecting using namespace directive </p>

<p>References <a class="el" href="structParserThreadOptions#m7-bufferSkipBlocks">ParserThreadOptions::bufferSkipBlocks</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="structParserThreadOptions#k0-followGlobalIncludes">ParserThreadOptions::followGlobalIncludes</a>, <a class="el" href="structParserThreadOptions#zu-followLocalIncludes">ParserThreadOptions::followLocalIncludes</a>, <a class="el" href="classParserBase#em-m_Options">ParserBase::m_Options</a>, <a class="el" href="classParserBase#ow-m_TempTokenTree">ParserBase::m_TempTokenTree</a>, <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParserThread::ParseBufferForUsingNamespace()</a>, <a class="el" href="structParserThreadOptions#y8-parseComplexMacros">ParserThreadOptions::parseComplexMacros</a>, <a class="el" href="structParserThreadOptions#kw-platformCheck">ParserThreadOptions::platformCheck</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, <a class="el" href="structParserThreadOptions#x0-storeDocumentation">ParserThreadOptions::storeDocumentation</a>, <a class="el" href="structParserOptions#wh-storeDocumentation">ParserOptions::storeDocumentation</a>, <a class="el" href="structParserThreadOptions#du-useBuffer">ParserThreadOptions::useBuffer</a>, <a class="el" href="structParserThreadOptions#ju-wantPreprocessor">ParserThreadOptions::wantPreprocessor</a>, and <a class="el" href="structParserOptions#qw-wantPreprocessor">ParserOptions::wantPreprocessor</a>.</p>

</div>
</div>
<a class="anchor" id="rp-ParseFile"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::ParseFile </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGlobal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>locked</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the only usage of this function is in the Parserthread class, when handling include directives the parserthread use some call like m_Parent-&gt;<a class="el" href="classParser#rp-ParseFile" title="the only usage of this function is in the Parserthread class, when handling include directives the pa...">ParseFile()</a> to call this function, but this function just call <a class="el" href="classParser#o1-Parse" title="parse the file, either immediately or delayed. ">Parser::Parse()</a> function, which either run the syntax analysis immediately or create a parsing task in the Pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the file we want to parse </td></tr>
    <tr><td class="paramname">isGlobal</td><td>true if the file is not belong to a C::B project </td></tr>
    <tr><td class="paramname">locked</td><td>true if the <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> is locked. when initially parse a translation unit file the locked should be set as false, but if you want to recursive parse to an include file the locked value should be set as true. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classParserBase#o7-ParseFile">ParserBase</a>.</p>

<p>References <a class="el" href="structParserOptions#r4-followGlobalIncludes">ParserOptions::followGlobalIncludes</a>, <a class="el" href="structParserOptions#rw-followLocalIncludes">ParserOptions::followLocalIncludes</a>, <a class="el" href="classParserBase#em-m_Options">ParserBase::m_Options</a>, and <a class="el" href="classParser#o1-Parse">Parse()</a>.</p>

</div>
</div>
<a class="anchor" id="jo-ProcessParserEvent"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::ProcessParserEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceParserCommon#a0-ParserState">ParserCommon::ParserState</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>info</em> = <code>wxEmptyString</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The parser will let its parent (<a class="el" href="classNativeParser" title="NativeParser class is just like a manager class to control Parser objects. ">NativeParser</a>) to handle the event, as the <a class="el" href="classCodeCompletion" title="Code completion plugin has those features: show tool-tip when the mouse hover over the variables/func...">CodeCompletion</a> instance was set as the next handler of the <a class="el" href="classNativeParser" title="NativeParser class is just like a manager class to control Parser objects. ">NativeParser</a>. </p>
<p>Those events can finally go to the <a class="el" href="classCodeCompletion" title="Code completion plugin has those features: show tool-tip when the mouse hover over the variables/func...">CodeCompletion</a>'s event handler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state of the <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a>, it could be any kind of enum ParserState </td></tr>
    <tr><td class="paramname">id</td><td>either idParserStart or idParserEnd </td></tr>
    <tr><td class="paramname">info</td><td>the log message </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classParser#px-m_Parent">m_Parent</a>, and <a class="el" href="classParser#p6-m_Project">m_Project</a>.</p>

<p>Referenced by <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>, and <a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer()</a>.</p>

</div>
</div>
<a class="anchor" id="gu-ReadOptions"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::ReadOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> options from configure file </p>

<p>Reimplemented from <a class="el" href="classParserBase#i1-ReadOptions">ParserBase</a>.</p>

<p>References <a class="el" href="parser__base_8h#s6-BrowserDisplayFilter:bdfFile">bdfFile</a>, <a class="el" href="parser__base_8h#gj-BrowserSortType:bstKind">bstKind</a>, <a class="el" href="structParserOptions#ao-caseSensitive">ParserOptions::caseSensitive</a>, <a class="el" href="structBrowserOptions#ee-displayFilter">BrowserOptions::displayFilter</a>, <a class="el" href="structBrowserOptions#e3-expandNS">BrowserOptions::expandNS</a>, <a class="el" href="namespaceParserCommon#fo-FileType">ParserCommon::FileType()</a>, <a class="el" href="structParserOptions#r4-followGlobalIncludes">ParserOptions::followGlobalIncludes</a>, <a class="el" href="structParserOptions#rw-followLocalIncludes">ParserOptions::followLocalIncludes</a>, <a class="el" href="classManager#rz-Get">Manager::Get()</a>, <a class="el" href="classManager#hd-GetConfigManager">Manager::GetConfigManager()</a>, <a class="el" href="classParserBase#b5-m_BrowserOptions">ParserBase::m_BrowserOptions</a>, <a class="el" href="classParserBase#em-m_Options">ParserBase::m_Options</a>, <a class="el" href="structParserOptions#q8-parseComplexMacros">ParserOptions::parseComplexMacros</a>, <a class="el" href="structParserOptions#a3-platformCheck">ParserOptions::platformCheck</a>, <a class="el" href="classConfigManager#mv-ReadBool">ConfigManager::ReadBool()</a>, <a class="el" href="classConfigManager#kb-ReadInt">ConfigManager::ReadInt()</a>, <a class="el" href="structBrowserOptions#ww-showInheritance">BrowserOptions::showInheritance</a>, <a class="el" href="structBrowserOptions#b7-sortType">BrowserOptions::sortType</a>, <a class="el" href="structParserOptions#wh-storeDocumentation">ParserOptions::storeDocumentation</a>, <a class="el" href="structBrowserOptions#le-treeMembers">BrowserOptions::treeMembers</a>, <a class="el" href="structParserOptions#nh-useSmartSense">ParserOptions::useSmartSense</a>, <a class="el" href="structParserOptions#qw-wantPreprocessor">ParserOptions::wantPreprocessor</a>, <a class="el" href="structParserOptions#vr-whileTyping">ParserOptions::whileTyping</a>, and <a class="el" href="classConfigManager#ls-Write">ConfigManager::Write()</a>.</p>

<p>Referenced by <a class="el" href="classParser#l5-Parser">Parser()</a>.</p>

</div>
</div>
<a class="anchor" id="ve-RemoveFile"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::RemoveFile </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this usually happens when the user removes a file from the existing project, it will remove all the tokens belong to the file. </p>

<p>References <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classTokenTree#af-EraseFileMapInFileMap">TokenTree::EraseFileMapInFileMap()</a>, <a class="el" href="classTokenTree#pi-EraseFileStatusByIndex">TokenTree::EraseFileStatusByIndex()</a>, <a class="el" href="classTokenTree#vc-EraseFilesToBeReparsedByIndex">TokenTree::EraseFilesToBeReparsedByIndex()</a>, <a class="el" href="classTokenTree#zg-GetFileStatusCountForIndex">TokenTree::GetFileStatusCountForIndex()</a>, <a class="el" href="classTokenTree#h8-InsertFileOrGetIndex">TokenTree::InsertFileOrGetIndex()</a>, <a class="el" href="classParserBase#cr-m_TokenTree">ParserBase::m_TokenTree</a>, <a class="el" href="classTokenTree#lb-RemoveFile">TokenTree::RemoveFile()</a>, and <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>.</p>

</div>
</div>
<a class="anchor" id="z8-RemoveParserThread"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::RemoveParserThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcbThreadedTask">cbThreadedTask</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a completed internal running threads. </p>

<p>References <a class="el" href="classParser#rp-m_tasksQueue">m_tasksQueue</a>.</p>

<p>Referenced by <a class="el" href="classParser#o1-Parse">Parse()</a>.</p>

</div>
</div>
<a class="anchor" id="zd-Reparse"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Reparse </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLocal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mark this file to be re-parsed in the <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a>, tick the reparse timer, note it looks like the isLocal parameter is not used in <a class="el" href="classParser#zd-Reparse" title="mark this file to be re-parsed in the TokenTree, tick the reparse timer, note it looks like the isLoc...">Parser::Reparse</a> function. </p>
<p>A better function name could be: MarkFileNeedToBeReParsed() </p>

<p>References <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="classParser#hu-Done">Done()</a>, <a class="el" href="classTokenTree#cj-FlagFileForReparsing">TokenTree::FlagFileForReparsing()</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, <a class="el" href="classParser#b7-m_NeedsReparse">m_NeedsReparse</a>, <a class="el" href="classParser#rx-m_ReparseTimer">m_ReparseTimer</a>, <a class="el" href="classParserBase#cr-m_TokenTree">ParserBase::m_TokenTree</a>, <a class="el" href="classParser#wi-NotDoneReason">NotDoneReason()</a>, <a class="el" href="namespaceParserCommon#xz-PARSER_REPARSE_TIMER_DELAY">ParserCommon::PARSER_REPARSE_TIMER_DELAY</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, and <a class="el" href="parser_8cpp#qa-TRACE">TRACE</a>.</p>

</div>
</div>
<a class="anchor" id="qq-ReparseModifiedFiles"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::ReparseModifiedFiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delete those files from the <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a>, and add them again through <a class="el" href="classParser#g2-AddParse" title="Add one file to Batch mode Parsing, this is the bridge between the main thread and the thread pool...">AddParse()</a> function </p>

<p>References <a class="el" href="classParser#g2-AddParse">AddParse()</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="classParser#hu-Done">Done()</a>, <a class="el" href="globals_8h#fu-FileTypeOf">FileTypeOf()</a>, <a class="el" href="globals_8h#k1-FileType:ftSource">ftSource</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, <a class="el" href="classTokenTree#yg-GetFilename">TokenTree::GetFilename()</a>, <a class="el" href="classTokenTree#yb-GetFilesToBeReparsed">TokenTree::GetFilesToBeReparsed()</a>, <a class="el" href="classParser#b7-m_NeedsReparse">m_NeedsReparse</a>, <a class="el" href="classParser#g0-m_ParserState">m_ParserState</a>, <a class="el" href="classParser#rx-m_ReparseTimer">m_ReparseTimer</a>, <a class="el" href="classParserBase#cr-m_TokenTree">ParserBase::m_TokenTree</a>, <a class="el" href="classParser#wi-NotDoneReason">NotDoneReason()</a>, <a class="el" href="namespaceParserCommon#xz-PARSER_REPARSE_TIMER_DELAY">ParserCommon::PARSER_REPARSE_TIMER_DELAY</a>, <a class="el" href="namespaceParserCommon#a0-ParserState:ptReparseFile">ParserCommon::ptReparseFile</a>, <a class="el" href="namespaceParserCommon#a0-ParserState:ptUndefined">ParserCommon::ptUndefined</a>, <a class="el" href="classTokenTree#lb-RemoveFile">TokenTree::RemoveFile()</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, and <a class="el" href="parser_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParser#ya-OnReparseTimer">OnReparseTimer()</a>.</p>

</div>
</div>
<a class="anchor" id="vn-SetMaxThreads"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::SetMaxThreads </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not used, because the ThreadPool only support running ONE <a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a> concurrently. </p>

<p>References <a class="el" href="classParser#l6-m_Pool">m_Pool</a>, and <a class="el" href="classcbThreadPool#mn-SetConcurrentThreads">cbThreadPool::SetConcurrentThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="zj-StartStopWatch"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::StartStopWatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classParser#re-m_StopWatch">m_StopWatch</a>, and <a class="el" href="classParser#hu-m_StopWatchRunning">m_StopWatchRunning</a>.</p>

<p>Referenced by <a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer()</a>.</p>

</div>
</div>
<a class="anchor" id="i0-TerminateAllThreads"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::TerminateAllThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cancel all the tasks in the thread pool m_Pool </p>

<p>References <a class="el" href="classcbThreadPool#s5-AbortAllTasks">cbThreadPool::AbortAllTasks()</a>, <a class="el" href="classParser#x2-AbortParserThreads">AbortParserThreads()</a>, <a class="el" href="classcbThreadPool#lj-Done">cbThreadPool::Done()</a>, and <a class="el" href="classParser#l6-m_Pool">m_Pool</a>.</p>

<p>Referenced by <a class="el" href="classParser#ij-Parser">~Parser()</a>.</p>

</div>
</div>
<a class="anchor" id="rn-UpdateParsingProject"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::UpdateParsingProject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcbProject">cbProject</a> *&#160;</td>
          <td class="paramname"><em>project</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the associated C::B project pointer. </p>
<p>(only used by one parser for whole workspace) </p><dl class="section return"><dt>Returns</dt><dd>true if it can do the switch, other wise, return false, and print some debug logs. </dd></dl>

<p>References <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="classParser#hu-Done">Done()</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, <a class="el" href="classParser#p6-m_Project">m_Project</a>, and <a class="el" href="classParser#wi-NotDoneReason">NotDoneReason()</a>.</p>

</div>
</div>
<a class="anchor" id="v3-WriteOptions"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::WriteOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write Parse options to configure file </p>

<p>Reimplemented from <a class="el" href="classParserBase#pl-WriteOptions">ParserBase</a>.</p>

<p>References <a class="el" href="structBrowserOptions#ee-displayFilter">BrowserOptions::displayFilter</a>, <a class="el" href="structBrowserOptions#e3-expandNS">BrowserOptions::expandNS</a>, <a class="el" href="structParserOptions#r4-followGlobalIncludes">ParserOptions::followGlobalIncludes</a>, <a class="el" href="structParserOptions#rw-followLocalIncludes">ParserOptions::followLocalIncludes</a>, <a class="el" href="classManager#rz-Get">Manager::Get()</a>, <a class="el" href="classManager#hd-GetConfigManager">Manager::GetConfigManager()</a>, <a class="el" href="classParserBase#b5-m_BrowserOptions">ParserBase::m_BrowserOptions</a>, <a class="el" href="classParserBase#em-m_Options">ParserBase::m_Options</a>, <a class="el" href="structParserOptions#q8-parseComplexMacros">ParserOptions::parseComplexMacros</a>, <a class="el" href="structParserOptions#a3-platformCheck">ParserOptions::platformCheck</a>, <a class="el" href="structBrowserOptions#ww-showInheritance">BrowserOptions::showInheritance</a>, <a class="el" href="structBrowserOptions#b7-sortType">BrowserOptions::sortType</a>, <a class="el" href="structBrowserOptions#le-treeMembers">BrowserOptions::treeMembers</a>, <a class="el" href="structParserOptions#nh-useSmartSense">ParserOptions::useSmartSense</a>, <a class="el" href="structParserOptions#qw-wantPreprocessor">ParserOptions::wantPreprocessor</a>, <a class="el" href="structParserOptions#vr-whileTyping">ParserOptions::whileTyping</a>, and <a class="el" href="classConfigManager#ls-Write">ConfigManager::Write()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="es-ParserThreadedTask"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classParserThreadedTask">ParserThreadedTask</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="x1-m_BatchParseFiles"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="parser__base_8h#ks-StringList">StringList</a> Parser::m_BatchParseFiles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All other batch parse files, like the normal headers/sources. </p>

<p>Referenced by <a class="el" href="classParser#uw-AddBatchParse">AddBatchParse()</a>, <a class="el" href="classParser#g2-AddParse">AddParse()</a>, <a class="el" href="classParser#hu-Done">Done()</a>, <a class="el" href="classParserThreadedTask#fr-Execute">ParserThreadedTask::Execute()</a>, <a class="el" href="classParser#pg-IsFileParsed">IsFileParsed()</a>, <a class="el" href="classParser#wi-NotDoneReason">NotDoneReason()</a>, <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>, and <a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga-m_BatchTimer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxTimer Parser::m_BatchTimer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a timer to delay the operation of batch parsing, see <a class="el" href="classParser#qb-OnBatchTimer" title="A timer is used to optimized the event handling for parsing, e.g. ">OnBatchTimer()</a> member function as a reference </p>

<p>Referenced by <a class="el" href="classParser#uw-AddBatchParse">AddBatchParse()</a>, <a class="el" href="classParser#g2-AddParse">AddParse()</a>, <a class="el" href="classParser#lv-AddPredefinedMacros">AddPredefinedMacros()</a>, <a class="el" href="classParser#rz-ConnectEvents">ConnectEvents()</a>, <a class="el" href="classParser#f8-DisconnectEvents">DisconnectEvents()</a>, <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>, and <a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer()</a>.</p>

</div>
</div>
<a class="anchor" id="we-m_IgnoreThreadEvents"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::m_IgnoreThreadEvents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classParser#dq-OnAllThreadsDone" title="When a ThreadPool batch parse stage is done, it will issue a cbEVT_THREADTASK_ALLDONE message...">Parser::OnAllThreadsDone</a> will be called when m_Pool finished its job, but when we run a batch parsing, we may receive several such event from the m_Pool, because 1, when <a class="el" href="classParserThreadedTask">ParserThreadedTask</a> finished 2, when batchFiles get finished 3, mark C::B project files's token as local. </p>

<p>Referenced by <a class="el" href="classParserThreadedTask#fr-Execute">ParserThreadedTask::Execute()</a>, and <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>.</p>

</div>
</div>
<a class="anchor" id="ph-m_IsBatchParseDone"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::m_IsBatchParseDone</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used to measure batch parse time </p>

<p>Referenced by <a class="el" href="classParser#qu-EndStopWatch">EndStopWatch()</a>, and <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>.</p>

</div>
</div>
<a class="anchor" id="cz-m_IsFirstBatch"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::m_IsFirstBatch</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>batch Parse mode flag. </p>
<p>It was set after consuming m_PredefinedMacros, it was reset after the final stage (mark token as local). </p>

<p>Referenced by <a class="el" href="classParserThreadedTask#fr-Execute">ParserThreadedTask::Execute()</a>.</p>

</div>
</div>
<a class="anchor" id="oc-m_IsParsing"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::m_IsParsing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true, if the parser is still busy with parsing, false if the parsing stage has finished this value is set in parserthreadedtask after putting all the batchFiles to pool(task) it was reset after the last stage (mark tokens as local) </p>

<p>Referenced by <a class="el" href="classParser#uw-AddBatchParse">AddBatchParse()</a>, <a class="el" href="classParser#g2-AddParse">AddParse()</a>, <a class="el" href="classParser#lv-AddPredefinedMacros">AddPredefinedMacros()</a>, <a class="el" href="classParserThreadedTask#fr-Execute">ParserThreadedTask::Execute()</a>, and <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>.</p>

</div>
</div>
<a class="anchor" id="su-m_LastPredefinedMacros"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Parser::m_LastPredefinedMacros</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classParser#vk-ClearPredefinedMacros">ClearPredefinedMacros()</a>, and <a class="el" href="classParser#s5-GetPredefinedMacros">GetPredefinedMacros()</a>.</p>

</div>
</div>
<a class="anchor" id="sf-m_LastStopWatchTime"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long Parser::m_LastStopWatchTime</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classParser#qu-EndStopWatch">EndStopWatch()</a>, and <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>.</p>

</div>
</div>
<a class="anchor" id="k3-m_NeedMarkFileAsLocal"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::m_NeedMarkFileAsLocal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if true, all the files of the current project will be labeled as "local" </p>

<p>Referenced by <a class="el" href="classParser#sc-AddFile">AddFile()</a>, <a class="el" href="classParser#hu-Done">Done()</a>, <a class="el" href="classParser#wi-NotDoneReason">NotDoneReason()</a>, and <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>.</p>

</div>
</div>
<a class="anchor" id="b7-m_NeedsReparse"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::m_NeedsReparse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates some files in the current project need to be re-parsed, this is commonly caused that the "real-time parsing option" is enabled, and user is editing source file. </p>

<p>Referenced by <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>, <a class="el" href="classParser#o1-Parse">Parse()</a>, <a class="el" href="classParser#zd-Reparse">Reparse()</a>, and <a class="el" href="classParser#qq-ReparseModifiedFiles">ReparseModifiedFiles()</a>.</p>

</div>
</div>
<a class="anchor" id="px-m_Parent"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxEvtHandler* Parser::m_Parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>when initialized, this variable will be an instance of a <a class="el" href="classNativeParser" title="NativeParser class is just like a manager class to control Parser objects. ">NativeParser</a> </p>

<p>Referenced by <a class="el" href="classParser#jo-ProcessParserEvent">ProcessParserEvent()</a>.</p>

</div>
</div>
<a class="anchor" id="g0-m_ParserState"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceParserCommon#a0-ParserState">ParserCommon::ParserState</a> Parser::m_ParserState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicated the current state the parser </p>

<p>Referenced by <a class="el" href="classParser#uw-AddBatchParse">AddBatchParse()</a>, <a class="el" href="classParser#sc-AddFile">AddFile()</a>, <a class="el" href="classParser#lv-AddPredefinedMacros">AddPredefinedMacros()</a>, <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>, <a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer()</a>, and <a class="el" href="classParser#qq-ReparseModifiedFiles">ReparseModifiedFiles()</a>.</p>

</div>
</div>
<a class="anchor" id="l6-m_Pool"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcbThreadPool">cbThreadPool</a> Parser::m_Pool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread Pool, executing all the <a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a>, used in batch parse mode. </p>
<p>The thread pool can add/remove/execute the <a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a> tasks, it will also notify the <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> that all the thread are done. </p>

<p>Referenced by <a class="el" href="classParser#rz-ConnectEvents">ConnectEvents()</a>, <a class="el" href="classParser#f8-DisconnectEvents">DisconnectEvents()</a>, <a class="el" href="classParser#hu-Done">Done()</a>, <a class="el" href="classParser#it-GetMaxThreads">GetMaxThreads()</a>, <a class="el" href="classParser#wi-NotDoneReason">NotDoneReason()</a>, <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>, <a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer()</a>, <a class="el" href="classParser#o1-Parse">Parse()</a>, <a class="el" href="classParser#vn-SetMaxThreads">SetMaxThreads()</a>, and <a class="el" href="classParser#i0-TerminateAllThreads">TerminateAllThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="ck-m_PredefinedMacros"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Parser::m_PredefinedMacros</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-defined macros, its a buffer queried from the compiler command line. </p>

<p>Referenced by <a class="el" href="classParser#lv-AddPredefinedMacros">AddPredefinedMacros()</a>, <a class="el" href="classParser#vk-ClearPredefinedMacros">ClearPredefinedMacros()</a>, <a class="el" href="classParser#hu-Done">Done()</a>, <a class="el" href="classParserThreadedTask#fr-Execute">ParserThreadedTask::Execute()</a>, <a class="el" href="classParser#wi-NotDoneReason">NotDoneReason()</a>, <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>, and <a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer()</a>.</p>

</div>
</div>
<a class="anchor" id="p6-m_Project"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcbProject">cbProject</a>* Parser::m_Project</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>referring to the C::B cbp project currently parsing in one parser per workspace mode </p>

<p>Referenced by <a class="el" href="classParser#sc-AddFile">AddFile()</a>, <a class="el" href="classParser#dq-OnAllThreadsDone">OnAllThreadsDone()</a>, <a class="el" href="classParser#jo-ProcessParserEvent">ProcessParserEvent()</a>, and <a class="el" href="classParser#rn-UpdateParsingProject">UpdateParsingProject()</a>.</p>

</div>
</div>
<a class="anchor" id="rx-m_ReparseTimer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxTimer Parser::m_ReparseTimer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a file is need to be reparsed, maybe another file will to be reparsed very soon, so use a timer to collect all the files need to be reparsed. </p>
<p>This avoid starting running the thread pool to quickly </p>

<p>Referenced by <a class="el" href="classParser#rz-ConnectEvents">ConnectEvents()</a>, <a class="el" href="classParser#f8-DisconnectEvents">DisconnectEvents()</a>, <a class="el" href="classParser#zd-Reparse">Reparse()</a>, and <a class="el" href="classParser#qq-ReparseModifiedFiles">ReparseModifiedFiles()</a>.</p>

</div>
</div>
<a class="anchor" id="re-m_StopWatch"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxStopWatch Parser::m_StopWatch</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a stop watch to measure parsing time </p>

<p>Referenced by <a class="el" href="classParser#qu-EndStopWatch">EndStopWatch()</a>, <a class="el" href="classParser#qb-OnBatchTimer">OnBatchTimer()</a>, and <a class="el" href="classParser#zj-StartStopWatch">StartStopWatch()</a>.</p>

</div>
</div>
<a class="anchor" id="hu-m_StopWatchRunning"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::m_StopWatchRunning</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classParser#qu-EndStopWatch">EndStopWatch()</a>, and <a class="el" href="classParser#zj-StartStopWatch">StartStopWatch()</a>.</p>

</div>
</div>
<a class="anchor" id="rp-m_tasksQueue"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParser#xu-TasksQueue">TasksQueue</a> Parser::m_tasksQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classParser#x2-AbortParserThreads">AbortParserThreads()</a>, <a class="el" href="classParser#ov-AddParserThread">AddParserThread()</a>, and <a class="el" href="classParser#z8-RemoveParserThread">RemoveParserThread()</a>.</p>

</div>
</div>
<a class="anchor" id="vd-m_UsingCache"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::m_UsingCache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used to detect changes between in-memory data and cache, true if loaded from cache </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="parser_8h_source">parser.h</a></li>
<li><a class="el" href="parser_8cpp">parser.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
