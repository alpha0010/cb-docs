<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Code::Blocks: NativeParserBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Code::Blocks
   &#160;<span id="projectnumber">SVN r10885</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index"><span>Main&#160;Page</span></a></li>
      <li><a href="pages"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated"><span>Classes</span></a></li>
      <li><a href="files"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated"><span>Class&#160;List</span></a></li>
      <li><a href="classes"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classNativeParserBase-members">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NativeParserBase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="nativeparser__base_8h_source">nativeparser_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NativeParserBase:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classNativeParserBase__inherit__graph.svg" width="234" height="1167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Collaboration diagram for NativeParserBase:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classNativeParserBase__coll__graph.svg" width="346" height="698"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNativeParserBase_1_1ParserComponent">ParserComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a long statement can be divided to a <a class="el" href="structNativeParserBase_1_1ParserComponent" title="a long statement can be divided to a ParserComponent chain. ">ParserComponent</a> chain.  <a href="structNativeParserBase_1_1ParserComponent#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:u7-ParserTokenType"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#u7-ParserTokenType">ParserTokenType</a> { <br />
&#160;&#160;<a class="el" href="classNativeParserBase#u7-ParserTokenType:pttUndefined">pttUndefined</a> = 0, 
<a class="el" href="classNativeParserBase#u7-ParserTokenType:pttSearchText">pttSearchText</a>, 
<a class="el" href="classNativeParserBase#u7-ParserTokenType:pttClass">pttClass</a>, 
<a class="el" href="classNativeParserBase#u7-ParserTokenType:pttNamespace">pttNamespace</a>, 
<br />
&#160;&#160;<a class="el" href="classNativeParserBase#u7-ParserTokenType:pttFunction">pttFunction</a>
<br />
 }<tr class="memdesc:u7-ParserTokenType"><td class="mdescLeft">&#160;</td><td class="mdescRight">divide a statement to several pieces(parser component), each component has a type member  <a href="classNativeParserBase#u7-ParserTokenType">More...</a><br /></td></tr>
<tr class="separator:u7-ParserTokenType"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:q3-OperatorType"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#q3-OperatorType">OperatorType</a> { <br />
&#160;&#160;<a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorUndefined">otOperatorUndefined</a> = 0, 
<a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorSquare">otOperatorSquare</a>, 
<a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorParentheses">otOperatorParentheses</a>, 
<a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorPointer">otOperatorPointer</a>, 
<br />
&#160;&#160;<a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorStar">otOperatorStar</a>
<br />
 }<tr class="memdesc:q3-OperatorType"><td class="mdescLeft">&#160;</td><td class="mdescRight">the delimiter separating two <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> Component, See <a class="el" href="structNativeParserBase_1_1ParserComponent" title="a long statement can be divided to a ParserComponent chain. ">ParserComponent</a> struct for more details  <a href="classNativeParserBase#q3-OperatorType">More...</a><br /></td></tr>
<tr class="separator:q3-OperatorType"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:mm-NativeParserBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#mm-NativeParserBase">NativeParserBase</a> ()</td></tr>
<tr class="memdesc:mm-NativeParserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#mm-NativeParserBase">More...</a><br /></td></tr>
<tr class="separator:mm-NativeParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cw-NativeParserBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#cw-NativeParserBase">~NativeParserBase</a> ()</td></tr>
<tr class="memdesc:cw-NativeParserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#cw-NativeParserBase">More...</a><br /></td></tr>
<tr class="separator:cw-NativeParserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ls-Reset"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#ls-Reset">Reset</a> ()</td></tr>
<tr class="memdesc:ls-Reset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init cc search member variables.  <a href="#ls-Reset">More...</a><br /></td></tr>
<tr class="separator:ls-Reset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nm-FindAIMatches"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#nm-FindAIMatches">FindAIMatches</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, std::queue&lt; <a class="el" href="structNativeParserBase_1_1ParserComponent">ParserComponent</a> &gt; components, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;result, int parentTokenIdx=-1, bool isPrefix=false, bool caseSensitive=false, bool use_inheritance=true, short int kindMask=0xFFFF, TokenIdxSet *search_scope=0)</td></tr>
<tr class="memdesc:nm-FindAIMatches"><td class="mdescLeft">&#160;</td><td class="mdescRight">Artificial Intelligence Matching.  <a href="#nm-FindAIMatches">More...</a><br /></td></tr>
<tr class="separator:nm-FindAIMatches"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:e0-FindCurrentFunctionScope"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#e0-FindCurrentFunctionScope">FindCurrentFunctionScope</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;procResult, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;scopeResult)</td></tr>
<tr class="memdesc:e0-FindCurrentFunctionScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the expression return the container tokens, which are the parent of the expression.  <a href="#e0-FindCurrentFunctionScope">More...</a><br /></td></tr>
<tr class="separator:e0-FindCurrentFunctionScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:my-CleanupSearchScope"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#my-CleanupSearchScope">CleanupSearchScope</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> *searchScope)</td></tr>
<tr class="memdesc:my-CleanupSearchScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all the container tokens in the token index set.  <a href="#my-CleanupSearchScope">More...</a><br /></td></tr>
<tr class="separator:my-CleanupSearchScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:er-GetCallTipHighlight"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#er-GetCallTipHighlight">GetCallTipHighlight</a> (const wxString &amp;calltip, int *start, int *end, int typedCommas)</td></tr>
<tr class="memdesc:er-GetCallTipHighlight"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the start and end of the call-tip highlight region.  <a href="#er-GetCallTipHighlight">More...</a><br /></td></tr>
<tr class="separator:er-GetCallTipHighlight"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:s5-FindFunctionOpenParenthesis"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#s5-FindFunctionOpenParenthesis">FindFunctionOpenParenthesis</a> (const wxString &amp;calltip)</td></tr>
<tr class="memdesc:s5-FindFunctionOpenParenthesis"><td class="mdescLeft">&#160;</td><td class="mdescRight">for <a class="el" href="classNativeParserBase#er-GetCallTipHighlight" title="Returns the start and end of the call-tip highlight region. ">GetCallTipHighlight()</a> Finds the position of the opening parenthesis marking the beginning of the params.  <a href="#s5-FindFunctionOpenParenthesis">More...</a><br /></td></tr>
<tr class="separator:s5-FindFunctionOpenParenthesis"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:v6-GetCCToken"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#v6-GetCCToken">GetCCToken</a> (wxString &amp;line, <a class="el" href="classNativeParserBase#u7-ParserTokenType">ParserTokenType</a> &amp;tokenType, <a class="el" href="classNativeParserBase#q3-OperatorType">OperatorType</a> &amp;tokenOperatorType)</td></tr>
<tr class="memdesc:v6-GetCCToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to split the statement line contains a string on the following form:  <a href="#v6-GetCCToken">More...</a><br /></td></tr>
<tr class="separator:v6-GetCCToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:q8-FindCCTokenStart"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#q8-FindCCTokenStart">FindCCTokenStart</a> (const wxString &amp;line)</td></tr>
<tr class="memdesc:q8-FindCCTokenStart"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to split the statement  <a href="#q8-FindCCTokenStart">More...</a><br /></td></tr>
<tr class="separator:q8-FindCCTokenStart"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pz-GetNextCCToken"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#pz-GetNextCCToken">GetNextCCToken</a> (const wxString &amp;line, unsigned int &amp;startAt, <a class="el" href="classNativeParserBase#q3-OperatorType">OperatorType</a> &amp;tokenOperatorType)</td></tr>
<tr class="memdesc:pz-GetNextCCToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to read the next CCToken, begin from the startAt, this point to a non-space character, and fetch the beginning identifier  <a href="#pz-GetNextCCToken">More...</a><br /></td></tr>
<tr class="separator:pz-GetNextCCToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zx-RemoveLastFunctionChildren"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#zx-RemoveLastFunctionChildren">RemoveLastFunctionChildren</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, int &amp;lastFuncTokenIdx)</td></tr>
<tr class="memdesc:zx-RemoveLastFunctionChildren"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last function's children, when doing codecompletion in a function body, the function body up to the caret position was parsed, and the local variables defined in the function were recorded as the function's children.  <a href="#zx-RemoveLastFunctionChildren">More...</a><br /></td></tr>
<tr class="separator:zx-RemoveLastFunctionChildren"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:we-BreakUpComponents"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#we-BreakUpComponents">BreakUpComponents</a> (const wxString &amp;actual, std::queue&lt; <a class="el" href="structNativeParserBase_1_1ParserComponent">ParserComponent</a> &gt; &amp;components)</td></tr>
<tr class="memdesc:we-BreakUpComponents"><td class="mdescLeft">&#160;</td><td class="mdescRight">break a statement to several ParserComponents, and store them in a queue.  <a href="#we-BreakUpComponents">More...</a><br /></td></tr>
<tr class="separator:we-BreakUpComponents"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gq-ResolveExpression"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#gq-ResolveExpression">ResolveExpression</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, std::queue&lt; <a class="el" href="structNativeParserBase_1_1ParserComponent">ParserComponent</a> &gt; components, const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;searchScope, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;result, bool caseSense=true, bool isPrefix=false)</td></tr>
<tr class="memdesc:gq-ResolveExpression"><td class="mdescLeft">&#160;</td><td class="mdescRight">A statement(expression) is expressed by a <a class="el" href="structNativeParserBase_1_1ParserComponent" title="a long statement can be divided to a ParserComponent chain. ">ParserComponent</a> queue We do a match from the left of the queue one by one.  <a href="#gq-ResolveExpression">More...</a><br /></td></tr>
<tr class="separator:gq-ResolveExpression"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:f4-ResolveOperator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#f4-ResolveOperator">ResolveOperator</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const <a class="el" href="classNativeParserBase#q3-OperatorType">OperatorType</a> &amp;tokenOperatorType, const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;tokens, const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;searchScope, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;result)</td></tr>
<tr class="memdesc:f4-ResolveOperator"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to solve the overloaded operator functions return type  <a href="#f4-ResolveOperator">More...</a><br /></td></tr>
<tr class="separator:f4-ResolveOperator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jr-ResolveActualType"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#jr-ResolveActualType">ResolveActualType</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, wxString searchText, const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;searchScope, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;result)</td></tr>
<tr class="memdesc:jr-ResolveActualType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Type information of the searchText string.  <a href="#jr-ResolveActualType">More...</a><br /></td></tr>
<tr class="separator:jr-ResolveActualType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:as-ResolveTemplateMap"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#as-ResolveTemplateMap">ResolveTemplateMap</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const wxString &amp;searchStr, const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;actualTypeScope, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;initialScope)</td></tr>
<tr class="memdesc:as-ResolveTemplateMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">resolve template map [formal parameter] to [actual parameter]  <a href="#as-ResolveTemplateMap">More...</a><br /></td></tr>
<tr class="separator:as-ResolveTemplateMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zr-AddTemplateAlias"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#zr-AddTemplateAlias">AddTemplateAlias</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const int &amp;id, const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;actualTypeScope, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;initialScope)</td></tr>
<tr class="memdesc:zr-AddTemplateAlias"><td class="mdescLeft">&#160;</td><td class="mdescRight">add template parameter, get the actual parameter from the formal parameter list  <a href="#zr-AddTemplateAlias">More...</a><br /></td></tr>
<tr class="separator:zr-AddTemplateAlias"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lo-GenerateResultSet"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#lo-GenerateResultSet">GenerateResultSet</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const wxString &amp;target, int parentIdx, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;result, bool caseSens=true, bool isPrefix=false, short int kindMask=0xFFFF)</td></tr>
<tr class="memdesc:lo-GenerateResultSet"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the matching results under the Parent <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> index set.  <a href="#lo-GenerateResultSet">More...</a><br /></td></tr>
<tr class="separator:lo-GenerateResultSet"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:p0-GenerateResultSet"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#p0-GenerateResultSet">GenerateResultSet</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const wxString &amp;target, const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;ptrParentID, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;result, bool caseSens=true, bool isPrefix=false, short int kindMask=0xFFFF)</td></tr>
<tr class="memdesc:p0-GenerateResultSet"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is just like the one above, especially that it use a single parent <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> id, not the parent id set in previous one.  <a href="#p0-GenerateResultSet">More...</a><br /></td></tr>
<tr class="separator:p0-GenerateResultSet"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dg-IsAllocator"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#dg-IsAllocator">IsAllocator</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const int &amp;id)</td></tr>
<tr class="memdesc:dg-IsAllocator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if token with this id is allocator class.  <a href="#dg-IsAllocator">More...</a><br /></td></tr>
<tr class="separator:dg-IsAllocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ji-DependsOnAllocator"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#ji-DependsOnAllocator">DependsOnAllocator</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const int &amp;id)</td></tr>
<tr class="memdesc:ji-DependsOnAllocator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if token with this id depends on allocator class.  <a href="#ji-DependsOnAllocator">More...</a><br /></td></tr>
<tr class="separator:ji-DependsOnAllocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nm-CollectSearchScopes"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#nm-CollectSearchScopes">CollectSearchScopes</a> (const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;searchScope, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;actualTypeScope, <a class="el" href="classTokenTree">TokenTree</a> *tree)</td></tr>
<tr class="memdesc:nm-CollectSearchScopes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect search scopes, add the searchScopes's parent scope.  <a href="#nm-CollectSearchScopes">More...</a><br /></td></tr>
<tr class="separator:nm-CollectSearchScopes"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ez-GetTokenFromCurrentLine"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#ez-GetTokenFromCurrentLine">GetTokenFromCurrentLine</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;tokens, size_t curLine, const wxString &amp;file)</td></tr>
<tr class="memdesc:ez-GetTokenFromCurrentLine"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to get the correct token index in current line, e.g.  <a href="#ez-GetTokenFromCurrentLine">More...</a><br /></td></tr>
<tr class="separator:ez-GetTokenFromCurrentLine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa-ComputeCallTip"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#aa-ComputeCallTip">ComputeCallTip</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;tokens, wxArrayString &amp;items)</td></tr>
<tr class="memdesc:aa-ComputeCallTip"><td class="mdescLeft">&#160;</td><td class="mdescRight">call tips are tips when you are entering some functions, such as you have a class definition  <a href="#aa-ComputeCallTip">More...</a><br /></td></tr>
<tr class="separator:aa-ComputeCallTip"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nr-PrettyPrintToken"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#nr-PrettyPrintToken">PrettyPrintToken</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const <a class="el" href="classToken">Token</a> *token, wxString &amp;result, bool isRoot=true)</td></tr>
<tr class="memdesc:nr-PrettyPrintToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="classNativeParserBase#aa-ComputeCallTip" title="call tips are tips when you are entering some functions, such as you have a class definition ...">ComputeCallTip()</a> No critical section needed in this recursive function! All functions that call this recursive function, should already entered a critical section.  <a href="#nr-PrettyPrintToken">More...</a><br /></td></tr>
<tr class="separator:nr-PrettyPrintToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:j0-CountCommas"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#j0-CountCommas">CountCommas</a> (const wxString &amp;lineText, int start)</td></tr>
<tr class="separator:j0-CountCommas"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ly-InsideToken"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#ly-InsideToken">InsideToken</a> (int startAt, const wxString &amp;line)</td></tr>
<tr class="memdesc:ly-InsideToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the line[startAt] point to the identifier  <a href="#ly-InsideToken">More...</a><br /></td></tr>
<tr class="separator:ly-InsideToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vr-BeginOfToken"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#vr-BeginOfToken">BeginOfToken</a> (int startAt, const wxString &amp;line)</td></tr>
<tr class="memdesc:vr-BeginOfToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">go to the first character of the identifier, e.g  <a href="#vr-BeginOfToken">More...</a><br /></td></tr>
<tr class="separator:vr-BeginOfToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ak-BeforeToken"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#ak-BeforeToken">BeforeToken</a> (int startAt, const wxString &amp;line)</td></tr>
<tr class="separator:ak-BeforeToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pi-IsOperatorEnd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#pi-IsOperatorEnd">IsOperatorEnd</a> (int startAt, const wxString &amp;line)</td></tr>
<tr class="memdesc:pi-IsOperatorEnd"><td class="mdescLeft">&#160;</td><td class="mdescRight">check startAt is at some character like:  <a href="#pi-IsOperatorEnd">More...</a><br /></td></tr>
<tr class="separator:pi-IsOperatorEnd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ic-IsOperatorPointer"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#ic-IsOperatorPointer">IsOperatorPointer</a> (int startAt, const wxString &amp;line)</td></tr>
<tr class="separator:ic-IsOperatorPointer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gz-IsOperatorBegin"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#gz-IsOperatorBegin">IsOperatorBegin</a> (int startAt, const wxString &amp;line)</td></tr>
<tr class="memdesc:gz-IsOperatorBegin"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if startAt point to "-&gt;" or "::" operator  <a href="#gz-IsOperatorBegin">More...</a><br /></td></tr>
<tr class="separator:gz-IsOperatorBegin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qv-IsOperatorDot"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#qv-IsOperatorDot">IsOperatorDot</a> (int startAt, const wxString &amp;line)</td></tr>
<tr class="memdesc:qv-IsOperatorDot"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether line[startAt] is a dot character  <a href="#qv-IsOperatorDot">More...</a><br /></td></tr>
<tr class="separator:qv-IsOperatorDot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ik-BeforeWhitespace"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#ik-BeforeWhitespace">BeforeWhitespace</a> (int startAt, const wxString &amp;line)</td></tr>
<tr class="memdesc:ik-BeforeWhitespace"><td class="mdescLeft">&#160;</td><td class="mdescRight">move to the char before whitespace and tabs, e.g.  <a href="#ik-BeforeWhitespace">More...</a><br /></td></tr>
<tr class="separator:ik-BeforeWhitespace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dp-AfterWhitespace"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#dp-AfterWhitespace">AfterWhitespace</a> (int startAt, const wxString &amp;line)</td></tr>
<tr class="memdesc:dp-AfterWhitespace"><td class="mdescLeft">&#160;</td><td class="mdescRight">search from left to right, move to the first character of the space  <a href="#dp-AfterWhitespace">More...</a><br /></td></tr>
<tr class="separator:dp-AfterWhitespace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ii-IsOpeningBracket"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#ii-IsOpeningBracket">IsOpeningBracket</a> (int startAt, const wxString &amp;line)</td></tr>
<tr class="separator:ii-IsOpeningBracket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:xe-IsClosingBracket"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#xe-IsClosingBracket">IsClosingBracket</a> (int startAt, const wxString &amp;line)</td></tr>
<tr class="memdesc:xe-IsClosingBracket"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the current char (line[startAt]) is either ')' or ']'  <a href="#xe-IsClosingBracket">More...</a><br /></td></tr>
<tr class="separator:xe-IsClosingBracket"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:nu-AddChildrenOfUnnamed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#nu-AddChildrenOfUnnamed">AddChildrenOfUnnamed</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const <a class="el" href="classToken">Token</a> *parent, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;result)</td></tr>
<tr class="memdesc:nu-AddChildrenOfUnnamed"><td class="mdescLeft">&#160;</td><td class="mdescRight">collect child tokens of the specified token, the specified token must be unnamed.  <a href="#nu-AddChildrenOfUnnamed">More...</a><br /></td></tr>
<tr class="separator:nu-AddChildrenOfUnnamed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1-AddChildrenOfEnum"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#a1-AddChildrenOfEnum">AddChildrenOfEnum</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const <a class="el" href="classToken">Token</a> *parent, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;result)</td></tr>
<tr class="separator:a1-AddChildrenOfEnum"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:k1-IsChildOfUnnamedOrEnum"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#k1-IsChildOfUnnamedOrEnum">IsChildOfUnnamedOrEnum</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const int targetIdx, const int parentIdx)</td></tr>
<tr class="memdesc:k1-IsChildOfUnnamedOrEnum"><td class="mdescLeft">&#160;</td><td class="mdescRight">check to see if the token is an unnamed class or enum under the parent token  <a href="#k1-IsChildOfUnnamedOrEnum">More...</a><br /></td></tr>
<tr class="separator:k1-IsChildOfUnnamedOrEnum"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:fn-AddConstructors"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#fn-AddConstructors">AddConstructors</a> (<a class="el" href="classTokenTree">TokenTree</a> *tree, const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;source, <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;dest)</td></tr>
<tr class="memdesc:fn-AddConstructors"><td class="mdescLeft">&#160;</td><td class="mdescRight">loop on the input <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> index set (source), add all its public constructors to output <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> index set (dest)  <a href="#fn-AddConstructors">More...</a><br /></td></tr>
<tr class="separator:fn-AddConstructors"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:an-MatchText"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#an-MatchText">MatchText</a> (const wxString &amp;text, const wxString &amp;target, bool caseSens, bool isPrefix)</td></tr>
<tr class="separator:an-MatchText"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:q5-MatchType"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#q5-MatchType">MatchType</a> (<a class="el" href="token_8h#uj-TokenKind">TokenKind</a> kind, short int kindMask)</td></tr>
<tr class="separator:q5-MatchType"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:gu-m_LastComponent"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNativeParserBase_1_1ParserComponent">ParserComponent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#gu-m_LastComponent">m_LastComponent</a></td></tr>
<tr class="separator:gu-m_LastComponent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ew-m_TemplateMap"><td class="memItemLeft" align="right" valign="top">std::map&lt; wxString, wxString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNativeParserBase#ew-m_TemplateMap">m_TemplateMap</a></td></tr>
<tr class="separator:ew-m_TemplateMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="q3-OperatorType"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classNativeParserBase#q3-OperatorType">NativeParserBase::OperatorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the delimiter separating two <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> Component, See <a class="el" href="structNativeParserBase_1_1ParserComponent" title="a long statement can be divided to a ParserComponent chain. ">ParserComponent</a> struct for more details </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="q3-OperatorType:otOperatorUndefined"></a>otOperatorUndefined&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="q3-OperatorType:otOperatorSquare"></a>otOperatorSquare&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="q3-OperatorType:otOperatorParentheses"></a>otOperatorParentheses&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="q3-OperatorType:otOperatorPointer"></a>otOperatorPointer&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="q3-OperatorType:otOperatorStar"></a>otOperatorStar&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="u7-ParserTokenType"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classNativeParserBase#u7-ParserTokenType">NativeParserBase::ParserTokenType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>divide a statement to several pieces(parser component), each component has a type member </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="u7-ParserTokenType:pttUndefined"></a>pttUndefined&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="u7-ParserTokenType:pttSearchText"></a>pttSearchText&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="u7-ParserTokenType:pttClass"></a>pttClass&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="u7-ParserTokenType:pttNamespace"></a>pttNamespace&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="u7-ParserTokenType:pttFunction"></a>pttFunction&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="mm-NativeParserBase"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NativeParserBase::NativeParserBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="cw-NativeParserBase"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NativeParserBase::~NativeParserBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1-AddChildrenOfEnum"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NativeParserBase::AddChildrenOfEnum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classToken#jd-m_Children">Token::m_Children</a>, <a class="el" href="classToken#d0-m_Scope">Token::m_Scope</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="token_8h#uj-TokenKind:tkEnum">tkEnum</a>, and <a class="el" href="token_8h#bs-TokenScope:tsPrivate">tsPrivate</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#nu-AddChildrenOfUnnamed">AddChildrenOfUnnamed()</a>.</p>

</div>
</div>
<a class="anchor" id="nu-AddChildrenOfUnnamed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NativeParserBase::AddChildrenOfUnnamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>collect child tokens of the specified token, the specified token must be unnamed. </p>
<p>used for <a class="el" href="classNativeParserBase#lo-GenerateResultSet" title="Generate the matching results under the Parent Token index set. ">GenerateResultSet()</a> function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td><a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> pointer </td></tr>
    <tr><td class="paramname">parent</td><td>we need to collect the children of this token </td></tr>
    <tr><td class="paramname">result</td><td>collected tokens </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if parent is an unnamed class or enum </dd></dl>

<p>References <a class="el" href="classNativeParserBase#a1-AddChildrenOfEnum">AddChildrenOfEnum()</a>, <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classToken#jd-m_Children">Token::m_Children</a>, <a class="el" href="classToken#no-m_IsAnonymous">Token::m_IsAnonymous</a>, <a class="el" href="classToken#d0-m_Scope">Token::m_Scope</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkEnum">tkEnum</a>, and <a class="el" href="token_8h#bs-TokenScope:tsPrivate">tsPrivate</a>.</p>

</div>
</div>
<a class="anchor" id="fn-AddConstructors"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NativeParserBase::AddConstructors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>loop on the input <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> index set (source), add all its public constructors to output <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> index set (dest) </p>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classToken#jd-m_Children">Token::m_Children</a>, <a class="el" href="classToken#df-m_IsOperator">Token::m_IsOperator</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classToken#d0-m_Scope">Token::m_Scope</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkConstructor">tkConstructor</a>, <a class="el" href="token_8h#bs-TokenScope:tsPublic">tsPublic</a>, and <a class="el" href="token_8h#bs-TokenScope:tsUndefined">tsUndefined</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#gq-ResolveExpression">ResolveExpression()</a>.</p>

</div>
</div>
<a class="anchor" id="zr-AddTemplateAlias"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NativeParserBase::AddTemplateAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>actualTypeScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>initialScope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add template parameter, get the actual parameter from the formal parameter list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>template token id </td></tr>
    <tr><td class="paramname">actualTypeScope</td><td>search scope </td></tr>
    <tr><td class="paramname">initialScope</td><td>resolved result </td></tr>
    <tr><td class="paramname">tree</td><td><a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> tree pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classTokenTree#bj-empty">TokenTree::empty()</a>, <a class="el" href="classToken#zu-m_TemplateAlias">Token::m_TemplateAlias</a>, <a class="el" href="classNativeParserBase#ew-m_TemplateMap">m_TemplateMap</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="classNativeParserBase#jr-ResolveActualType">ResolveActualType()</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, and <a class="el" href="token_8h#uj-TokenKind:tkTypedef">tkTypedef</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#gq-ResolveExpression">ResolveExpression()</a>, and <a class="el" href="classNativeParserBase#f4-ResolveOperator">ResolveOperator()</a>.</p>

</div>
</div>
<a class="anchor" id="dp-AfterWhitespace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int NativeParserBase::AfterWhitespace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>search from left to right, move to the first character of the space </p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;       ::   f&quot;</span></div>
<div class="line">^begin  ^end</div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="classNativeParserBase#q8-FindCCTokenStart">FindCCTokenStart()</a>, <a class="el" href="classNativeParserBase#v6-GetCCToken">GetCCToken()</a>, and <a class="el" href="classNativeParserBase#pz-GetNextCCToken">GetNextCCToken()</a>.</p>

</div>
</div>
<a class="anchor" id="ak-BeforeToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int NativeParserBase::BeforeToken </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classNativeParserBase#q8-FindCCTokenStart">FindCCTokenStart()</a>.</p>

</div>
</div>
<a class="anchor" id="ik-BeforeWhitespace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int NativeParserBase::BeforeWhitespace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move to the char before whitespace and tabs, e.g. </p>
<div class="fragment"><div class="line"> SomeNameSpace       ::  SomeClass</div>
<div class="line">             ^end   ^begin</div>
<div class="line">note <span class="keywordflow">if</span> there some spaces in the begging like</div>
<div class="line">     <span class="stringliteral">&quot;       f::&quot;</span></div>
<div class="line">    ^end    ^begin</div>
</div><!-- fragment --><p> the returned index is -1. </p>

<p>Referenced by <a class="el" href="classNativeParserBase#q8-FindCCTokenStart">FindCCTokenStart()</a>.</p>

</div>
</div>
<a class="anchor" id="vr-BeginOfToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int NativeParserBase::BeginOfToken </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>go to the first character of the identifier, e.g </p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;    f(SomeNameSpace::SomeClass.SomeMethod&quot;</span></div>
<div class="line">                   <span class="keywordflow">return</span> value^         ^begin</div>
</div><!-- fragment --><p> this is the index before the first character of the identifier </p>

<p>Referenced by <a class="el" href="classNativeParserBase#q8-FindCCTokenStart">FindCCTokenStart()</a>.</p>

</div>
</div>
<a class="anchor" id="we-BreakUpComponents"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t NativeParserBase::BreakUpComponents </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; <a class="el" href="structNativeParserBase_1_1ParserComponent">ParserComponent</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>break a statement to several ParserComponents, and store them in a queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actual</td><td>a statement string to be divided. </td></tr>
    <tr><td class="paramname">components</td><td>output variable containing the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of <a class="el" href="structNativeParserBase_1_1ParserComponent" title="a long statement can be divided to a ParserComponent chain. ">ParserComponent</a> </dd></dl>

<p>References <a class="el" href="structNativeParserBase_1_1ParserComponent#ba-component">NativeParserBase::ParserComponent::component</a>, <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="logmanager_8h#ug-F">F()</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, <a class="el" href="classNativeParserBase#v6-GetCCToken">GetCCToken()</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttClass">pttClass</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttFunction">pttFunction</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttNamespace">pttNamespace</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttSearchText">pttSearchText</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttUndefined">pttUndefined</a>, <a class="el" href="nativeparser_8cpp#oc-s_DebugSmartSense">s_DebugSmartSense</a>, <a class="el" href="structNativeParserBase_1_1ParserComponent#eb-tokenOperatorType">NativeParserBase::ParserComponent::tokenOperatorType</a>, <a class="el" href="structNativeParserBase_1_1ParserComponent#q2-tokenType">NativeParserBase::ParserComponent::tokenType</a>, and <a class="el" href="nativeparser__base_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classNativeParser#tf-AI">NativeParser::AI()</a>, <a class="el" href="classNativeParserBase#nm-FindAIMatches">FindAIMatches()</a>, <a class="el" href="classNativeParser#zu-FindCurrentFunctionToken">NativeParser::FindCurrentFunctionToken()</a>, <a class="el" href="classNativeParser#gu-ParseBufferForUsingNamespace">NativeParser::ParseBufferForUsingNamespace()</a>, and <a class="el" href="classNativeParserBase#jr-ResolveActualType">ResolveActualType()</a>.</p>

</div>
</div>
<a class="anchor" id="my-CleanupSearchScope"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NativeParserBase::CleanupSearchScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> *&#160;</td>
          <td class="paramname"><em>searchScope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove all the container tokens in the token index set. </p>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, <a class="el" href="token_8h#uj-TokenKind:tkAnyFunction">tkAnyFunction</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkNamespace">tkNamespace</a>, and <a class="el" href="token_8h#uj-TokenKind:tkTypedef">tkTypedef</a>.</p>

<p>Referenced by <a class="el" href="classNativeParser#tf-AI">NativeParser::AI()</a>.</p>

</div>
</div>
<a class="anchor" id="nm-CollectSearchScopes"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NativeParserBase::CollectSearchScopes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>searchScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>actualTypeScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect search scopes, add the searchScopes's parent scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchScope</td><td>input search scope </td></tr>
    <tr><td class="paramname">actualTypeScope</td><td>returned search scope </td></tr>
    <tr><td class="paramname">tree</td><td><a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> pointer </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classToken#zl-m_Index">Token::m_Index</a>, <a class="el" href="classToken#wc-m_ParentIndex">Token::m_ParentIndex</a>, and <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#gq-ResolveExpression">ResolveExpression()</a>, and <a class="el" href="classNativeParserBase#f4-ResolveOperator">ResolveOperator()</a>.</p>

</div>
</div>
<a class="anchor" id="aa-ComputeCallTip"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NativeParserBase::ComputeCallTip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>tokens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxArrayString &amp;&#160;</td>
          <td class="paramname"><em>items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>call tips are tips when you are entering some functions, such as you have a class definition </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> A() {};</div>
<div class="line">    <span class="keywordtype">void</span> test() { };</div>
<div class="line">};</div>
<div class="line">when you are entering some text like</div>
<div class="line">A(|    or  objA.test(|</div>
</div><!-- fragment --><p> then there will be a tip window show the function prototype of the function </p>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classTokenTree#tb-FindMatches">TokenTree::FindMatches()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">Tokenizer::InitFromBuffer()</a>, <a class="el" href="classToken#wh-m_Args">Token::m_Args</a>, <a class="el" href="classToken#bs-m_BaseType">Token::m_BaseType</a>, <a class="el" href="classToken#jd-m_Children">Token::m_Children</a>, <a class="el" href="classToken#z1-m_FullType">Token::m_FullType</a>, <a class="el" href="classToken#df-m_IsOperator">Token::m_IsOperator</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classToken#d0-m_Scope">Token::m_Scope</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="classTokenizer#pm-PeekToken">Tokenizer::PeekToken()</a>, <a class="el" href="classNativeParserBase#nr-PrettyPrintToken">PrettyPrintToken()</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkConstructor">tkConstructor</a>, <a class="el" href="token_8h#uj-TokenKind:tkFunction">tkFunction</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, <a class="el" href="token_8h#uj-TokenKind:tkVariable">tkVariable</a>, <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>, <a class="el" href="token_8h#bs-TokenScope:tsPublic">tsPublic</a>, and <a class="el" href="token_8h#bs-TokenScope:tsUndefined">tsUndefined</a>.</p>

<p>Referenced by <a class="el" href="classNativeParser#o0-GetCallTips">NativeParser::GetCallTips()</a>.</p>

</div>
</div>
<a class="anchor" id="j0-CountCommas"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int NativeParserBase::CountCommas </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>lineText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classCodeCompletion#kp-GetCallTips">CodeCompletion::GetCallTips()</a>.</p>

</div>
</div>
<a class="anchor" id="ji-DependsOnAllocator"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NativeParserBase::DependsOnAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if token with this id depends on allocator class. </p>
<p>Currently, this function only identifies STL containers dependent on allocator.</p>
<p>All functions that call this recursive function, should already entered a critical section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td><a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> pointer </td></tr>
    <tr><td class="paramname">id</td><td>token idx </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classToken#wc-m_ParentIndex">Token::m_ParentIndex</a>, and <a class="el" href="classToken#nh-m_TemplateArgument">Token::m_TemplateArgument</a>.</p>

</div>
</div>
<a class="anchor" id="nm-FindAIMatches"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t NativeParserBase::FindAIMatches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; <a class="el" href="structNativeParserBase_1_1ParserComponent">ParserComponent</a> &gt;&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parentTokenIdx</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPrefix</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>caseSensitive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_inheritance</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>kindMask</em> = <code>0xFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> *&#160;</td>
          <td class="paramname"><em>search_scope</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Artificial Intelligence Matching. </p>
<p>All functions that call this recursive function, should already entered a critical section or a mutex to protect the <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a>.</p>
<p>match (consume) the <a class="el" href="structNativeParserBase_1_1ParserComponent" title="a long statement can be divided to a ParserComponent chain. ">ParserComponent</a> queue from left to right, the output result becomes the search scope of the next match. finally, give the results which match the last <a class="el" href="structNativeParserBase_1_1ParserComponent" title="a long statement can be divided to a ParserComponent chain. ">ParserComponent</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">components</td><td>input <a class="el" href="structNativeParserBase_1_1ParserComponent" title="a long statement can be divided to a ParserComponent chain. ">ParserComponent</a> queue </td></tr>
    <tr><td class="paramname">parentTokenIdx,initial</td><td>search scope of the left most component, this is the direct parent of the current statement(expression) </td></tr>
    <tr><td class="paramname">fullMatch</td><td>the result should be a full text match or prefix match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>matching token number, it is the size of result </dd></dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classNativeParserBase#we-BreakUpComponents">BreakUpComponents()</a>, <a class="el" href="structNativeParserBase_1_1ParserComponent#ba-component">NativeParserBase::ParserComponent::component</a>, <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="logmanager_8h#ug-F">F()</a>, <a class="el" href="classNativeParserBase#lo-GenerateResultSet">GenerateResultSet()</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, <a class="el" href="classToken#bs-m_BaseType">Token::m_BaseType</a>, <a class="el" href="classToken#jd-m_Children">Token::m_Children</a>, <a class="el" href="classToken#zl-m_Index">Token::m_Index</a>, <a class="el" href="classToken#df-m_IsOperator">Token::m_IsOperator</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classToken#wc-m_ParentIndex">Token::m_ParentIndex</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttSearchText">pttSearchText</a>, <a class="el" href="nativeparser_8cpp#oc-s_DebugSmartSense">s_DebugSmartSense</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkEnum">tkEnum</a>, <a class="el" href="token_8h#uj-TokenKind:tkNamespace">tkNamespace</a>, <a class="el" href="token_8h#uj-TokenKind:tkTypedef">tkTypedef</a>, <a class="el" href="structNativeParserBase_1_1ParserComponent#q2-tokenType">NativeParserBase::ParserComponent::tokenType</a>, and <a class="el" href="nativeparser__base_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classNativeParser#zu-FindCurrentFunctionToken">NativeParser::FindCurrentFunctionToken()</a>.</p>

</div>
</div>
<a class="anchor" id="q8-FindCCTokenStart"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int NativeParserBase::FindCCTokenStart </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to split the statement </p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;    SomeNameSpace::SomeClass.SomeMethod|&quot;</span></div>
<div class="line">     ^  should stop here  &lt;------------ ^ start from here, go backward(right to left)</div>
<div class="line"><span class="stringliteral">&quot;    f(SomeNameSpace::SomeClass.SomeMethod|&quot;</span></div>
<div class="line">       ^ should stop here</div>
</div><!-- fragment --><p> so, brace level should be considered </p>

<p>References <a class="el" href="classNativeParserBase#dp-AfterWhitespace">AfterWhitespace()</a>, <a class="el" href="classNativeParserBase#ak-BeforeToken">BeforeToken()</a>, <a class="el" href="classNativeParserBase#ik-BeforeWhitespace">BeforeWhitespace()</a>, <a class="el" href="classNativeParserBase#vr-BeginOfToken">BeginOfToken()</a>, <a class="el" href="classNativeParserBase#xe-IsClosingBracket">IsClosingBracket()</a>, <a class="el" href="classNativeParserBase#ii-IsOpeningBracket">IsOpeningBracket()</a>, <a class="el" href="classNativeParserBase#qv-IsOperatorDot">IsOperatorDot()</a>, <a class="el" href="classNativeParserBase#pi-IsOperatorEnd">IsOperatorEnd()</a>, and <a class="el" href="nativeparser__base_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#v6-GetCCToken">GetCCToken()</a>.</p>

</div>
</div>
<a class="anchor" id="e0-FindCurrentFunctionScope"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NativeParserBase::FindCurrentFunctionScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>procResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>scopeResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if the expression return the container tokens, which are the parent of the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procResult</td><td>input function index collection </td></tr>
    <tr><td class="paramname">scopeResult</td><td>filtered output function index collection </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, <a class="el" href="classToken#q3-HasChildren">Token::HasChildren()</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classToken#wc-m_ParentIndex">Token::m_ParentIndex</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="nativeparser_8cpp#oc-s_DebugSmartSense">s_DebugSmartSense</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, <a class="el" href="token_8h#uj-TokenKind:tkAnyFunction">tkAnyFunction</a>, and <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>.</p>

<p>Referenced by <a class="el" href="classNativeParser#tf-AI">NativeParser::AI()</a>.</p>

</div>
</div>
<a class="anchor" id="s5-FindFunctionOpenParenthesis"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NativeParserBase::FindFunctionOpenParenthesis </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>calltip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for <a class="el" href="classNativeParserBase#er-GetCallTipHighlight" title="Returns the start and end of the call-tip highlight region. ">GetCallTipHighlight()</a> Finds the position of the opening parenthesis marking the beginning of the params. </p>

<p>Referenced by <a class="el" href="classNativeParserBase#er-GetCallTipHighlight">GetCallTipHighlight()</a>.</p>

</div>
</div>
<a class="anchor" id="lo-GenerateResultSet"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t NativeParserBase::GenerateResultSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parentIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>caseSens</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPrefix</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>kindMask</em> = <code>0xFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the matching results under the Parent <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> index set. </p>
<p>All functions that call this recursive function, should already entered a critical section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td><a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> pointer </td></tr>
    <tr><td class="paramname">target</td><td>Scope (defined in TokenIdxSet) </td></tr>
    <tr><td class="paramname">result</td><td>result token index set </td></tr>
    <tr><td class="paramname">isPrefix</td><td>whether a full match is used or only do a prefix match </td></tr>
    <tr><td class="paramname">kindMask</td><td>define the result tokens filter, such as only class type is OK </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result token set number </dd></dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="logmanager_8h#ug-F">F()</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, <a class="el" href="classToken#x7-GetTokenKindString">Token::GetTokenKindString()</a>, <a class="el" href="classTokenTree#yf-GetTokens">TokenTree::GetTokens()</a>, <a class="el" href="classToken#kh-m_Aliases">Token::m_Aliases</a>, <a class="el" href="classToken#iq-m_Ancestors">Token::m_Ancestors</a>, <a class="el" href="classToken#jd-m_Children">Token::m_Children</a>, <a class="el" href="classToken#zl-m_Index">Token::m_Index</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classToken#wc-m_ParentIndex">Token::m_ParentIndex</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="classNativeParserBase#an-MatchText">MatchText()</a>, <a class="el" href="classNativeParserBase#q5-MatchType">MatchType()</a>, <a class="el" href="classTokenTree#ww-RecalcInheritanceChain">TokenTree::RecalcInheritanceChain()</a>, <a class="el" href="nativeparser_8cpp#oc-s_DebugSmartSense">s_DebugSmartSense</a>, <a class="el" href="token_8h#uj-TokenKind:tkEnum">tkEnum</a>, <a class="el" href="token_8h#uj-TokenKind:tkNamespace">tkNamespace</a>, and <a class="el" href="nativeparser__base_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#nm-FindAIMatches">FindAIMatches()</a>, <a class="el" href="classNativeParser#zu-FindCurrentFunctionToken">NativeParser::FindCurrentFunctionToken()</a>, <a class="el" href="classNativeParserBase#jr-ResolveActualType">ResolveActualType()</a>, <a class="el" href="classNativeParserBase#gq-ResolveExpression">ResolveExpression()</a>, and <a class="el" href="classNativeParserBase#f4-ResolveOperator">ResolveOperator()</a>.</p>

</div>
</div>
<a class="anchor" id="p0-GenerateResultSet"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t NativeParserBase::GenerateResultSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ptrParentID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>caseSens</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPrefix</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>kindMask</em> = <code>0xFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is just like the one above, especially that it use a single parent <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> id, not the parent id set in previous one. </p>
<p>All functions that call this recursive function, should already entered a critical section. </p>

</div>
</div>
<a class="anchor" id="er-GetCallTipHighlight"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NativeParserBase::GetCallTipHighlight </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>calltip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typedCommas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the start and end of the call-tip highlight region. </p>

<p>References <a class="el" href="classNativeParserBase#s5-FindFunctionOpenParenthesis">FindFunctionOpenParenthesis()</a>, and <a class="el" href="nativeparser__base_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classCodeCompletion#kp-GetCallTips">CodeCompletion::GetCallTips()</a>.</p>

</div>
</div>
<a class="anchor" id="v6-GetCCToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString NativeParserBase::GetCCToken </td>
          <td>(</td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNativeParserBase#u7-ParserTokenType">ParserTokenType</a> &amp;&#160;</td>
          <td class="paramname"><em>tokenType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNativeParserBase#q3-OperatorType">OperatorType</a> &amp;&#160;</td>
          <td class="paramname"><em>tokenOperatorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to split the statement line contains a string on the following form: </p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;    char* mychar = SomeNamespace::m_SomeVar.SomeMeth&quot;</span></div>
</div><!-- fragment --><p> first we locate the first non-space char starting from the <em>end</em>: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;    char* mychar = SomeNamespace::m_SomeVar.SomeMeth&quot;</span></div>
</div><!-- fragment --><p> ^ then we remove everything before it. after it, what we do here, is (by this example) return "SomeNamespace" <em>and</em> modify line to become: </p><div class="fragment"><div class="line">m_SomeVar.SomeMeth</div>
</div><!-- fragment --><p> so that if we 're called again with the (modified) line, we 'll return "m_SomeVar" and modify line (again) to become: </p><div class="fragment"><div class="line">SomeMeth</div>
</div><!-- fragment --><p> and so on and so forth until we return an empty string... NOTE: if we find () args or [] arrays in our way, we skip them (done in GetNextCCToken)... </p>

<p>References <a class="el" href="classNativeParserBase#dp-AfterWhitespace">AfterWhitespace()</a>, <a class="el" href="classNativeParserBase#q8-FindCCTokenStart">FindCCTokenStart()</a>, <a class="el" href="classNativeParserBase#pz-GetNextCCToken">GetNextCCToken()</a>, <a class="el" href="classNativeParserBase#qv-IsOperatorDot">IsOperatorDot()</a>, <a class="el" href="classNativeParserBase#pi-IsOperatorEnd">IsOperatorEnd()</a>, <a class="el" href="classNativeParserBase#ic-IsOperatorPointer">IsOperatorPointer()</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorParentheses">otOperatorParentheses</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorPointer">otOperatorPointer</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorSquare">otOperatorSquare</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorUndefined">otOperatorUndefined</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttClass">pttClass</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttFunction">pttFunction</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttNamespace">pttNamespace</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttSearchText">pttSearchText</a>, and <a class="el" href="nativeparser__base_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#we-BreakUpComponents">BreakUpComponents()</a>.</p>

</div>
</div>
<a class="anchor" id="pz-GetNextCCToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString NativeParserBase::GetNextCCToken </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNativeParserBase#q3-OperatorType">OperatorType</a> &amp;&#160;</td>
          <td class="paramname"><em>tokenOperatorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to read the next CCToken, begin from the startAt, this point to a non-space character, and fetch the beginning identifier </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startAt</td><td>this will be updated to the char after the identifier </td></tr>
    <tr><td class="paramname">tokenOperatorType</td><td>the type of the operator E.g. <div class="fragment"><div class="line">SomeMethod()-&gt;</div>
<div class="line">^begin</div>
</div><!-- fragment --> the returned wxString is "SomeMethod", the tokenOperatorType is pointer member access </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classNativeParserBase#dp-AfterWhitespace">AfterWhitespace()</a>, <a class="el" href="classNativeParserBase#ly-InsideToken">InsideToken()</a>, <a class="el" href="classNativeParserBase#xe-IsClosingBracket">IsClosingBracket()</a>, <a class="el" href="classNativeParserBase#ii-IsOpeningBracket">IsOpeningBracket()</a>, <a class="el" href="classNativeParserBase#gz-IsOperatorBegin">IsOperatorBegin()</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorParentheses">otOperatorParentheses</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorSquare">otOperatorSquare</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorStar">otOperatorStar</a>, and <a class="el" href="nativeparser__base_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#v6-GetCCToken">GetCCToken()</a>.</p>

</div>
</div>
<a class="anchor" id="ez-GetTokenFromCurrentLine"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NativeParserBase::GetTokenFromCurrentLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>tokens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>curLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used to get the correct token index in current line, e.g. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">void</span> test()</div>
<div class="line">   {               <span class="comment">// start of the function body</span></div>
<div class="line">      |</div>
<div class="line">   };              <span class="comment">// end of the function body</span></div>
<div class="line">};</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tokens</td><td>all current file's function and class, which cover the current line </td></tr>
    <tr><td class="paramname">curLine</td><td>the line of the current caret position </td></tr>
    <tr><td class="paramname">file</td><td>editor file name </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classToken#a0-DisplayName">Token::DisplayName()</a>, <a class="el" href="classToken#y8-GetFilename">Token::GetFilename()</a>, <a class="el" href="classTokenTree#h8-InsertFileOrGetIndex">TokenTree::InsertFileOrGetIndex()</a>, <a class="el" href="classToken#ot-m_ImplFileIdx">Token::m_ImplFileIdx</a>, <a class="el" href="classToken#ur-m_ImplLine">Token::m_ImplLine</a>, <a class="el" href="classToken#tv-m_ImplLineEnd">Token::m_ImplLineEnd</a>, <a class="el" href="classToken#b7-m_ImplLineStart">Token::m_ImplLineStart</a>, <a class="el" href="classToken#zl-m_Index">Token::m_Index</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="token_8h#uj-TokenKind:tkAnyFunction">tkAnyFunction</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkConstructor">tkConstructor</a>, and <a class="el" href="nativeparser__base_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classNativeParser#qf-FindCurrentFunctionStart">NativeParser::FindCurrentFunctionStart()</a>.</p>

</div>
</div>
<a class="anchor" id="ly-InsideToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool NativeParserBase::InsideToken </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the line[startAt] point to the identifier </p>
<div class="fragment"><div class="line">SomeMethod(<a class="code" href="sqvm_8cpp#wp-arg1">arg1</a>, <a class="code" href="sqvm_8cpp#ga-arg2">arg2</a>)-&gt;Method2()</div>
<div class="line">^^^^^^^^^^ those index will <span class="keywordflow">return</span> <span class="keyword">true</span></div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="classNativeParserBase#pz-GetNextCCToken">GetNextCCToken()</a>.</p>

</div>
</div>
<a class="anchor" id="dg-IsAllocator"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NativeParserBase::IsAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if token with this id is allocator class. </p>
<p>All functions that call this function, should already entered a critical section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td><a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> pointer </td></tr>
    <tr><td class="paramname">id</td><td>token idx </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, and <a class="el" href="classToken#el-m_Name">Token::m_Name</a>.</p>

</div>
</div>
<a class="anchor" id="k1-IsChildOfUnnamedOrEnum"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NativeParserBase::IsChildOfUnnamedOrEnum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>targetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>parentIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check to see if the token is an unnamed class or enum under the parent token </p>
<p>This function will internally recursive call itself. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to the <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> </td></tr>
    <tr><td class="paramname">targetIdx</td><td>the checked token index </td></tr>
    <tr><td class="paramname">parentIdx</td><td>the search scope </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if success </dd></dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classToken#jd-m_Children">Token::m_Children</a>, <a class="el" href="classToken#no-m_IsAnonymous">Token::m_IsAnonymous</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, and <a class="el" href="token_8h#uj-TokenKind:tkEnum">tkEnum</a>.</p>

</div>
</div>
<a class="anchor" id="xe-IsClosingBracket"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool NativeParserBase::IsClosingBracket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the current char (line[startAt]) is either ')' or ']' </p>

<p>Referenced by <a class="el" href="classNativeParserBase#q8-FindCCTokenStart">FindCCTokenStart()</a>, and <a class="el" href="classNativeParserBase#pz-GetNextCCToken">GetNextCCToken()</a>.</p>

</div>
</div>
<a class="anchor" id="ii-IsOpeningBracket"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool NativeParserBase::IsOpeningBracket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classNativeParserBase#q8-FindCCTokenStart">FindCCTokenStart()</a>, and <a class="el" href="classNativeParserBase#pz-GetNextCCToken">GetNextCCToken()</a>.</p>

</div>
</div>
<a class="anchor" id="gz-IsOperatorBegin"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool NativeParserBase::IsOperatorBegin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if startAt point to "-&gt;" or "::" operator </p>

<p>Referenced by <a class="el" href="classNativeParserBase#pz-GetNextCCToken">GetNextCCToken()</a>.</p>

</div>
</div>
<a class="anchor" id="qv-IsOperatorDot"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool NativeParserBase::IsOperatorDot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether line[startAt] is a dot character </p>

<p>Referenced by <a class="el" href="classNativeParserBase#q8-FindCCTokenStart">FindCCTokenStart()</a>, and <a class="el" href="classNativeParserBase#v6-GetCCToken">GetCCToken()</a>.</p>

</div>
</div>
<a class="anchor" id="pi-IsOperatorEnd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool NativeParserBase::IsOperatorEnd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check startAt is at some character like: </p>
<div class="fragment"><div class="line">SomeNameSpace::SomeClass</div>
<div class="line">              ^ here is a <span class="keywordtype">double</span> <a class="code" href="namespaceParserConsts#ox-colon">colon</a></div>
<div class="line">SomeObject-&gt;SomeMethod</div>
<div class="line">           ^ here is a pointer member access <span class="keyword">operator</span></div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="classNativeParserBase#q8-FindCCTokenStart">FindCCTokenStart()</a>, and <a class="el" href="classNativeParserBase#v6-GetCCToken">GetCCToken()</a>.</p>

</div>
</div>
<a class="anchor" id="ic-IsOperatorPointer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool NativeParserBase::IsOperatorPointer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classNativeParserBase#v6-GetCCToken">GetCCToken()</a>.</p>

</div>
</div>
<a class="anchor" id="an-MatchText"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NativeParserBase::MatchText </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>caseSens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classNativeParserBase#lo-GenerateResultSet">GenerateResultSet()</a>.</p>

</div>
</div>
<a class="anchor" id="q5-MatchType"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NativeParserBase::MatchType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="token_8h#uj-TokenKind">TokenKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>kindMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classNativeParserBase#lo-GenerateResultSet">GenerateResultSet()</a>.</p>

</div>
</div>
<a class="anchor" id="nr-PrettyPrintToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NativeParserBase::PrettyPrintToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRoot</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For <a class="el" href="classNativeParserBase#aa-ComputeCallTip" title="call tips are tips when you are entering some functions, such as you have a class definition ...">ComputeCallTip()</a> No critical section needed in this recursive function! All functions that call this recursive function, should already entered a critical section. </p>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classToken#py-GetFormattedArgs">Token::GetFormattedArgs()</a>, <a class="el" href="classToken#wh-m_Args">Token::m_Args</a>, <a class="el" href="classToken#bs-m_BaseType">Token::m_BaseType</a>, <a class="el" href="classToken#z1-m_FullType">Token::m_FullType</a>, <a class="el" href="classToken#sk-m_IsConst">Token::m_IsConst</a>, <a class="el" href="classToken#ht-m_IsNoExcept">Token::m_IsNoExcept</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classToken#wc-m_ParentIndex">Token::m_ParentIndex</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="token_8h#uj-TokenKind:tkAnyContainer">tkAnyContainer</a>, <a class="el" href="token_8h#uj-TokenKind:tkAnyFunction">tkAnyFunction</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkConstructor">tkConstructor</a>, <a class="el" href="token_8h#uj-TokenKind:tkDestructor">tkDestructor</a>, <a class="el" href="token_8h#uj-TokenKind:tkEnum">tkEnum</a>, <a class="el" href="token_8h#uj-TokenKind:tkEnumerator">tkEnumerator</a>, <a class="el" href="token_8h#uj-TokenKind:tkFunction">tkFunction</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroUse">tkMacroUse</a>, <a class="el" href="token_8h#uj-TokenKind:tkNamespace">tkNamespace</a>, <a class="el" href="token_8h#uj-TokenKind:tkTypedef">tkTypedef</a>, <a class="el" href="token_8h#uj-TokenKind:tkUndefined">tkUndefined</a>, <a class="el" href="token_8h#uj-TokenKind:tkVariable">tkVariable</a>, and <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#aa-ComputeCallTip">ComputeCallTip()</a>.</p>

</div>
</div>
<a class="anchor" id="zx-RemoveLastFunctionChildren"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NativeParserBase::RemoveLastFunctionChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>lastFuncTokenIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last function's children, when doing codecompletion in a function body, the function body up to the caret position was parsed, and the local variables defined in the function were recorded as the function's children. </p>
<p>Note that there tokens are marked as temporary tokens, so If the edit caret moves to another function body, those temporary tokens should be removed. </p>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classToken#q1-DeleteAllChildren">Token::DeleteAllChildren()</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, and <a class="el" href="token_8h#uj-TokenKind:tkAnyFunction">tkAnyFunction</a>.</p>

<p>Referenced by <a class="el" href="classNativeParser#jh-MarkItemsByAI">NativeParser::MarkItemsByAI()</a>, and <a class="el" href="classNativeParser#rg-SetParser">NativeParser::SetParser()</a>.</p>

</div>
</div>
<a class="anchor" id="ls-Reset"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NativeParserBase::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Init cc search member variables. </p>

<p>References <a class="el" href="structNativeParserBase_1_1ParserComponent#py-Clear">NativeParserBase::ParserComponent::Clear()</a>, and <a class="el" href="classNativeParserBase#gu-m_LastComponent">m_LastComponent</a>.</p>

<p>Referenced by <a class="el" href="classNativeParser#c2-InitCCSearchVariables">NativeParser::InitCCSearchVariables()</a>.</p>

</div>
</div>
<a class="anchor" id="jr-ResolveActualType"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t NativeParserBase::ResolveActualType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxString&#160;</td>
          <td class="paramname"><em>searchText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>searchScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Type information of the searchText string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchText</td><td>input search text </td></tr>
    <tr><td class="paramname">searchScope</td><td>search scope defined in TokenIdxSet format </td></tr>
    <tr><td class="paramname">result</td><td>result token specify the Type of searchText </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classNativeParserBase#we-BreakUpComponents">BreakUpComponents()</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="structNativeParserBase_1_1ParserComponent#ba-component">NativeParserBase::ParserComponent::component</a>, <a class="el" href="classNativeParserBase#lo-GenerateResultSet">GenerateResultSet()</a>, and <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#zr-AddTemplateAlias">AddTemplateAlias()</a>, <a class="el" href="classNativeParserBase#gq-ResolveExpression">ResolveExpression()</a>, <a class="el" href="classNativeParserBase#f4-ResolveOperator">ResolveOperator()</a>, and <a class="el" href="classNativeParserBase#as-ResolveTemplateMap">ResolveTemplateMap()</a>.</p>

</div>
</div>
<a class="anchor" id="gq-ResolveExpression"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t NativeParserBase::ResolveExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; <a class="el" href="structNativeParserBase_1_1ParserComponent">ParserComponent</a> &gt;&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>searchScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>caseSense</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPrefix</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A statement(expression) is expressed by a <a class="el" href="structNativeParserBase_1_1ParserComponent" title="a long statement can be divided to a ParserComponent chain. ">ParserComponent</a> queue We do a match from the left of the queue one by one. </p>
<p>Here is a simple description about the algorithm, suppose we have such code snippet </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>AAA</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">class </span>BBB</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">int</span> m_aaa;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">class </span>CCC</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        BBB fun();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line">AAA::CCC obj;</div>
<div class="line">obj.fun().|-----we want to <span class="keyword">get</span> code suggestion list here</div>
</div><!-- fragment --><p> We first split the statement "obj.fun()." into 3 components: component name </p><div class="fragment"><div class="line">1, obj</div>
<div class="line">2, fun</div>
<div class="line">3, <a class="code" href="namespaceParserConsts#gs-empty">empty</a></div>
</div><!-- fragment --><p> We do three loops here, each loop, we consume one component. Also each loop's result will serve as the next loop's search scope.</p>
<p>Loop 1 We first search the tree by the text "obj", we find a matched variable token, which has the type string "AAA::CCC", then the text "AAA::CCC" is resolved to a class kind token "class CCC" Loop 2 We search the tree by the text "fun". Here the search scope should be "CCC", it's the result from the previous loop, so we find that there is a function kind token under "class CCC", which is "function fun()" token. Then we need to see the return type of the fun() token, which is the name "BBB". Then we do another text search for "BBB" in the tree, and find a class kind token "class BBB" Loop 3 Since the last search text is empty, we just return all the children of the "class BBB" token, so finally, we give the child variable kind token "m_aaa", then the code suggestion should prompt the string "m_aaa"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">tree</td><td>the token tree pointer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">components</td><td>expression structure expressed in std::queue&lt;ParserComponent&gt; </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">searchScope</td><td>search scope defined by TokenIdxSet </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">the</td><td>final result token index </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">caseSense</td><td>case sensitive match </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">isPrefix</td><td>match type( full match or prefix match) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result tokens count </dd></dl>

<p>References <a class="el" href="classNativeParserBase#fn-AddConstructors">AddConstructors()</a>, <a class="el" href="classNativeParserBase#zr-AddTemplateAlias">AddTemplateAlias()</a>, <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classNativeParserBase#nm-CollectSearchScopes">CollectSearchScopes()</a>, <a class="el" href="structNativeParserBase_1_1ParserComponent#ba-component">NativeParserBase::ParserComponent::component</a>, <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="logmanager_8h#ug-F">F()</a>, <a class="el" href="classNativeParserBase#lo-GenerateResultSet">GenerateResultSet()</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, <a class="el" href="classToken#bs-m_BaseType">Token::m_BaseType</a>, <a class="el" href="classToken#zl-m_Index">Token::m_Index</a>, <a class="el" href="classToken#df-m_IsOperator">Token::m_IsOperator</a>, <a class="el" href="classNativeParserBase#gu-m_LastComponent">m_LastComponent</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classToken#wc-m_ParentIndex">Token::m_ParentIndex</a>, <a class="el" href="classToken#he-m_TemplateMap">Token::m_TemplateMap</a>, <a class="el" href="classNativeParserBase#ew-m_TemplateMap">m_TemplateMap</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorUndefined">otOperatorUndefined</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttNamespace">pttNamespace</a>, <a class="el" href="classNativeParserBase#u7-ParserTokenType:pttSearchText">pttSearchText</a>, <a class="el" href="classNativeParserBase#jr-ResolveActualType">ResolveActualType()</a>, <a class="el" href="classNativeParserBase#f4-ResolveOperator">ResolveOperator()</a>, <a class="el" href="classNativeParserBase#as-ResolveTemplateMap">ResolveTemplateMap()</a>, <a class="el" href="nativeparser_8cpp#oc-s_DebugSmartSense">s_DebugSmartSense</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="structNativeParserBase_1_1ParserComponent#eb-tokenOperatorType">NativeParserBase::ParserComponent::tokenOperatorType</a>, and <a class="el" href="structNativeParserBase_1_1ParserComponent#q2-tokenType">NativeParserBase::ParserComponent::tokenType</a>.</p>

<p>Referenced by <a class="el" href="classNativeParser#tf-AI">NativeParser::AI()</a>.</p>

</div>
</div>
<a class="anchor" id="f4-ResolveOperator"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NativeParserBase::ResolveOperator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNativeParserBase#q3-OperatorType">OperatorType</a> &amp;&#160;</td>
          <td class="paramname"><em>tokenOperatorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>tokens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>searchScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used to solve the overloaded operator functions return type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tokenOperatorType</td><td>overloaded operator type, could be [], (), -&gt; </td></tr>
    <tr><td class="paramname">tokens</td><td>input tokens set </td></tr>
    <tr><td class="paramname">tree</td><td><a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> tree pointer </td></tr>
    <tr><td class="paramname">searchScope</td><td>search scope </td></tr>
    <tr><td class="paramname">result</td><td>output result </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classNativeParserBase#zr-AddTemplateAlias">AddTemplateAlias()</a>, <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classNativeParserBase#nm-CollectSearchScopes">CollectSearchScopes()</a>, <a class="el" href="classTokenTree#bj-empty">TokenTree::empty()</a>, <a class="el" href="classNativeParserBase#lo-GenerateResultSet">GenerateResultSet()</a>, <a class="el" href="classToken#bs-m_BaseType">Token::m_BaseType</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorParentheses">otOperatorParentheses</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorPointer">otOperatorPointer</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorSquare">otOperatorSquare</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorStar">otOperatorStar</a>, <a class="el" href="classNativeParserBase#q3-OperatorType:otOperatorUndefined">otOperatorUndefined</a>, <a class="el" href="classNativeParserBase#jr-ResolveActualType">ResolveActualType()</a>, <a class="el" href="classNativeParserBase#as-ResolveTemplateMap">ResolveTemplateMap()</a>, <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, and <a class="el" href="token_8h#uj-TokenKind:tkTypedef">tkTypedef</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#gq-ResolveExpression">ResolveExpression()</a>.</p>

</div>
</div>
<a class="anchor" id="as-ResolveTemplateMap"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NativeParserBase::ResolveTemplateMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>searchStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>actualTypeScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> &amp;&#160;</td>
          <td class="paramname"><em>initialScope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resolve template map [formal parameter] to [actual parameter] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchStr</td><td>input Search String </td></tr>
    <tr><td class="paramname">actualtypeScope</td><td><a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> type(actual parameter) </td></tr>
    <tr><td class="paramname">initialScope</td><td>search scope </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classNativeParserBase#ew-m_TemplateMap">m_TemplateMap</a>, and <a class="el" href="classNativeParserBase#jr-ResolveActualType">ResolveActualType()</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#gq-ResolveExpression">ResolveExpression()</a>, and <a class="el" href="classNativeParserBase#f4-ResolveOperator">ResolveOperator()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="gu-m_LastComponent"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNativeParserBase_1_1ParserComponent">ParserComponent</a> NativeParserBase::m_LastComponent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classNativeParserBase#ls-Reset">Reset()</a>, and <a class="el" href="classNativeParserBase#gq-ResolveExpression">ResolveExpression()</a>.</p>

</div>
</div>
<a class="anchor" id="ew-m_TemplateMap"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;wxString, wxString&gt; NativeParserBase::m_TemplateMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classNativeParserBase#zr-AddTemplateAlias">AddTemplateAlias()</a>, <a class="el" href="classNativeParserBase#gq-ResolveExpression">ResolveExpression()</a>, and <a class="el" href="classNativeParserBase#as-ResolveTemplateMap">ResolveTemplateMap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="nativeparser__base_8h_source">nativeparser_base.h</a></li>
<li><a class="el" href="nativeparser__base_8cpp">nativeparser_base.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
