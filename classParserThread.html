<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Code::Blocks: ParserThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Code::Blocks
   &#160;<span id="projectnumber">SVN r10345</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated"><span>Classes</span></a></li>
      <li><a href="files"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated"><span>Class&#160;List</span></a></li>
      <li><a href="classes"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classParserThread-members">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ParserThread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A parser threaded task, which can be assigned to the thread task pool, and run there.  
 <a href="classParserThread#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="parserthread_8h_source">parserthread.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ParserThread:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classParserThread__inherit__graph.svg" width="238" height="742"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for ParserThread:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classParserThread__coll__graph.svg" width="2230" height="3258"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:kb-ParserThread"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#kb-ParserThread">ParserThread</a> (<a class="el" href="classParserBase">ParserBase</a> *parent, const wxString &amp;bufferOrFilename, bool isLocal, <a class="el" href="structParserThreadOptions">ParserThreadOptions</a> &amp;parserThreadOptions, <a class="el" href="classTokenTree">TokenTree</a> *tokenTree)</td></tr>
<tr class="memdesc:kb-ParserThread"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a> constructor.  <a href="#kb-ParserThread">More...</a><br /></td></tr>
<tr class="separator:kb-ParserThread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:js-ParserThread"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#js-ParserThread">~ParserThread</a> ()</td></tr>
<tr class="memdesc:js-ParserThread"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a> destructor.  <a href="#js-ParserThread">More...</a><br /></td></tr>
<tr class="separator:js-ParserThread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:te-Parse"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#te-Parse">Parse</a> ()</td></tr>
<tr class="memdesc:te-Parse"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the main job (syntax analysis) here.  <a href="#te-Parse">More...</a><br /></td></tr>
<tr class="separator:te-Parse"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:i9-ParseBufferForNamespaces"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParseBufferForNamespaces</a> (const wxString &amp;buffer, <a class="el" href="parserthread_8h#ia-NameSpaceVec">NameSpaceVec</a> &amp;result)</td></tr>
<tr class="memdesc:i9-ParseBufferForNamespaces"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context "namespace XXX { ... }" directive.  <a href="#i9-ParseBufferForNamespaces">More...</a><br /></td></tr>
<tr class="separator:i9-ParseBufferForNamespaces"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cc-ParseBufferForUsingNamespace"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace</a> (const wxString &amp;buffer, wxArrayString &amp;result)</td></tr>
<tr class="memdesc:cc-ParseBufferForUsingNamespace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context "using namespace XXX" directive.  <a href="#cc-ParseBufferForUsingNamespace">More...</a><br /></td></tr>
<tr class="separator:cc-ParseBufferForUsingNamespace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zz-GetFilename"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#zz-GetFilename">GetFilename</a> ()</td></tr>
<tr class="separator:zz-GetFilename"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcbThreadedTask"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcbThreadedTask')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcbThreadedTask">cbThreadedTask</a></td></tr>
<tr class="memitem:xe-cbThreadedTask inherit pub_methods_classcbThreadedTask"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadedTask#xe-cbThreadedTask">cbThreadedTask</a> ()</td></tr>
<tr class="memdesc:xe-cbThreadedTask inherit pub_methods_classcbThreadedTask"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcbThreadedTask" title="This is what you have to use instead of wxThread to add tasks to the Thread Pool. ...">cbThreadedTask</a> ctor  <a href="#xe-cbThreadedTask">More...</a><br /></td></tr>
<tr class="separator:xe-cbThreadedTask inherit pub_methods_classcbThreadedTask"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:au-cbThreadedTask inherit pub_methods_classcbThreadedTask"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadedTask#au-cbThreadedTask">~cbThreadedTask</a> ()=0</td></tr>
<tr class="memdesc:au-cbThreadedTask inherit pub_methods_classcbThreadedTask"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcbThreadedTask" title="This is what you have to use instead of wxThread to add tasks to the Thread Pool. ...">cbThreadedTask</a> dtor  <a href="#au-cbThreadedTask">More...</a><br /></td></tr>
<tr class="separator:au-cbThreadedTask inherit pub_methods_classcbThreadedTask"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:c2-Abort inherit pub_methods_classcbThreadedTask"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadedTask#c2-Abort">Abort</a> ()</td></tr>
<tr class="memdesc:c2-Abort inherit pub_methods_classcbThreadedTask"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called to tell the task to abort (check <a class="el" href="classcbThreadPool#s5-AbortAllTasks" title="Aborts all running and pending tasks. ">cbThreadPool::AbortAllTasks</a>)  <a href="#c2-Abort">More...</a><br /></td></tr>
<tr class="separator:c2-Abort inherit pub_methods_classcbThreadedTask"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:w8-EClassType"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#w8-EClassType">EClassType</a> { <a class="el" href="classParserThread#w8-EClassType:ctStructure">ctStructure</a> = 0, 
<a class="el" href="classParserThread#w8-EClassType:ctClass">ctClass</a> = 1, 
<a class="el" href="classParserThread#w8-EClassType:ctUnion">ctUnion</a> = 3
 }<tr class="memdesc:w8-EClassType"><td class="mdescLeft">&#160;</td><td class="mdescRight">specify which "class like type" we are handling: struct or class or union  <a href="classParserThread#w8-EClassType">More...</a><br /></td></tr>
<tr class="separator:w8-EClassType"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:bv-Execute"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#bv-Execute">Execute</a> ()</td></tr>
<tr class="memdesc:bv-Execute"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classParserThread#bv-Execute" title="Execute() is a virtual function derived from cbThreadedTask class, we should override it here...">Execute()</a> is a virtual function derived from <a class="el" href="classcbThreadedTask" title="This is what you have to use instead of wxThread to add tasks to the Thread Pool. ...">cbThreadedTask</a> class, we should override it here.  <a href="#bv-Execute">More...</a><br /></td></tr>
<tr class="separator:bv-Execute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zh-SkipToOneOfChars"><td class="memItemLeft" align="right" valign="top">wxChar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#zh-SkipToOneOfChars">SkipToOneOfChars</a> (const wxString &amp;chars, bool supportNesting=false, bool singleCharToken=true)</td></tr>
<tr class="memdesc:zh-SkipToOneOfChars"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continuously eat the tokens until we meet one of the matching characters.  <a href="#zh-SkipToOneOfChars">More...</a><br /></td></tr>
<tr class="separator:zh-SkipToOneOfChars"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tn-DoParse"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#tn-DoParse">DoParse</a> ()</td></tr>
<tr class="memdesc:tn-DoParse"><td class="mdescLeft">&#160;</td><td class="mdescRight">actually run the syntax analysis  <a href="#tn-DoParse">More...</a><br /></td></tr>
<tr class="separator:tn-DoParse"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ru-SkipBlock"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#ru-SkipBlock">SkipBlock</a> ()</td></tr>
<tr class="memdesc:ru-SkipBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight">skip blocks () [] {} &lt;&gt;  <a href="#ru-SkipBlock">More...</a><br /></td></tr>
<tr class="separator:ru-SkipBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pl-SkipAngleBraces"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#pl-SkipAngleBraces">SkipAngleBraces</a> ()</td></tr>
<tr class="memdesc:pl-SkipAngleBraces"><td class="mdescLeft">&#160;</td><td class="mdescRight">skip the template argument  <a href="#pl-SkipAngleBraces">More...</a><br /></td></tr>
<tr class="separator:pl-SkipAngleBraces"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ky-HandleIncludes"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#ky-HandleIncludes">HandleIncludes</a> ()</td></tr>
<tr class="memdesc:ky-HandleIncludes"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle include &lt;XXXX&gt; or include "XXXX" directive.  <a href="#ky-HandleIncludes">More...</a><br /></td></tr>
<tr class="separator:ky-HandleIncludes"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tp-HandleDefines"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#tp-HandleDefines">HandleDefines</a> ()</td></tr>
<tr class="memdesc:tp-HandleDefines"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the statement: #define XXXXX  <a href="#tp-HandleDefines">More...</a><br /></td></tr>
<tr class="separator:tp-HandleDefines"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sn-HandleUndefs"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#sn-HandleUndefs">HandleUndefs</a> ()</td></tr>
<tr class="memdesc:sn-HandleUndefs"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the statement: #undef XXXXX  <a href="#sn-HandleUndefs">More...</a><br /></td></tr>
<tr class="separator:sn-HandleUndefs"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:bg-HandleNamespace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#bg-HandleNamespace">HandleNamespace</a> ()</td></tr>
<tr class="memdesc:bg-HandleNamespace"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the statement: namespace XXX {  <a href="#bg-HandleNamespace">More...</a><br /></td></tr>
<tr class="separator:bg-HandleNamespace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:s3-HandleClass"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#s3-HandleClass">HandleClass</a> (<a class="el" href="classParserThread#w8-EClassType">EClassType</a> ct)</td></tr>
<tr class="memdesc:s3-HandleClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle class declaration  <a href="#s3-HandleClass">More...</a><br /></td></tr>
<tr class="separator:s3-HandleClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oq-HandleFunction"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#oq-HandleFunction">HandleFunction</a> (wxString &amp;name, bool isOperator=false, bool isPointer=false)</td></tr>
<tr class="memdesc:oq-HandleFunction"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle function declaration or definition  <a href="#oq-HandleFunction">More...</a><br /></td></tr>
<tr class="separator:oq-HandleFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:l5-HandleForLoopArguments"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#l5-HandleForLoopArguments">HandleForLoopArguments</a> ()</td></tr>
<tr class="memdesc:l5-HandleForLoopArguments"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse for loop arguments: for(int X; ...  <a href="#l5-HandleForLoopArguments">More...</a><br /></td></tr>
<tr class="separator:l5-HandleForLoopArguments"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:w4-HandleConditionalArguments"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#w4-HandleConditionalArguments">HandleConditionalArguments</a> ()</td></tr>
<tr class="memdesc:w4-HandleConditionalArguments"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse arguments like: if(int X = getNumber())  <a href="#w4-HandleConditionalArguments">More...</a><br /></td></tr>
<tr class="separator:w4-HandleConditionalArguments"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gm-HandleEnum"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#gm-HandleEnum">HandleEnum</a> ()</td></tr>
<tr class="memdesc:gm-HandleEnum"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle enum declaration  <a href="#gm-HandleEnum">More...</a><br /></td></tr>
<tr class="separator:gm-HandleEnum"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nq-CalcEnumExpression"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#nq-CalcEnumExpression">CalcEnumExpression</a> (<a class="el" href="classToken">Token</a> *tokenParent, long &amp;result, wxString &amp;peek)</td></tr>
<tr class="memdesc:nq-CalcEnumExpression"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the value assigned to enumerator  <a href="#nq-CalcEnumExpression">More...</a><br /></td></tr>
<tr class="separator:nq-CalcEnumExpression"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pm-HandleTypedef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef</a> ()</td></tr>
<tr class="memdesc:pm-HandleTypedef"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle typedef directive  <a href="#pm-HandleTypedef">More...</a><br /></td></tr>
<tr class="separator:pm-HandleTypedef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sa-HandleMacroExpansion"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#sa-HandleMacroExpansion">HandleMacroExpansion</a> (int id, const wxString &amp;peek)</td></tr>
<tr class="memdesc:sa-HandleMacroExpansion"><td class="mdescLeft">&#160;</td><td class="mdescRight">We guess this is a macro usage, so try to expand macro.  <a href="#sa-HandleMacroExpansion">More...</a><br /></td></tr>
<tr class="separator:sa-HandleMacroExpansion"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:p3-ReadVarNames"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#p3-ReadVarNames">ReadVarNames</a> ()</td></tr>
<tr class="memdesc:p3-ReadVarNames"><td class="mdescLeft">&#160;</td><td class="mdescRight">eg: class ClassA{...} varA, varB, varC This function will read the "varA, varB, varC"  <a href="#p3-ReadVarNames">More...</a><br /></td></tr>
<tr class="separator:p3-ReadVarNames"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dy-ReadClsNames"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#dy-ReadClsNames">ReadClsNames</a> (wxString &amp;ancestor)</td></tr>
<tr class="memdesc:dy-ReadClsNames"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle class names, e.g., the code below typedef class AAA{ int m_a; int m_b; } BBB,CCC;  <a href="#dy-ReadClsNames">More...</a><br /></td></tr>
<tr class="separator:dy-ReadClsNames"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:hd-DoAddToken"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classToken">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#hd-DoAddToken">DoAddToken</a> (<a class="el" href="token_8h#uj-TokenKind">TokenKind</a> kind, const wxString &amp;name, int line, int implLineStart=0, int implLineEnd=0, const wxString &amp;args=wxEmptyString, bool isOperator=false, bool isImpl=false)</td></tr>
<tr class="memdesc:hd-DoAddToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">add one token to the token tree  <a href="#hd-DoAddToken">More...</a><br /></td></tr>
<tr class="separator:hd-DoAddToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rj-GetTokenBaseType"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#rj-GetTokenBaseType">GetTokenBaseType</a> ()</td></tr>
<tr class="memdesc:rj-GetTokenBaseType"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the actual token's base type.  <a href="#rj-GetTokenBaseType">More...</a><br /></td></tr>
<tr class="separator:rj-GetTokenBaseType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcbThreadedTask"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcbThreadedTask')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcbThreadedTask">cbThreadedTask</a></td></tr>
<tr class="memitem:tp-TestDestroy inherit pro_methods_classcbThreadedTask"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadedTask#tp-TestDestroy">TestDestroy</a> () const </td></tr>
<tr class="memdesc:tp-TestDestroy inherit pro_methods_classcbThreadedTask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Be sure to call this function often. If it returns true, quit your task quickly.  <a href="#tp-TestDestroy">More...</a><br /></td></tr>
<tr class="separator:tp-TestDestroy inherit pro_methods_classcbThreadedTask"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:bi-Aborted inherit pro_methods_classcbThreadedTask"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadedTask#bi-Aborted">Aborted</a> () const </td></tr>
<tr class="memdesc:bi-Aborted inherit pro_methods_classcbThreadedTask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcbThreadedTask#tp-TestDestroy" title="Be sure to call this function often. If it returns true, quit your task quickly. ">TestDestroy()</a>  <a href="#bi-Aborted">More...</a><br /></td></tr>
<tr class="separator:bi-Aborted inherit pro_methods_classcbThreadedTask"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:fc-InitTokenizer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#fc-InitTokenizer">InitTokenizer</a> ()</td></tr>
<tr class="memdesc:fc-InitTokenizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize the m_Buffer, load from local file or use a buffer in memory  <a href="#fc-InitTokenizer">More...</a><br /></td></tr>
<tr class="separator:fc-InitTokenizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mq-TokenExists"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classToken">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#mq-TokenExists">TokenExists</a> (const wxString &amp;name, const <a class="el" href="classToken">Token</a> *parent=0, short int kindMask=0xFFFF)</td></tr>
<tr class="memdesc:mq-TokenExists"><td class="mdescLeft">&#160;</td><td class="mdescRight">if parent is 0, then global namespace will be used, all tokens under parent scope are searched  <a href="#mq-TokenExists">More...</a><br /></td></tr>
<tr class="separator:mq-TokenExists"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rw-TokenExists"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classToken">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#rw-TokenExists">TokenExists</a> (const wxString &amp;name, const wxString &amp;baseArgs, const <a class="el" href="classToken">Token</a> *parent, <a class="el" href="token_8h#uj-TokenKind">TokenKind</a> kind)</td></tr>
<tr class="memdesc:rw-TokenExists"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support function overloading.  <a href="#rw-TokenExists">More...</a><br /></td></tr>
<tr class="separator:rw-TokenExists"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:fp-FindTokenFromQueue"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classToken">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#fp-FindTokenFromQueue">FindTokenFromQueue</a> (std::queue&lt; wxString &gt; &amp;q, <a class="el" href="classToken">Token</a> *parent=0, bool createIfNotExist=false, <a class="el" href="classToken">Token</a> *parentIfCreated=0)</td></tr>
<tr class="memdesc:fp-FindTokenFromQueue"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO comment here?  <a href="#fp-FindTokenFromQueue">More...</a><br /></td></tr>
<tr class="separator:fp-FindTokenFromQueue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zj-GetBaseArgs"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#zj-GetBaseArgs">GetBaseArgs</a> (const wxString &amp;args, wxString &amp;baseArgs)</td></tr>
<tr class="memdesc:zj-GetBaseArgs"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a full argument list (including variable names) to argument types only and strips spaces.  <a href="#zj-GetBaseArgs">More...</a><br /></td></tr>
<tr class="separator:zj-GetBaseArgs"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vz-GetClassFromMacro"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#vz-GetClassFromMacro">GetClassFromMacro</a> (const wxString &amp;macro)</td></tr>
<tr class="memdesc:vz-GetClassFromMacro"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the class name from a macro.  <a href="#vz-GetClassFromMacro">More...</a><br /></td></tr>
<tr class="separator:vz-GetClassFromMacro"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:hy-GetRealTypeIfTokenIsMacro"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#hy-GetRealTypeIfTokenIsMacro">GetRealTypeIfTokenIsMacro</a> (wxString &amp;tokenName)</td></tr>
<tr class="memdesc:hy-GetRealTypeIfTokenIsMacro"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the macro's type, if the token is a macro, and saved the type in tokenName.  <a href="#hy-GetRealTypeIfTokenIsMacro">More...</a><br /></td></tr>
<tr class="separator:hy-GetRealTypeIfTokenIsMacro"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zx-GetTemplateArgs"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#zx-GetTemplateArgs">GetTemplateArgs</a> ()</td></tr>
<tr class="memdesc:zx-GetTemplateArgs"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the &lt;xxxx=yyy, zzz&gt; , and store the value in m_TemplateArgs.  <a href="#zx-GetTemplateArgs">More...</a><br /></td></tr>
<tr class="separator:zx-GetTemplateArgs"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vw-ResolveTemplateArgs"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#vw-ResolveTemplateArgs">ResolveTemplateArgs</a> (<a class="el" href="classToken">Token</a> *newToken)</td></tr>
<tr class="memdesc:vw-ResolveTemplateArgs"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function just associate the formal template argument to actual argument For example, we have such code: template &lt;typename t&gt;=""&gt; class AAA { T m_aaa;}; AAA&lt;int&gt; bbb; When handling the "bbb", we need to construct a TemplateMap, we store the map in the "bbb"'s member variable, which is "T"-&gt;"int".  <a href="#vw-ResolveTemplateArgs">More...</a><br /></td></tr>
<tr class="separator:vw-ResolveTemplateArgs"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:xu-GetTemplateArgArray"><td class="memItemLeft" align="right" valign="top">wxArrayString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#xu-GetTemplateArgArray">GetTemplateArgArray</a> (const wxString &amp;templateArgs, bool remove_gt_lt, bool add_last)</td></tr>
<tr class="memdesc:xu-GetTemplateArgArray"><td class="mdescLeft">&#160;</td><td class="mdescRight">normally the template argument is all in a wxString, this function just split them to a wxArrayString, each element is an actual argument.  <a href="#xu-GetTemplateArgArray">More...</a><br /></td></tr>
<tr class="separator:xu-GetTemplateArgArray"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:y3-SplitTemplateFormalParameters"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#y3-SplitTemplateFormalParameters">SplitTemplateFormalParameters</a> (const wxString &amp;templateArgs, wxArrayString &amp;formals)</td></tr>
<tr class="memdesc:y3-SplitTemplateFormalParameters"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split formal template argument list.  <a href="#y3-SplitTemplateFormalParameters">More...</a><br /></td></tr>
<tr class="separator:y3-SplitTemplateFormalParameters"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mr-SplitTemplateActualParameters"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#mr-SplitTemplateActualParameters">SplitTemplateActualParameters</a> (const wxString &amp;templateArgs, wxArrayString &amp;actuals)</td></tr>
<tr class="memdesc:mr-SplitTemplateActualParameters"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split actual template argument list.  <a href="#mr-SplitTemplateActualParameters">More...</a><br /></td></tr>
<tr class="separator:mr-SplitTemplateActualParameters"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rd-ResolveTemplateMap"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#rd-ResolveTemplateMap">ResolveTemplateMap</a> (const wxString &amp;typeStr, const wxArrayString &amp;actuals, std::map&lt; wxString, wxString &gt; &amp;results)</td></tr>
<tr class="memdesc:rd-ResolveTemplateMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">associate formal argument with actual template argument  <a href="#rd-ResolveTemplateMap">More...</a><br /></td></tr>
<tr class="separator:rd-ResolveTemplateMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8-RemoveTemplateArgs"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#a8-RemoveTemplateArgs">RemoveTemplateArgs</a> (const wxString &amp;expr, wxString &amp;expNoArgs, wxString &amp;templateArgs)</td></tr>
<tr class="memdesc:a8-RemoveTemplateArgs"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove template arguments from an expression example: 'std::list&lt;string&gt;' will be separated into 'std::list' and '&lt;string&gt;'  <a href="#a8-RemoveTemplateArgs">More...</a><br /></td></tr>
<tr class="separator:a8-RemoveTemplateArgs"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jq-IsStillAlive"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#jq-IsStillAlive">IsStillAlive</a> (const wxString &amp;funcInfo)</td></tr>
<tr class="memdesc:jq-IsStillAlive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only for debug.  <a href="#jq-IsStillAlive">More...</a><br /></td></tr>
<tr class="separator:jq-IsStillAlive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gl-RefineAnonymousTypeToken"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#gl-RefineAnonymousTypeToken">RefineAnonymousTypeToken</a> (short int typeMask, wxString alise)</td></tr>
<tr class="memdesc:gl-RefineAnonymousTypeToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">change an anonymous(unnamed) token's name to a human readable name, the m_Str is expect to store the unnamed token name, for example, for parsing the code struct { int x; float y; } abc; when we first find an anonymous token, which is named _UnnamedStruct1_2, after this function call, the anonymous token name will becomes struct1_abc, and m_Str will changed from _UnnamedStruct1_2 to struct1_abc.  <a href="#gl-RefineAnonymousTypeToken">More...</a><br /></td></tr>
<tr class="separator:gl-RefineAnonymousTypeToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:xs-m_Tokenizer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTokenizer">Tokenizer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a></td></tr>
<tr class="memdesc:xs-m_Tokenizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">if we regard the parserThread class as a syntax analyzer, then the <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> class is regard as the lexer, which always feeds a wxString by calling m_Tokenizer.GetToken()  <a href="#xs-m_Tokenizer">More...</a><br /></td></tr>
<tr class="separator:xs-m_Tokenizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lq-m_Parent"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParserBase">ParserBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#lq-m_Parent">m_Parent</a></td></tr>
<tr class="memdesc:lq-m_Parent"><td class="mdescLeft">&#160;</td><td class="mdescRight">a pointer to its parent <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> object, the Parserthread class has two place to communicate with <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> class.  <a href="#lq-m_Parent">More...</a><br /></td></tr>
<tr class="separator:lq-m_Parent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:x5-m_TokenTree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a></td></tr>
<tr class="memdesc:x5-m_TokenTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">a pointer to the token tree, all the tokens will be added to that tree structure  <a href="#x5-m_TokenTree">More...</a><br /></td></tr>
<tr class="separator:x5-m_TokenTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dn-m_LastParent"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classToken">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a></td></tr>
<tr class="memdesc:dn-m_LastParent"><td class="mdescLeft">&#160;</td><td class="mdescRight">parent <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a>, for example, when you are parsing in the class member variables, m_LastParent holds a pointer to the current context, which is a token holding class name  <a href="#dn-m_LastParent">More...</a><br /></td></tr>
<tr class="separator:dn-m_LastParent"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rj-m_LastScope"><td class="memItemLeft" align="right" valign="top"><a class="el" href="token_8h#bs-TokenScope">TokenScope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#rj-m_LastScope">m_LastScope</a></td></tr>
<tr class="memdesc:rj-m_LastScope"><td class="mdescLeft">&#160;</td><td class="mdescRight">this member define the scope type of member variables, which is: public, private protected or undefined  <a href="#rj-m_LastScope">More...</a><br /></td></tr>
<tr class="separator:rj-m_LastScope"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ql-m_Filename"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#ql-m_Filename">m_Filename</a></td></tr>
<tr class="memdesc:ql-m_Filename"><td class="mdescLeft">&#160;</td><td class="mdescRight">the file name of the parsing source  <a href="#ql-m_Filename">More...</a><br /></td></tr>
<tr class="separator:ql-m_Filename"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gi-m_FileSize"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#gi-m_FileSize">m_FileSize</a></td></tr>
<tr class="memdesc:gi-m_FileSize"><td class="mdescLeft">&#160;</td><td class="mdescRight">file size, actually the length of the wxString  <a href="#gi-m_FileSize">More...</a><br /></td></tr>
<tr class="separator:gi-m_FileSize"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ak-m_FileIdx"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#ak-m_FileIdx">m_FileIdx</a></td></tr>
<tr class="memdesc:ak-m_FileIdx"><td class="mdescLeft">&#160;</td><td class="mdescRight">source file index on the "file map tree"  <a href="#ak-m_FileIdx">More...</a><br /></td></tr>
<tr class="separator:ak-m_FileIdx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gx-m_IsLocal"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#gx-m_IsLocal">m_IsLocal</a></td></tr>
<tr class="memdesc:gx-m_IsLocal"><td class="mdescLeft">&#160;</td><td class="mdescRight">if true, means we are parsing a file which belongs to a C::B project, otherwise, we are parsing a file not belong to a C::B project(such as a system header file)  <a href="#gx-m_IsLocal">More...</a><br /></td></tr>
<tr class="separator:gx-m_IsLocal"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:x2-m_Str"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#x2-m_Str">m_Str</a></td></tr>
<tr class="memdesc:x2-m_Str"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a very important member variables! It serves as a type stack, eg: parsing the statement: "int wxString const varA;" we determine 'varA' is a token variable, until we searching to the last semicolon.  <a href="#x2-m_Str">More...</a><br /></td></tr>
<tr class="separator:x2-m_Str"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:kb-m_LastToken"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#kb-m_LastToken">m_LastToken</a></td></tr>
<tr class="memdesc:kb-m_LastToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">hold the previous token string  <a href="#kb-m_LastToken">More...</a><br /></td></tr>
<tr class="separator:kb-m_LastToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:wi-m_Options"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structParserThreadOptions">ParserThreadOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#wi-m_Options">m_Options</a></td></tr>
<tr class="memdesc:wi-m_Options"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser options, see the <a class="el" href="structParserThreadOptions">ParserThreadOptions</a> structure  <a href="#wi-m_Options">More...</a><br /></td></tr>
<tr class="separator:wi-m_Options"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ge-m_EncounteredNamespaces"><td class="memItemLeft" align="right" valign="top">std::queue&lt; wxString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#ge-m_EncounteredNamespaces">m_EncounteredNamespaces</a></td></tr>
<tr class="memdesc:ge-m_EncounteredNamespaces"><td class="mdescLeft">&#160;</td><td class="mdescRight">for member funcs implementation or a function declaration below eg: int ClassA::FunctionB(); EncounteredNamespaces is 'ClassA'  <a href="#ge-m_EncounteredNamespaces">More...</a><br /></td></tr>
<tr class="separator:ge-m_EncounteredNamespaces"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gg-m_EncounteredTypeNamespaces"><td class="memItemLeft" align="right" valign="top">std::queue&lt; wxString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#gg-m_EncounteredTypeNamespaces">m_EncounteredTypeNamespaces</a></td></tr>
<tr class="memdesc:gg-m_EncounteredTypeNamespaces"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespaces in function return types for a function declaration below: e.g.  <a href="#gg-m_EncounteredTypeNamespaces">More...</a><br /></td></tr>
<tr class="separator:gg-m_EncounteredTypeNamespaces"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aw-m_UsedNamespacesIds"><td class="memItemLeft" align="right" valign="top"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#aw-m_UsedNamespacesIds">m_UsedNamespacesIds</a></td></tr>
<tr class="memdesc:aw-m_UsedNamespacesIds"><td class="mdescLeft">&#160;</td><td class="mdescRight">globally included namespaces by "using namespace" statement  <a href="#aw-m_UsedNamespacesIds">More...</a><br /></td></tr>
<tr class="separator:aw-m_UsedNamespacesIds"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vq-m_LastUnnamedTokenName"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#vq-m_LastUnnamedTokenName">m_LastUnnamedTokenName</a></td></tr>
<tr class="memdesc:vq-m_LastUnnamedTokenName"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: describe me here.  <a href="#vq-m_LastUnnamedTokenName">More...</a><br /></td></tr>
<tr class="separator:vq-m_LastUnnamedTokenName"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qh-m_ParsingTypedef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#qh-m_ParsingTypedef">m_ParsingTypedef</a></td></tr>
<tr class="memdesc:qh-m_ParsingTypedef"><td class="mdescLeft">&#160;</td><td class="mdescRight">this makes a difference in unnamed class/struct/enum handling  <a href="#qh-m_ParsingTypedef">More...</a><br /></td></tr>
<tr class="separator:qh-m_ParsingTypedef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:wm-m_IsBuffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#wm-m_IsBuffer">m_IsBuffer</a></td></tr>
<tr class="memdesc:wm-m_IsBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">local file or buffer in memory  <a href="#wm-m_IsBuffer">More...</a><br /></td></tr>
<tr class="separator:wm-m_IsBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:xe-m_Buffer"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#xe-m_Buffer">m_Buffer</a></td></tr>
<tr class="memdesc:xe-m_Buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">a wxString holding the parsing buffer  <a href="#xe-m_Buffer">More...</a><br /></td></tr>
<tr class="separator:xe-m_Buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ng-m_PointerOrRef"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#ng-m_PointerOrRef">m_PointerOrRef</a></td></tr>
<tr class="memdesc:ng-m_PointerOrRef"><td class="mdescLeft">&#160;</td><td class="mdescRight">a pointer indicator or a references  <a href="#ng-m_PointerOrRef">More...</a><br /></td></tr>
<tr class="separator:ng-m_PointerOrRef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ly-m_TemplateArgument"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#ly-m_TemplateArgument">m_TemplateArgument</a></td></tr>
<tr class="memdesc:ly-m_TemplateArgument"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds current template argument(s) when a template occurs  <a href="#ly-m_TemplateArgument">More...</a><br /></td></tr>
<tr class="separator:ly-m_TemplateArgument"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ha-m_StructUnionUnnamedCount"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#ha-m_StructUnionUnnamedCount">m_StructUnionUnnamedCount</a></td></tr>
<tr class="separator:ha-m_StructUnionUnnamedCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8-m_EnumUnnamedCount"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParserThread#a8-m_EnumUnnamedCount">m_EnumUnnamedCount</a></td></tr>
<tr class="separator:a8-m_EnumUnnamedCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A parser threaded task, which can be assigned to the thread task pool, and run there. </p>
<p>This class represents a worker threaded task for the Code Completion plug-in, the main task is doing the syntax analysis and add every token to the token tree. The <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> tree (sometimes, we call it <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a> ) is a Patricia tree structure, more details can be seen in <a class="el" href="token_8h">token.h</a> and <a class="el" href="token_8cpp">token.cpp</a>. The buffer can either be loaded from a local file or directly used of a wxString. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="w8-EClassType"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParserThread#w8-EClassType">ParserThread::EClassType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>specify which "class like type" we are handling: struct or class or union </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="w8-EClassType:ctStructure"></a>ctStructure&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="w8-EClassType:ctClass"></a>ctClass&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="w8-EClassType:ctUnion"></a>ctUnion&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="kb-ParserThread"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParserThread::ParserThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParserBase">ParserBase</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>bufferOrFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLocal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParserThreadOptions">ParserThreadOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>parserThreadOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tokenTree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> object which contain the token tree. </td></tr>
    <tr><td class="paramname">bufferOrFilename</td><td>it's either the filename to open or a wxString buffer already in memory. </td></tr>
    <tr><td class="paramname">isLocal</td><td>determine whether this is a file locally belong to a cbp or in other global paths. </td></tr>
    <tr><td class="paramname">parserThreadOptions</td><td>parser thread options, see <a class="el" href="structParserThreadOptions">ParserThreadOptions</a> Class for details. </td></tr>
    <tr><td class="paramname">tokenTree</td><td>it is the tree structure holding all the tokens, <a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a> will add every token when it parsed. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="cbexception_8h#g4-cbThrow">cbThrow</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#uv-SetTokenizerOption">Tokenizer::SetTokenizerOption()</a>, <a class="el" href="structParserThreadOptions#x0-storeDocumentation">ParserThreadOptions::storeDocumentation</a>, and <a class="el" href="structParserThreadOptions#ju-wantPreprocessor">ParserThreadOptions::wantPreprocessor</a>.</p>

</div>
</div>
<a class="anchor" id="js-ParserThread"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParserThread::~ParserThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classParserThread" title="A parser threaded task, which can be assigned to the thread task pool, and run there. ">ParserThread</a> destructor. </p>

<p>References <a class="el" href="structParserThreadOptions#li-loader">ParserThreadOptions::loader</a>, <a class="el" href="classParserThread#wi-m_Options">m_Options</a>, and <a class="el" href="classLoaderBase#yt-Sync">LoaderBase::Sync()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="nq-CalcEnumExpression"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::CalcEnumExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>tokenParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>peek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate the value assigned to enumerator </p>

<p>References <a class="el" href="classExpression#do-AddToInfixExpression">Expression::AddToInfixExpression()</a>, <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classExpression#k0-CalcPostfix">Expression::CalcPostfix()</a>, <a class="el" href="namespaceParserConsts#a0-clbrace">ParserConsts::clbrace()</a>, <a class="el" href="classExpression#hb-Clear">Expression::Clear()</a>, <a class="el" href="namespaceParserConsts#wa-comma">ParserConsts::comma()</a>, <a class="el" href="namespaceParserConsts#wa-commaclbrace">ParserConsts::commaclbrace()</a>, <a class="el" href="classExpression#nc-ConvertInfixToPostfix">Expression::ConvertInfixToPostfix()</a>, <a class="el" href="namespaceParserConsts#rc-dcolon">ParserConsts::dcolon()</a>, <a class="el" href="classExpression#hy-GetResult">Expression::GetResult()</a>, <a class="el" href="classTokenizer#kr-GetState">Tokenizer::GetState()</a>, <a class="el" href="classExpression#ef-GetStatus">Expression::GetStatus()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classToken#wh-m_Args">Token::m_Args</a>, <a class="el" href="classToken#z1-m_FullType">Token::m_FullType</a>, <a class="el" href="classToken#zl-m_Index">Token::m_Index</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">Tokenizer::ReplaceBufferText()</a>, <a class="el" href="classTokenizer#v8-ReplaceMacroUsage">Tokenizer::ReplaceMacroUsage()</a>, <a class="el" href="classTokenizer#no-SetState">Tokenizer::SetState()</a>, <a class="el" href="classParserThread#zh-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="token_8h#uj-TokenKind:tkEnumerator">tkEnumerator</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsReadRawExpression">tsReadRawExpression</a>, <a class="el" href="namespaceParserConsts#zu-underscore_chr">ParserConsts::underscore_chr()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">Tokenizer::UngetToken()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>.</p>

</div>
</div>
<a class="anchor" id="hd-DoAddToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken">Token</a> * ParserThread::DoAddToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="token_8h#uj-TokenKind">TokenKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>implLineStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>implLineEnd</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>args</em> = <code>wxEmptyString</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isOperator</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isImpl</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add one token to the token tree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kind</td><td><a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> type, see  Emun for more details </td></tr>
    <tr><td class="paramname">name</td><td><a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> name, this is the key string to be searched in the token tree </td></tr>
    <tr><td class="paramname">line</td><td>line number of the source file where the current <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> locates </td></tr>
    <tr><td class="paramname">implLineStart</td><td>if this is a function implementation, it is the start of function body </td></tr>
    <tr><td class="paramname">implLineEnd</td><td>like the one above, it is the end line of the function implementation body </td></tr>
    <tr><td class="paramname">args</td><td>if the token type is a function, this is the function arguments </td></tr>
    <tr><td class="paramname">isOperator</td><td>bool variable to determine an operator override function or not </td></tr>
    <tr><td class="paramname">isTmpl</td><td>bool variable to determine it is a function declaration or implementation </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classToken#ta-AddChild">Token::AddChild()</a>, <a class="el" href="parserthread_8cpp#mr-ADDTOKEN">ADDTOKEN</a>, <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="namespaceParserConsts#rc-dcolon">ParserConsts::dcolon()</a>, <a class="el" href="classParserThread#fp-FindTokenFromQueue">FindTokenFromQueue()</a>, <a class="el" href="classParserThread#zj-GetBaseArgs">GetBaseArgs()</a>, <a class="el" href="classParserThread#rj-GetTokenBaseType">GetTokenBaseType()</a>, <a class="el" href="classToken#x7-GetTokenKindString">Token::GetTokenKindString()</a>, <a class="el" href="classTokenTree#fq-insert">TokenTree::insert()</a>, <a class="el" href="classTokenTree#gj-InsertTokenBelongToFile">TokenTree::InsertTokenBelongToFile()</a>, <a class="el" href="structParserThreadOptions#s3-isTemp">ParserThreadOptions::isTemp</a>, <a class="el" href="classToken#wh-m_Args">Token::m_Args</a>, <a class="el" href="classToken#pf-m_BaseArgs">Token::m_BaseArgs</a>, <a class="el" href="classToken#bs-m_BaseType">Token::m_BaseType</a>, <a class="el" href="classParserThread#ge-m_EncounteredNamespaces">m_EncounteredNamespaces</a>, <a class="el" href="classParserThread#gg-m_EncounteredTypeNamespaces">m_EncounteredTypeNamespaces</a>, <a class="el" href="classToken#ss-m_FileIdx">Token::m_FileIdx</a>, <a class="el" href="classParserThread#ak-m_FileIdx">m_FileIdx</a>, <a class="el" href="classToken#z1-m_FullType">Token::m_FullType</a>, <a class="el" href="classToken#ot-m_ImplFileIdx">Token::m_ImplFileIdx</a>, <a class="el" href="classToken#ur-m_ImplLine">Token::m_ImplLine</a>, <a class="el" href="classToken#tv-m_ImplLineEnd">Token::m_ImplLineEnd</a>, <a class="el" href="classToken#b7-m_ImplLineStart">Token::m_ImplLineStart</a>, <a class="el" href="classToken#zl-m_Index">Token::m_Index</a>, <a class="el" href="classToken#dy-m_IsLocal">Token::m_IsLocal</a>, <a class="el" href="classParserThread#gx-m_IsLocal">m_IsLocal</a>, <a class="el" href="classToken#df-m_IsOperator">Token::m_IsOperator</a>, <a class="el" href="classToken#tj-m_IsTemp">Token::m_IsTemp</a>, <a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a>, <a class="el" href="classParserThread#rj-m_LastScope">m_LastScope</a>, <a class="el" href="classToken#qp-m_Line">Token::m_Line</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classParserThread#wi-m_Options">m_Options</a>, <a class="el" href="classToken#wc-m_ParentIndex">Token::m_ParentIndex</a>, <a class="el" href="classParserThread#ng-m_PointerOrRef">m_PointerOrRef</a>, <a class="el" href="classToken#d0-m_Scope">Token::m_Scope</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classToken#nh-m_TemplateArgument">Token::m_TemplateArgument</a>, <a class="el" href="classParserThread#ly-m_TemplateArgument">m_TemplateArgument</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="classTokenTree#tm-m_TokenTicketCount">TokenTree::m_TokenTicketCount</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="structParserThreadOptions#ud-parentIdxOfBuffer">ParserThreadOptions::parentIdxOfBuffer</a>, <a class="el" href="classTokenizer#d7-SetLastTokenIdx">Tokenizer::SetLastTokenIdx()</a>, <a class="el" href="namespaceParserConsts#qb-space_chr">ParserConsts::space_chr()</a>, <a class="el" href="namespaceParserConsts#sg-tilde">ParserConsts::tilde()</a>, <a class="el" href="token_8h#uj-TokenKind:tkAnyContainer">tkAnyContainer</a>, <a class="el" href="token_8h#uj-TokenKind:tkAnyFunction">tkAnyFunction</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkConstructor">tkConstructor</a>, <a class="el" href="token_8h#uj-TokenKind:tkDestructor">tkDestructor</a>, <a class="el" href="token_8h#uj-TokenKind:tkVariable">tkVariable</a>, <a class="el" href="classParserThread#mq-TokenExists">TokenExists()</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">HandleConditionalArguments()</a>, <a class="el" href="classParserThread#tp-HandleDefines">HandleDefines()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">HandleNamespace()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ReadClsNames()</a>, and <a class="el" href="classParserThread#p3-ReadVarNames">ReadVarNames()</a>.</p>

</div>
</div>
<a class="anchor" id="tn-DoParse"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::DoParse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>actually run the syntax analysis </p>

<p>References <a class="el" href="structParserThreadOptions#m7-bufferSkipBlocks">ParserThreadOptions::bufferSkipBlocks</a>, <a class="el" href="namespaceParserConsts#tv-clbrace_chr">ParserConsts::clbrace_chr()</a>, <a class="el" href="namespaceParserConsts#ox-colon">ParserConsts::colon()</a>, <a class="el" href="namespaceParserConsts#qo-colon_chr">ParserConsts::colon_chr()</a>, <a class="el" href="namespaceParserConsts#wa-comma">ParserConsts::comma()</a>, <a class="el" href="namespaceParserConsts#m3-comma_chr">ParserConsts::comma_chr()</a>, <a class="el" href="classParserThread#w8-EClassType:ctClass">ctClass</a>, <a class="el" href="classParserThread#w8-EClassType:ctStructure">ctStructure</a>, <a class="el" href="classParserThread#w8-EClassType:ctUnion">ctUnion</a>, <a class="el" href="namespaceParserConsts#z7-dash">ParserConsts::dash()</a>, <a class="el" href="namespaceParserConsts#g5-dash_chr">ParserConsts::dash_chr()</a>, <a class="el" href="namespaceParserConsts#rc-dcolon">ParserConsts::dcolon()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="namespaceParserConsts#cz-dot_chr">ParserConsts::dot_chr()</a>, <a class="el" href="classParserThread#fp-FindTokenFromQueue">FindTokenFromQueue()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classTokenizer#kr-GetState">Tokenizer::GetState()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">GetTemplateArgs()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="namespaceParserConsts#c6-gt_chr">ParserConsts::gt_chr()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="structParserThreadOptions#wj-handleClasses">ParserThreadOptions::handleClasses</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">HandleConditionalArguments()</a>, <a class="el" href="classParserThread#tp-HandleDefines">HandleDefines()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="structParserThreadOptions#kx-handleEnums">ParserThreadOptions::handleEnums</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, <a class="el" href="structParserThreadOptions#wc-handleFunctions">ParserThreadOptions::handleFunctions</a>, <a class="el" href="classParserThread#ky-HandleIncludes">HandleIncludes()</a>, <a class="el" href="classParserThread#sa-HandleMacroExpansion">HandleMacroExpansion()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">HandleNamespace()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>, <a class="el" href="structParserThreadOptions#g9-handleTypedefs">ParserThreadOptions::handleTypedefs</a>, <a class="el" href="classParserThread#sn-HandleUndefs">HandleUndefs()</a>, <a class="el" href="structParserThreadOptions#np-handleVars">ParserThreadOptions::handleVars</a>, <a class="el" href="namespaceParserConsts#vx-hash_chr">ParserConsts::hash_chr()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="namespaceParserConsts#ht-kw___asm">ParserConsts::kw___asm()</a>, <a class="el" href="namespaceParserConsts#wi-kw___at">ParserConsts::kw___at()</a>, <a class="el" href="namespaceParserConsts#wh-kw__C_">ParserConsts::kw__C_()</a>, <a class="el" href="namespaceParserConsts#e0-kw__CPP_">ParserConsts::kw__CPP_()</a>, <a class="el" href="namespaceParserConsts#js-kw_attribute">ParserConsts::kw_attribute()</a>, <a class="el" href="namespaceParserConsts#do-kw_case">ParserConsts::kw_case()</a>, <a class="el" href="namespaceParserConsts#wd-kw_catch">ParserConsts::kw_catch()</a>, <a class="el" href="namespaceParserConsts#aq-kw_class">ParserConsts::kw_class()</a>, <a class="el" href="namespaceParserConsts#nd-kw_const">ParserConsts::kw_const()</a>, <a class="el" href="namespaceParserConsts#yl-kw_declspec">ParserConsts::kw_declspec()</a>, <a class="el" href="namespaceParserConsts#r5-kw_define">ParserConsts::kw_define()</a>, <a class="el" href="namespaceParserConsts#vp-kw_delete">ParserConsts::kw_delete()</a>, <a class="el" href="namespaceParserConsts#j4-kw_do">ParserConsts::kw_do()</a>, <a class="el" href="namespaceParserConsts#z8-kw_else">ParserConsts::kw_else()</a>, <a class="el" href="namespaceParserConsts#hw-kw_enum">ParserConsts::kw_enum()</a>, <a class="el" href="namespaceParserConsts#rh-kw_extern">ParserConsts::kw_extern()</a>, <a class="el" href="namespaceParserConsts#i0-kw_for">ParserConsts::kw_for()</a>, <a class="el" href="namespaceParserConsts#ry-kw_friend">ParserConsts::kw_friend()</a>, <a class="el" href="namespaceParserConsts#zd-kw_if">ParserConsts::kw_if()</a>, <a class="el" href="namespaceParserConsts#ii-kw_include">ParserConsts::kw_include()</a>, <a class="el" href="namespaceParserConsts#js-kw_inline">ParserConsts::kw_inline()</a>, <a class="el" href="namespaceParserConsts#hz-kw_namespace">ParserConsts::kw_namespace()</a>, <a class="el" href="namespaceParserConsts#hb-kw_noexcept">ParserConsts::kw_noexcept()</a>, <a class="el" href="namespaceParserConsts#da-kw_operator">ParserConsts::kw_operator()</a>, <a class="el" href="namespaceParserConsts#is-kw_private">ParserConsts::kw_private()</a>, <a class="el" href="namespaceParserConsts#pn-kw_protected">ParserConsts::kw_protected()</a>, <a class="el" href="namespaceParserConsts#xr-kw_public">ParserConsts::kw_public()</a>, <a class="el" href="namespaceParserConsts#tn-kw_return">ParserConsts::kw_return()</a>, <a class="el" href="namespaceParserConsts#uc-kw_static">ParserConsts::kw_static()</a>, <a class="el" href="namespaceParserConsts#hi-kw_struct">ParserConsts::kw_struct()</a>, <a class="el" href="namespaceParserConsts#lx-kw_switch">ParserConsts::kw_switch()</a>, <a class="el" href="namespaceParserConsts#z6-kw_template">ParserConsts::kw_template()</a>, <a class="el" href="namespaceParserConsts#fp-kw_typedef">ParserConsts::kw_typedef()</a>, <a class="el" href="namespaceParserConsts#zu-kw_undef">ParserConsts::kw_undef()</a>, <a class="el" href="namespaceParserConsts#an-kw_union">ParserConsts::kw_union()</a>, <a class="el" href="namespaceParserConsts#ss-kw_using">ParserConsts::kw_using()</a>, <a class="el" href="namespaceParserConsts#qo-kw_virtual">ParserConsts::kw_virtual()</a>, <a class="el" href="namespaceParserConsts#ou-kw_volatile">ParserConsts::kw_volatile()</a>, <a class="el" href="namespaceParserConsts#ci-kw_while">ParserConsts::kw_while()</a>, <a class="el" href="namespaceParserConsts#ko-lt">ParserConsts::lt()</a>, <a class="el" href="classToken#nz-m_AncestorsString">Token::m_AncestorsString</a>, <a class="el" href="classParserThread#ge-m_EncounteredNamespaces">m_EncounteredNamespaces</a>, <a class="el" href="classParserThread#gg-m_EncounteredTypeNamespaces">m_EncounteredTypeNamespaces</a>, <a class="el" href="classToken#zl-m_Index">Token::m_Index</a>, <a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a>, <a class="el" href="classParserThread#rj-m_LastScope">m_LastScope</a>, <a class="el" href="classParserThread#kb-m_LastToken">m_LastToken</a>, <a class="el" href="classParserThread#vq-m_LastUnnamedTokenName">m_LastUnnamedTokenName</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classParserThread#wi-m_Options">m_Options</a>, <a class="el" href="classParserThread#ng-m_PointerOrRef">m_PointerOrRef</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classParserThread#ly-m_TemplateArgument">m_TemplateArgument</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="classParserThread#aw-m_UsedNamespacesIds">m_UsedNamespacesIds</a>, <a class="el" href="classTokenizer#c2-NotEOF">Tokenizer::NotEOF()</a>, <a class="el" href="namespaceParserConsts#md-opbrace">ParserConsts::opbrace()</a>, <a class="el" href="namespaceParserConsts#r3-opbrace_chr">ParserConsts::opbrace_chr()</a>, <a class="el" href="namespaceParserConsts#mc-opbracket_chr">ParserConsts::opbracket_chr()</a>, <a class="el" href="classTokenizer#pm-PeekToken">Tokenizer::PeekToken()</a>, <a class="el" href="namespaceParserConsts#r9-plus_chr">ParserConsts::plus_chr()</a>, <a class="el" href="namespaceParserConsts#eu-ptr">ParserConsts::ptr()</a>, <a class="el" href="namespaceParserConsts#jp-ptr_chr">ParserConsts::ptr_chr()</a>, <a class="el" href="classParserThread#vw-ResolveTemplateArgs">ResolveTemplateArgs()</a>, <a class="el" href="namespaceParserConsts#nf-semicolon">ParserConsts::semicolon()</a>, <a class="el" href="namespaceParserConsts#n9-semicolon_chr">ParserConsts::semicolon_chr()</a>, <a class="el" href="namespaceParserConsts#uq-semicolonclbrace">ParserConsts::semicolonclbrace()</a>, <a class="el" href="classTokenizer#no-SetState">Tokenizer::SetState()</a>, <a class="el" href="classParserThread#pl-SkipAngleBraces">SkipAngleBraces()</a>, <a class="el" href="classParserThread#ru-SkipBlock">SkipBlock()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">Tokenizer::SkipToEOL()</a>, <a class="el" href="classParserThread#zh-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="namespaceParserConsts#qb-space_chr">ParserConsts::space_chr()</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, <a class="el" href="token_8h#uj-TokenKind:tkNamespace">tkNamespace</a>, <a class="el" href="token_8h#uj-TokenKind:tkVariable">tkVariable</a>, <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>, <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>, <a class="el" href="token_8h#bs-TokenScope:tsPrivate">tsPrivate</a>, <a class="el" href="token_8h#bs-TokenScope:tsProtected">tsProtected</a>, <a class="el" href="token_8h#bs-TokenScope:tsPublic">tsPublic</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipNone">tsSkipNone</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipUnWanted">tsSkipUnWanted</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsTemplateArgument">tsTemplateArgument</a>, <a class="el" href="token_8h#bs-TokenScope:tsUndefined">tsUndefined</a>, <a class="el" href="namespaceParserConsts#zu-underscore_chr">ParserConsts::underscore_chr()</a>, <a class="el" href="classTokenizer#jv-UngetToken">Tokenizer::UngetToken()</a>, and <a class="el" href="structParserThreadOptions#du-useBuffer">ParserThreadOptions::useBuffer</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">HandleNamespace()</a>, and <a class="el" href="classParserThread#te-Parse">Parse()</a>.</p>

</div>
</div>
<a class="anchor" id="bv-Execute"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ParserThread::Execute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classParserThread#bv-Execute" title="Execute() is a virtual function derived from cbThreadedTask class, we should override it here...">Execute()</a> is a virtual function derived from <a class="el" href="classcbThreadedTask" title="This is what you have to use instead of wxThread to add tasks to the Thread Pool. ...">cbThreadedTask</a> class, we should override it here. </p>
<p>In the batch parsing mode, a lot of parser threads were generated and executed concurrently, this often happens when user open a project. Every parserthread task will firstly be added to the thread pool, later called automatically from the thread pool. </p>

<p>Implements <a class="el" href="classcbThreadedTask#q2-Execute">cbThreadedTask</a>.</p>

<p>References <a class="el" href="cclogger_8h#ap-CC_LOCKER_TRACK_TT_MTX_LOCK">CC_LOCKER_TRACK_TT_MTX_LOCK</a>, <a class="el" href="cclogger_8h#al-CC_LOCKER_TRACK_TT_MTX_UNLOCK">CC_LOCKER_TRACK_TT_MTX_UNLOCK</a>, <a class="el" href="classParserThread#te-Parse">Parse()</a>, and <a class="el" href="tokentree_8cpp#ko-s_TokenTreeMutex">s_TokenTreeMutex</a>.</p>

</div>
</div>
<a class="anchor" id="fp-FindTokenFromQueue"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken">Token</a> * ParserThread::FindTokenFromQueue </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; wxString &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createIfNotExist</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>parentIfCreated</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO comment here? </p>

<p>References <a class="el" href="classToken#ta-AddChild">Token::AddChild()</a>, <a class="el" href="classTokenTree#fq-insert">TokenTree::insert()</a>, <a class="el" href="classParserThread#ak-m_FileIdx">m_FileIdx</a>, <a class="el" href="classToken#zl-m_Index">Token::m_Index</a>, <a class="el" href="classToken#dy-m_IsLocal">Token::m_IsLocal</a>, <a class="el" href="classParserThread#gx-m_IsLocal">m_IsLocal</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classToken#wc-m_ParentIndex">Token::m_ParentIndex</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="classTokenTree#tm-m_TokenTicketCount">TokenTree::m_TokenTicketCount</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkNamespace">tkNamespace</a>, <a class="el" href="classParserThread#mq-TokenExists">TokenExists()</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, and <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>.</p>

</div>
</div>
<a class="anchor" id="zj-GetBaseArgs"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::GetBaseArgs </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>baseArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a full argument list (including variable names) to argument types only and strips spaces. </p>
<p>eg: if the argument list is like "(const TheClass* the_class, int my_int)" then, the returned argument list is "(const TheClass*,int)" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Full argument list </td></tr>
    <tr><td class="paramname">baseArgs</td><td>argument types only </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if failed, will return false, so, it must be a variable </dd></dl>

<p>References <a class="el" href="namespaceParserConsts#jl-clarray_chr">ParserConsts::clarray_chr()</a>, <a class="el" href="namespaceParserConsts#xv-clbracket_chr">ParserConsts::clbracket_chr()</a>, <a class="el" href="namespaceParserConsts#qo-colon_chr">ParserConsts::colon_chr()</a>, <a class="el" href="namespaceParserConsts#m3-comma_chr">ParserConsts::comma_chr()</a>, <a class="el" href="namespaceParserConsts#f6-eol_chr">ParserConsts::eol_chr()</a>, <a class="el" href="namespaceParserConsts#c6-gt_chr">ParserConsts::gt_chr()</a>, <a class="el" href="namespaceParserConsts#nd-kw_const">ParserConsts::kw_const()</a>, <a class="el" href="namespaceParserConsts#hw-kw_enum">ParserConsts::kw_enum()</a>, <a class="el" href="namespaceParserConsts#ou-kw_volatile">ParserConsts::kw_volatile()</a>, <a class="el" href="namespaceParserConsts#pj-lt_chr">ParserConsts::lt_chr()</a>, <a class="el" href="namespaceParserConsts#jm-null">ParserConsts::null()</a>, <a class="el" href="namespaceParserConsts#bj-oparray_chr">ParserConsts::oparray_chr()</a>, <a class="el" href="namespaceParserConsts#mc-opbracket_chr">ParserConsts::opbracket_chr()</a>, <a class="el" href="namespaceParserConsts#eu-ptr">ParserConsts::ptr()</a>, <a class="el" href="namespaceParserConsts#jp-ptr_chr">ParserConsts::ptr_chr()</a>, <a class="el" href="namespaceParserConsts#kc-ref_chr">ParserConsts::ref_chr()</a>, <a class="el" href="namespaceParserConsts#qb-space_chr">ParserConsts::space_chr()</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>.</p>

</div>
</div>
<a class="anchor" id="vz-GetClassFromMacro"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString ParserThread::GetClassFromMacro </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>macro</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the class name from a macro. </p>

<p>References <a class="el" href="classParserThread#hy-GetRealTypeIfTokenIsMacro">GetRealTypeIfTokenIsMacro()</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="classParserThread#mq-TokenExists">TokenExists()</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>.</p>

</div>
</div>
<a class="anchor" id="zz-GetFilename"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString ParserThread::GetFilename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classParserThread#xe-m_Buffer">m_Buffer</a>.</p>

</div>
</div>
<a class="anchor" id="hy-GetRealTypeIfTokenIsMacro"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::GetRealTypeIfTokenIsMacro </td>
          <td>(</td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>tokenName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the macro's type, if the token is a macro, and saved the type in tokenName. </p>

<p>References <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classToken#z1-m_FullType">Token::m_FullType</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, <a class="el" href="classParserThread#mq-TokenExists">TokenExists()</a>, <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>, and <a class="el" href="namespaceParserConsts#zu-underscore_chr">ParserConsts::underscore_chr()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#vz-GetClassFromMacro">GetClassFromMacro()</a>, and <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>.</p>

</div>
</div>
<a class="anchor" id="xu-GetTemplateArgArray"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxArrayString ParserThread::GetTemplateArgArray </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>templateArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_gt_lt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normally the template argument is all in a wxString, this function just split them to a wxArrayString, each element is an actual argument. </p>

<p>References <a class="el" href="namespaceParserConsts#m3-comma_chr">ParserConsts::comma_chr()</a>, <a class="el" href="namespaceParserConsts#c6-gt_chr">ParserConsts::gt_chr()</a>, <a class="el" href="namespaceParserConsts#pj-lt_chr">ParserConsts::lt_chr()</a>, and <a class="el" href="namespaceParserConsts#qb-space_chr">ParserConsts::space_chr()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#mr-SplitTemplateActualParameters">SplitTemplateActualParameters()</a>, and <a class="el" href="classParserThread#y3-SplitTemplateFormalParameters">SplitTemplateFormalParameters()</a>.</p>

</div>
</div>
<a class="anchor" id="zx-GetTemplateArgs"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::GetTemplateArgs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the &lt;xxxx=yyy, zzz&gt; , and store the value in m_TemplateArgs. </p>

<p>References <a class="el" href="classTokenizer#kr-GetState">Tokenizer::GetState()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="namespaceParserConsts#vf-gt">ParserConsts::gt()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="namespaceParserConsts#ko-lt">ParserConsts::lt()</a>, <a class="el" href="classParserThread#ly-m_TemplateArgument">m_TemplateArgument</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="namespaceParserConsts#nf-semicolon">ParserConsts::semicolon()</a>, <a class="el" href="classTokenizer#no-SetState">Tokenizer::SetState()</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipNone">tsSkipNone</a>, and <a class="el" href="classTokenizer#jv-UngetToken">Tokenizer::UngetToken()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, and <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>.</p>

</div>
</div>
<a class="anchor" id="rj-GetTokenBaseType"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString ParserThread::GetTokenBaseType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the actual token's base type. </p>
<p>e.g.: if the token type string is: "const wxString &amp;" then, the actual token base type is : "wxString" </p>

<p>References <a class="el" href="namespaceParserConsts#qo-colon_chr">ParserConsts::colon_chr()</a>, <a class="el" href="namespaceParserConsts#nd-kw_const">ParserConsts::kw_const()</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="namespaceParserConsts#jp-ptr_chr">ParserConsts::ptr_chr()</a>, <a class="el" href="namespaceParserConsts#kc-ref_chr">ParserConsts::ref_chr()</a>, <a class="el" href="namespaceParserConsts#qb-space_chr">ParserConsts::space_chr()</a>, <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>, and <a class="el" href="namespaceParserConsts#zu-underscore_chr">ParserConsts::underscore_chr()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>.</p>

</div>
</div>
<a class="anchor" id="s3-HandleClass"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::HandleClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParserThread#w8-EClassType">EClassType</a>&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle class declaration </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>specify class like type : struct or enum or class </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceParserConsts#ox-colon">ParserConsts::colon()</a>, <a class="el" href="namespaceParserConsts#wa-comma">ParserConsts::comma()</a>, <a class="el" href="namespaceParserConsts#m3-comma_chr">ParserConsts::comma_chr()</a>, <a class="el" href="classParserThread#w8-EClassType:ctClass">ctClass</a>, <a class="el" href="classParserThread#w8-EClassType:ctUnion">ctUnion</a>, <a class="el" href="namespaceParserConsts#rc-dcolon">ParserConsts::dcolon()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="parserthread_8cpp#v6-g_UnnamedSymbol">g_UnnamedSymbol</a>, <a class="el" href="classParserThread#vz-GetClassFromMacro">GetClassFromMacro()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classParserThread#hy-GetRealTypeIfTokenIsMacro">GetRealTypeIfTokenIsMacro()</a>, <a class="el" href="classTokenizer#kr-GetState">Tokenizer::GetState()</a>, <a class="el" href="globals_8h#n5-GetStringFromArray">GetStringFromArray()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">GetTemplateArgs()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="namespaceParserConsts#vf-gt">ParserConsts::gt()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, <a class="el" href="structParserThreadOptions#np-handleVars">ParserThreadOptions::handleVars</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="namespaceParserConsts#js-kw_attribute">ParserConsts::kw_attribute()</a>, <a class="el" href="namespaceParserConsts#yl-kw_declspec">ParserConsts::kw_declspec()</a>, <a class="el" href="namespaceParserConsts#is-kw_private">ParserConsts::kw_private()</a>, <a class="el" href="namespaceParserConsts#pn-kw_protected">ParserConsts::kw_protected()</a>, <a class="el" href="namespaceParserConsts#xr-kw_public">ParserConsts::kw_public()</a>, <a class="el" href="namespaceParserConsts#ko-lt">ParserConsts::lt()</a>, <a class="el" href="classToken#nz-m_AncestorsString">Token::m_AncestorsString</a>, <a class="el" href="classParserThread#ak-m_FileIdx">m_FileIdx</a>, <a class="el" href="classToken#ur-m_ImplLine">Token::m_ImplLine</a>, <a class="el" href="classToken#tv-m_ImplLineEnd">Token::m_ImplLineEnd</a>, <a class="el" href="classToken#b7-m_ImplLineStart">Token::m_ImplLineStart</a>, <a class="el" href="classToken#no-m_IsAnonymous">Token::m_IsAnonymous</a>, <a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a>, <a class="el" href="classParserThread#rj-m_LastScope">m_LastScope</a>, <a class="el" href="classParserThread#vq-m_LastUnnamedTokenName">m_LastUnnamedTokenName</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classParserThread#wi-m_Options">m_Options</a>, <a class="el" href="classParserThread#qh-m_ParsingTypedef">m_ParsingTypedef</a>, <a class="el" href="classParserThread#ng-m_PointerOrRef">m_PointerOrRef</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classParserThread#ha-m_StructUnionUnnamedCount">m_StructUnionUnnamedCount</a>, <a class="el" href="classToken#nh-m_TemplateArgument">Token::m_TemplateArgument</a>, <a class="el" href="classParserThread#ly-m_TemplateArgument">m_TemplateArgument</a>, <a class="el" href="classToken#te-m_TemplateType">Token::m_TemplateType</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="namespaceParserConsts#md-opbrace">ParserConsts::opbrace()</a>, <a class="el" href="namespaceParserConsts#mc-opbracket_chr">ParserConsts::opbracket_chr()</a>, <a class="el" href="classTokenizer#pm-PeekToken">Tokenizer::PeekToken()</a>, <a class="el" href="namespaceParserConsts#jp-ptr_chr">ParserConsts::ptr_chr()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ReadClsNames()</a>, <a class="el" href="classParserThread#p3-ReadVarNames">ReadVarNames()</a>, <a class="el" href="namespaceParserConsts#kc-ref_chr">ParserConsts::ref_chr()</a>, <a class="el" href="namespaceParserConsts#nf-semicolon">ParserConsts::semicolon()</a>, <a class="el" href="classTokenizer#no-SetState">Tokenizer::SetState()</a>, <a class="el" href="classParserThread#pl-SkipAngleBraces">SkipAngleBraces()</a>, <a class="el" href="namespaceParserConsts#p0-space">ParserConsts::space()</a>, <a class="el" href="namespaceParserConsts#qb-space_chr">ParserConsts::space_chr()</a>, <a class="el" href="classParserThread#y3-SplitTemplateFormalParameters">SplitTemplateFormalParameters()</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkVariable">tkVariable</a>, <a class="el" href="classParserThread#mq-TokenExists">TokenExists()</a>, <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>, <a class="el" href="token_8h#bs-TokenScope:tsPrivate">tsPrivate</a>, <a class="el" href="token_8h#bs-TokenScope:tsPublic">tsPublic</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipUnWanted">tsSkipUnWanted</a>, and <a class="el" href="classTokenizer#jv-UngetToken">Tokenizer::UngetToken()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, and <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>.</p>

</div>
</div>
<a class="anchor" id="w4-HandleConditionalArguments"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::HandleConditionalArguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parse arguments like: if(int X = getNumber()) </p>

<p>References <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classTokenizer#rn-GetFilename">Tokenizer::GetFilename()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">Tokenizer::InitFromBuffer()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classParserThread#ng-m_PointerOrRef">m_PointerOrRef</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classParserThread#ly-m_TemplateArgument">m_TemplateArgument</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classTokenizer#pm-PeekToken">Tokenizer::PeekToken()</a>, <a class="el" href="namespaceParserConsts#jp-ptr_chr">ParserConsts::ptr_chr()</a>, <a class="el" href="namespaceParserConsts#kc-ref_chr">ParserConsts::ref_chr()</a>, <a class="el" href="classParserThread#a8-RemoveTemplateArgs">RemoveTemplateArgs()</a>, <a class="el" href="classParserThread#vw-ResolveTemplateArgs">ResolveTemplateArgs()</a>, <a class="el" href="token_8h#uj-TokenKind:tkVariable">tkVariable</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>.</p>

</div>
</div>
<a class="anchor" id="tp-HandleDefines"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::HandleDefines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle the statement: #define XXXXX </p>

<p>References <a class="el" href="namespaceParserConsts#xv-clbracket_chr">ParserConsts::clbracket_chr()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classTokenizer#kr-GetState">Tokenizer::GetState()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="namespaceParserConsts#mc-opbracket_chr">ParserConsts::opbracket_chr()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">Tokenizer::ReadToEOL()</a>, <a class="el" href="classTokenizer#no-SetState">Tokenizer::SetState()</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsReadRawExpression">tsReadRawExpression</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>.</p>

</div>
</div>
<a class="anchor" id="gm-HandleEnum"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::HandleEnum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle enum declaration </p>

<p>References <a class="el" href="classParserThread#nq-CalcEnumExpression">CalcEnumExpression()</a>, <a class="el" href="namespaceParserConsts#a0-clbrace">ParserConsts::clbrace()</a>, <a class="el" href="namespaceParserConsts#ox-colon">ParserConsts::colon()</a>, <a class="el" href="namespaceParserConsts#wa-comma">ParserConsts::comma()</a>, <a class="el" href="namespaceParserConsts#wa-commaclbrace">ParserConsts::commaclbrace()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="namespaceParserConsts#vm-equals">ParserConsts::equals()</a>, <a class="el" href="parserthread_8cpp#v6-g_UnnamedSymbol">g_UnnamedSymbol</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classTokenizer#el-GetNestingLevel">Tokenizer::GetNestingLevel()</a>, <a class="el" href="classTokenizer#kr-GetState">Tokenizer::GetState()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="structParserThreadOptions#kx-handleEnums">ParserThreadOptions::handleEnums</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="namespaceParserConsts#aq-kw_class">ParserConsts::kw_class()</a>, <a class="el" href="classParserThread#a8-m_EnumUnnamedCount">m_EnumUnnamedCount</a>, <a class="el" href="classParserThread#ak-m_FileIdx">m_FileIdx</a>, <a class="el" href="classToken#ur-m_ImplLine">Token::m_ImplLine</a>, <a class="el" href="classToken#tv-m_ImplLineEnd">Token::m_ImplLineEnd</a>, <a class="el" href="classToken#b7-m_ImplLineStart">Token::m_ImplLineStart</a>, <a class="el" href="classToken#no-m_IsAnonymous">Token::m_IsAnonymous</a>, <a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a>, <a class="el" href="classParserThread#vq-m_LastUnnamedTokenName">m_LastUnnamedTokenName</a>, <a class="el" href="classParserThread#wi-m_Options">m_Options</a>, <a class="el" href="classParserThread#qh-m_ParsingTypedef">m_ParsingTypedef</a>, <a class="el" href="classToken#d0-m_Scope">Token::m_Scope</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="namespaceParserConsts#md-opbrace">ParserConsts::opbrace()</a>, <a class="el" href="namespaceParserConsts#r3-opbrace_chr">ParserConsts::opbrace_chr()</a>, <a class="el" href="classTokenizer#pm-PeekToken">Tokenizer::PeekToken()</a>, <a class="el" href="namespaceParserConsts#nf-semicolon">ParserConsts::semicolon()</a>, <a class="el" href="classTokenizer#no-SetState">Tokenizer::SetState()</a>, <a class="el" href="classParserThread#zh-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="token_8h#uj-TokenKind:tkEnum">tkEnum</a>, <a class="el" href="token_8h#uj-TokenKind:tkEnumerator">tkEnumerator</a>, <a class="el" href="token_8h#uj-TokenKind:tkVariable">tkVariable</a>, <a class="el" href="classParserThread#mq-TokenExists">TokenExists()</a>, <a class="el" href="token_8h#bs-TokenScope:tsPrivate">tsPrivate</a>, <a class="el" href="token_8h#bs-TokenScope:tsPublic">tsPublic</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipNone">tsSkipNone</a>, <a class="el" href="namespaceParserConsts#zu-underscore_chr">ParserConsts::underscore_chr()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">Tokenizer::UngetToken()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, and <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>.</p>

</div>
</div>
<a class="anchor" id="l5-HandleForLoopArguments"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::HandleForLoopArguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parse for loop arguments: for(int X; ... </p>
<p>; ...) </p>

<p>References <a class="el" href="namespaceParserConsts#ox-colon">ParserConsts::colon()</a>, <a class="el" href="namespaceParserConsts#wa-comma">ParserConsts::comma()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classTokenizer#rn-GetFilename">Tokenizer::GetFilename()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">Tokenizer::InitFromBuffer()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classParserThread#ng-m_PointerOrRef">m_PointerOrRef</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classParserThread#ly-m_TemplateArgument">m_TemplateArgument</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classTokenizer#pm-PeekToken">Tokenizer::PeekToken()</a>, <a class="el" href="namespaceParserConsts#jp-ptr_chr">ParserConsts::ptr_chr()</a>, <a class="el" href="namespaceParserConsts#kc-ref_chr">ParserConsts::ref_chr()</a>, <a class="el" href="classParserThread#a8-RemoveTemplateArgs">RemoveTemplateArgs()</a>, <a class="el" href="classParserThread#vw-ResolveTemplateArgs">ResolveTemplateArgs()</a>, <a class="el" href="namespaceParserConsts#nf-semicolon">ParserConsts::semicolon()</a>, <a class="el" href="token_8h#uj-TokenKind:tkVariable">tkVariable</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>.</p>

</div>
</div>
<a class="anchor" id="oq-HandleFunction"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::HandleFunction </td>
          <td>(</td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isOperator</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPointer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle function declaration or definition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>function name </td></tr>
    <tr><td class="paramname">isOperator</td><td>if true, means it is an operator overload function </td></tr>
    <tr><td class="paramname">isPointer</td><td>if true, means it is a function pointer </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceParserConsts#a0-clbrace">ParserConsts::clbrace()</a>, <a class="el" href="namespaceParserConsts#ox-colon">ParserConsts::colon()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#fp-FindTokenFromQueue">FindTokenFromQueue()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="namespaceParserConsts#wd-kw_catch">ParserConsts::kw_catch()</a>, <a class="el" href="namespaceParserConsts#nd-kw_const">ParserConsts::kw_const()</a>, <a class="el" href="namespaceParserConsts#ry-kw_friend">ParserConsts::kw_friend()</a>, <a class="el" href="namespaceParserConsts#hb-kw_noexcept">ParserConsts::kw_noexcept()</a>, <a class="el" href="namespaceParserConsts#lc-kw_throw">ParserConsts::kw_throw()</a>, <a class="el" href="namespaceParserConsts#mk-kw_try">ParserConsts::kw_try()</a>, <a class="el" href="classParserThread#ge-m_EncounteredNamespaces">m_EncounteredNamespaces</a>, <a class="el" href="classParserThread#gg-m_EncounteredTypeNamespaces">m_EncounteredTypeNamespaces</a>, <a class="el" href="classParserThread#ql-m_Filename">m_Filename</a>, <a class="el" href="classToken#sk-m_IsConst">Token::m_IsConst</a>, <a class="el" href="classToken#ht-m_IsNoExcept">Token::m_IsNoExcept</a>, <a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classParserThread#wi-m_Options">m_Options</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classToken#nh-m_TemplateArgument">Token::m_TemplateArgument</a>, <a class="el" href="classParserThread#ly-m_TemplateArgument">m_TemplateArgument</a>, <a class="el" href="classToken#he-m_TemplateMap">Token::m_TemplateMap</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="namespaceParserConsts#bj-oparray_chr">ParserConsts::oparray_chr()</a>, <a class="el" href="namespaceParserConsts#md-opbrace">ParserConsts::opbrace()</a>, <a class="el" href="classTokenizer#pm-PeekToken">Tokenizer::PeekToken()</a>, <a class="el" href="namespaceParserConsts#eu-ptr">ParserConsts::ptr()</a>, <a class="el" href="classParserThread#vw-ResolveTemplateArgs">ResolveTemplateArgs()</a>, <a class="el" href="namespaceParserConsts#nf-semicolon">ParserConsts::semicolon()</a>, <a class="el" href="classParserThread#ru-SkipBlock">SkipBlock()</a>, <a class="el" href="classParserThread#zh-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="namespaceParserConsts#sg-tilde">ParserConsts::tilde()</a>, <a class="el" href="token_8h#uj-TokenKind:tkConstructor">tkConstructor</a>, <a class="el" href="token_8h#uj-TokenKind:tkDestructor">tkDestructor</a>, <a class="el" href="token_8h#uj-TokenKind:tkFunction">tkFunction</a>, <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>, <a class="el" href="classTokenizer#jv-UngetToken">Tokenizer::UngetToken()</a>, and <a class="el" href="structParserThreadOptions#du-useBuffer">ParserThreadOptions::useBuffer</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, and <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>.</p>

</div>
</div>
<a class="anchor" id="ky-HandleIncludes"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::HandleIncludes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle include &lt;XXXX&gt; or include "XXXX" directive. </p>
<p>This will internally add another parserThead object associate with the included file to parserthread pool </p>

<p>References <a class="el" href="namespaceParserCommon#fo-FileType">ParserCommon::FileType()</a>, <a class="el" href="structParserThreadOptions#k0-followGlobalIncludes">ParserThreadOptions::followGlobalIncludes</a>, <a class="el" href="structParserThreadOptions#zu-followLocalIncludes">ParserThreadOptions::followLocalIncludes</a>, <a class="el" href="namespaceParserCommon#pu-EFileType:ftOther">ParserCommon::ftOther</a>, <a class="el" href="classParserBase#je-GetFullFileName">ParserBase::GetFullFileName()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="namespaceParserConsts#c6-gt_chr">ParserConsts::gt_chr()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classTokenTree#vv-IsFileParsed">TokenTree::IsFileParsed()</a>, <a class="el" href="namespaceParserConsts#pj-lt_chr">ParserConsts::lt_chr()</a>, <a class="el" href="classParserThread#ql-m_Filename">m_Filename</a>, <a class="el" href="classParserThread#gx-m_IsLocal">m_IsLocal</a>, <a class="el" href="classParserThread#wi-m_Options">m_Options</a>, <a class="el" href="classParserThread#lq-m_Parent">m_Parent</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="classParserBase#o7-ParseFile">ParserBase::ParseFile()</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>.</p>

</div>
</div>
<a class="anchor" id="sa-HandleMacroExpansion"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::HandleMacroExpansion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>peek</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We guess this is a macro usage, so try to expand macro. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>token id in <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> tree </td></tr>
    <tr><td class="paramname">peek</td><td>macro actual arguments </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classParserThread#wi-m_Options">m_Options</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="structParserThreadOptions#y8-parseComplexMacros">ParserThreadOptions::parseComplexMacros</a>, and <a class="el" href="classTokenizer#v8-ReplaceMacroUsage">Tokenizer::ReplaceMacroUsage()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>.</p>

</div>
</div>
<a class="anchor" id="bg-HandleNamespace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::HandleNamespace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle the statement: namespace XXX { </p>

<p>References <a class="el" href="namespaceParserConsts#rc-dcolon">ParserConsts::dcolon()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="namespaceParserConsts#vm-equals">ParserConsts::equals()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classToken#kh-m_Aliases">Token::m_Aliases</a>, <a class="el" href="classParserThread#ak-m_FileIdx">m_FileIdx</a>, <a class="el" href="classToken#z1-m_FullType">Token::m_FullType</a>, <a class="el" href="classToken#ot-m_ImplFileIdx">Token::m_ImplFileIdx</a>, <a class="el" href="classToken#ur-m_ImplLine">Token::m_ImplLine</a>, <a class="el" href="classToken#tv-m_ImplLineEnd">Token::m_ImplLineEnd</a>, <a class="el" href="classToken#b7-m_ImplLineStart">Token::m_ImplLineStart</a>, <a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a>, <a class="el" href="classParserThread#rj-m_LastScope">m_LastScope</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="prefix_8cpp#t6-NULL">NULL</a>, <a class="el" href="namespaceParserConsts#md-opbrace">ParserConsts::opbrace()</a>, <a class="el" href="classTokenizer#pm-PeekToken">Tokenizer::PeekToken()</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">Tokenizer::ReplaceBufferText()</a>, <a class="el" href="namespaceParserConsts#jk-semicolonopbrace">ParserConsts::semicolonopbrace()</a>, <a class="el" href="classTokenizer#no-SetState">Tokenizer::SetState()</a>, <a class="el" href="classParserThread#zh-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, <a class="el" href="token_8h#uj-TokenKind:tkNamespace">tkNamespace</a>, <a class="el" href="classParserThread#mq-TokenExists">TokenExists()</a>, <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>, <a class="el" href="token_8h#bs-TokenScope:tsPublic">tsPublic</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipNone">tsSkipNone</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipUnWanted">tsSkipUnWanted</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>.</p>

</div>
</div>
<a class="anchor" id="pm-HandleTypedef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::HandleTypedef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle typedef directive </p>

<p>References <a class="el" href="namespaceParserConsts#xv-clbracket_chr">ParserConsts::clbracket_chr()</a>, <a class="el" href="namespaceParserConsts#wa-comma">ParserConsts::comma()</a>, <a class="el" href="classParserThread#w8-EClassType:ctClass">ctClass</a>, <a class="el" href="classParserThread#w8-EClassType:ctStructure">ctStructure</a>, <a class="el" href="classParserThread#w8-EClassType:ctUnion">ctUnion</a>, <a class="el" href="namespaceParserConsts#rc-dcolon">ParserConsts::dcolon()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">GetTemplateArgs()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="namespaceParserConsts#aq-kw_class">ParserConsts::kw_class()</a>, <a class="el" href="namespaceParserConsts#nd-kw_const">ParserConsts::kw_const()</a>, <a class="el" href="namespaceParserConsts#hw-kw_enum">ParserConsts::kw_enum()</a>, <a class="el" href="namespaceParserConsts#hi-kw_struct">ParserConsts::kw_struct()</a>, <a class="el" href="namespaceParserConsts#an-kw_union">ParserConsts::kw_union()</a>, <a class="el" href="namespaceParserConsts#ko-lt">ParserConsts::lt()</a>, <a class="el" href="namespaceParserConsts#pj-lt_chr">ParserConsts::lt_chr()</a>, <a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a>, <a class="el" href="classParserThread#vq-m_LastUnnamedTokenName">m_LastUnnamedTokenName</a>, <a class="el" href="classParserThread#qh-m_ParsingTypedef">m_ParsingTypedef</a>, <a class="el" href="classParserThread#ng-m_PointerOrRef">m_PointerOrRef</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classParserThread#ly-m_TemplateArgument">m_TemplateArgument</a>, <a class="el" href="classToken#te-m_TemplateType">Token::m_TemplateType</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="namespaceParserConsts#mc-opbracket_chr">ParserConsts::opbracket_chr()</a>, <a class="el" href="classTokenizer#pm-PeekToken">Tokenizer::PeekToken()</a>, <a class="el" href="namespaceParserConsts#eu-ptr">ParserConsts::ptr()</a>, <a class="el" href="namespaceParserConsts#jp-ptr_chr">ParserConsts::ptr_chr()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ReadClsNames()</a>, <a class="el" href="namespaceParserConsts#rs-ref">ParserConsts::ref()</a>, <a class="el" href="classParserThread#vw-ResolveTemplateArgs">ResolveTemplateArgs()</a>, <a class="el" href="namespaceParserConsts#nf-semicolon">ParserConsts::semicolon()</a>, <a class="el" href="namespaceParserConsts#qb-space_chr">ParserConsts::space_chr()</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkTypedef">tkTypedef</a>, <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>, <a class="el" href="classToken#ue-Trim">Token::Trim()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">Tokenizer::UngetToken()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>.</p>

</div>
</div>
<a class="anchor" id="sn-HandleUndefs"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::HandleUndefs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle the statement: #undef XXXXX </p>

<p>References <a class="el" href="classTokenTree#ud-erase">TokenTree::erase()</a>, <a class="el" href="classTokenizer#kr-GetState">Tokenizer::GetState()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#no-SetState">Tokenizer::SetState()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">Tokenizer::SkipToEOL()</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, <a class="el" href="classParserThread#mq-TokenExists">TokenExists()</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsReadRawExpression">tsReadRawExpression</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>.</p>

</div>
</div>
<a class="anchor" id="fc-InitTokenizer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::InitTokenizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize the m_Buffer, load from local file or use a buffer in memory </p>

<p>References <a class="el" href="safedelete_8h#cr-Delete">Delete()</a>, <a class="el" href="structParserThreadOptions#pm-fileOfBuffer">ParserThreadOptions::fileOfBuffer</a>, <a class="el" href="classTokenizer#zq-Init">Tokenizer::Init()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">Tokenizer::InitFromBuffer()</a>, <a class="el" href="structParserThreadOptions#ui-initLineOfBuffer">ParserThreadOptions::initLineOfBuffer</a>, <a class="el" href="classTokenTree#h8-InsertFileOrGetIndex">TokenTree::InsertFileOrGetIndex()</a>, <a class="el" href="structParserThreadOptions#li-loader">ParserThreadOptions::loader</a>, <a class="el" href="classParserThread#xe-m_Buffer">m_Buffer</a>, <a class="el" href="classParserThread#ak-m_FileIdx">m_FileIdx</a>, <a class="el" href="classParserThread#ql-m_Filename">m_Filename</a>, <a class="el" href="classParserThread#gi-m_FileSize">m_FileSize</a>, <a class="el" href="classParserThread#wm-m_IsBuffer">m_IsBuffer</a>, <a class="el" href="classParserThread#wi-m_Options">m_Options</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#te-Parse">Parse()</a>.</p>

</div>
</div>
<a class="anchor" id="jq-IsStillAlive"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::IsStillAlive </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>funcInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only for debug. </p>

<p>References <a class="el" href="classcbThreadedTask#tp-TestDestroy">cbThreadedTask::TestDestroy()</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

</div>
</div>
<a class="anchor" id="te-Parse"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::Parse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do the main job (syntax analysis) here. </p>

<p>References <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classTokenTree#jg-FlagFileAsParsed">TokenTree::FlagFileAsParsed()</a>, <a class="el" href="classParserThread#fc-InitTokenizer">InitTokenizer()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classTokenizer#f2-IsOK">Tokenizer::IsOK()</a>, <a class="el" href="classParserThread#ak-m_FileIdx">m_FileIdx</a>, <a class="el" href="classParserThread#ql-m_Filename">m_Filename</a>, <a class="el" href="classParserThread#wi-m_Options">m_Options</a>, <a class="el" href="classParserThread#qh-m_ParsingTypedef">m_ParsingTypedef</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenTree#na-ReserveFileForParsing">TokenTree::ReserveFileForParsing()</a>, <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>, and <a class="el" href="structParserThreadOptions#du-useBuffer">ParserThreadOptions::useBuffer</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#bv-Execute">Execute()</a>, <a class="el" href="classParser#o1-Parse">Parser::Parse()</a>, <a class="el" href="classParserBase#kd-ParseBuffer">ParserBase::ParseBuffer()</a>, <a class="el" href="classParser#or-ParseBuffer">Parser::ParseBuffer()</a>, <a class="el" href="classParser#nz-ParseBufferForFunctions">Parser::ParseBufferForFunctions()</a>, and <a class="el" href="classParserBase#bz-Reparse">ParserBase::Reparse()</a>.</p>

</div>
</div>
<a class="anchor" id="i9-ParseBufferForNamespaces"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::ParseBufferForNamespaces </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parserthread_8h#ia-NameSpaceVec">NameSpaceVec</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the context "namespace XXX { ... }" directive. </p>
<p>It is used to find the initial search scope before CC prompt a suggestion list. Need a critical section locker before call this function! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>wxString to be parsed. </td></tr>
    <tr><td class="paramname">result</td><td>vector containing all the namespace names. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceParserConsts#a0-clbrace">ParserConsts::clbrace()</a>, <a class="el" href="namespaceParserConsts#rc-dcolon">ParserConsts::dcolon()</a>, <a class="el" href="parserthread_8h#uv-EndLine">NameSpace::EndLine</a>, <a class="el" href="namespaceParserConsts#vm-equals">ParserConsts::equals()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">Tokenizer::InitFromBuffer()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classTokenizer#f2-IsOK">Tokenizer::IsOK()</a>, <a class="el" href="namespaceParserConsts#hz-kw_namespace">ParserConsts::kw_namespace()</a>, <a class="el" href="namespaceParserConsts#ss-kw_using">ParserConsts::kw_using()</a>, <a class="el" href="classParserThread#qh-m_ParsingTypedef">m_ParsingTypedef</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="parserthread_8h#sf-Name">NameSpace::Name</a>, <a class="el" href="classTokenizer#c2-NotEOF">Tokenizer::NotEOF()</a>, <a class="el" href="namespaceParserConsts#md-opbrace">ParserConsts::opbrace()</a>, <a class="el" href="classTokenizer#pm-PeekToken">Tokenizer::PeekToken()</a>, <a class="el" href="namespaceParserConsts#uq-semicolonclbrace">ParserConsts::semicolonclbrace()</a>, <a class="el" href="classTokenizer#no-SetState">Tokenizer::SetState()</a>, <a class="el" href="classParserThread#ru-SkipBlock">SkipBlock()</a>, <a class="el" href="classParserThread#zh-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="parserthread_8h#qs-StartLine">NameSpace::StartLine</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipNone">tsSkipNone</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipUnWanted">tsSkipUnWanted</a>.</p>

<p>Referenced by <a class="el" href="classParser#jn-ParseBufferForNamespaces">Parser::ParseBufferForNamespaces()</a>.</p>

</div>
</div>
<a class="anchor" id="cc-ParseBufferForUsingNamespace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::ParseBufferForUsingNamespace </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxArrayString &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the context "using namespace XXX" directive. </p>
<p>It is used to find the initial search scope before CC prompt a suggestion list. Need a critical section locker before call this function! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>wxString to be parsed. </td></tr>
    <tr><td class="paramname">result</td><td>the wxArrayString contains all the namespace names. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structParserThreadOptions#m7-bufferSkipBlocks">ParserThreadOptions::bufferSkipBlocks</a>, <a class="el" href="namespaceParserConsts#rc-dcolon">ParserConsts::dcolon()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">Tokenizer::InitFromBuffer()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classTokenizer#f2-IsOK">Tokenizer::IsOK()</a>, <a class="el" href="namespaceParserConsts#hz-kw_namespace">ParserConsts::kw_namespace()</a>, <a class="el" href="namespaceParserConsts#ss-kw_using">ParserConsts::kw_using()</a>, <a class="el" href="classParserThread#ge-m_EncounteredNamespaces">m_EncounteredNamespaces</a>, <a class="el" href="classParserThread#gg-m_EncounteredTypeNamespaces">m_EncounteredTypeNamespaces</a>, <a class="el" href="classParserThread#vq-m_LastUnnamedTokenName">m_LastUnnamedTokenName</a>, <a class="el" href="classParserThread#wi-m_Options">m_Options</a>, <a class="el" href="classParserThread#qh-m_ParsingTypedef">m_ParsingTypedef</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classTokenizer#c2-NotEOF">Tokenizer::NotEOF()</a>, <a class="el" href="namespaceParserConsts#md-opbrace">ParserConsts::opbrace()</a>, <a class="el" href="classTokenizer#pm-PeekToken">Tokenizer::PeekToken()</a>, <a class="el" href="namespaceParserConsts#uq-semicolonclbrace">ParserConsts::semicolonclbrace()</a>, <a class="el" href="classParserThread#ru-SkipBlock">SkipBlock()</a>, and <a class="el" href="classParserThread#zh-SkipToOneOfChars">SkipToOneOfChars()</a>.</p>

<p>Referenced by <a class="el" href="classParser#u4-ParseBufferForUsingNamespace">Parser::ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="dy-ReadClsNames"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::ReadClsNames </td>
          <td>(</td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>ancestor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle class names, e.g., the code below typedef class AAA{ int m_a; int m_b; } BBB,CCC; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ancestor</td><td>class name = "AAA" this function reads the following "BBB" and "CCC", and regard them as derived classes of "AAA" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if token was handled, false, if an unexpected token was read. </dd></dl>

<p>References <a class="el" href="namespaceParserConsts#wa-comma">ParserConsts::comma()</a>, <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="logmanager_8h#ug-F">F()</a>, <a class="el" href="parserthread_8cpp#v6-g_UnnamedSymbol">g_UnnamedSymbol</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, <a class="el" href="classTokenizer#rn-GetFilename">Tokenizer::GetFilename()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classToken#nz-m_AncestorsString">Token::m_AncestorsString</a>, <a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classParserThread#ng-m_PointerOrRef">m_PointerOrRef</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="namespaceParserConsts#eu-ptr">ParserConsts::ptr()</a>, <a class="el" href="classParserThread#gl-RefineAnonymousTypeToken">RefineAnonymousTypeToken()</a>, <a class="el" href="namespaceParserConsts#nf-semicolon">ParserConsts::semicolon()</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, <a class="el" href="token_8h#uj-TokenKind:tkTypedef">tkTypedef</a>, <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>, <a class="el" href="namespaceParserConsts#zu-underscore_chr">ParserConsts::underscore_chr()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">Tokenizer::UngetToken()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, and <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>.</p>

</div>
</div>
<a class="anchor" id="p3-ReadVarNames"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::ReadVarNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>eg: class ClassA{...} varA, varB, varC This function will read the "varA, varB, varC" </p>
<dl class="section return"><dt>Returns</dt><dd>True, if token was handled, false, if an unexpected token was read. </dd></dl>

<p>References <a class="el" href="namespaceParserConsts#wa-comma">ParserConsts::comma()</a>, <a class="el" href="classCCLogger#ux-DebugLog">CCLogger::DebugLog()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="logmanager_8h#ug-F">F()</a>, <a class="el" href="parserthread_8cpp#v6-g_UnnamedSymbol">g_UnnamedSymbol</a>, <a class="el" href="classCCLogger#ma-Get">CCLogger::Get()</a>, <a class="el" href="classTokenizer#rn-GetFilename">Tokenizer::GetFilename()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">Tokenizer::GetLineNumber()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classParserThread#ng-m_PointerOrRef">m_PointerOrRef</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="namespaceParserConsts#eu-ptr">ParserConsts::ptr()</a>, <a class="el" href="classParserThread#gl-RefineAnonymousTypeToken">RefineAnonymousTypeToken()</a>, <a class="el" href="namespaceParserConsts#nf-semicolon">ParserConsts::semicolon()</a>, <a class="el" href="token_8h#uj-TokenKind:tkUndefined">tkUndefined</a>, <a class="el" href="token_8h#uj-TokenKind:tkVariable">tkVariable</a>, <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>, and <a class="el" href="namespaceParserConsts#zu-underscore_chr">ParserConsts::underscore_chr()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>.</p>

</div>
</div>
<a class="anchor" id="gl-RefineAnonymousTypeToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::RefineAnonymousTypeToken </td>
          <td>(</td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>typeMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxString&#160;</td>
          <td class="paramname"><em>alise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change an anonymous(unnamed) token's name to a human readable name, the m_Str is expect to store the unnamed token name, for example, for parsing the code struct { int x; float y; } abc; when we first find an anonymous token, which is named _UnnamedStruct1_2, after this function call, the anonymous token name will becomes struct1_abc, and m_Str will changed from _UnnamedStruct1_2 to struct1_abc. </p>

<p>References <a class="el" href="classParserThread#ak-m_FileIdx">m_FileIdx</a>, <a class="el" href="classToken#no-m_IsAnonymous">Token::m_IsAnonymous</a>, <a class="el" href="classParserThread#dn-m_LastParent">m_LastParent</a>, <a class="el" href="classParserThread#x2-m_Str">m_Str</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenTree#it-RenameToken">TokenTree::RenameToken()</a>, and <a class="el" href="classParserThread#mq-TokenExists">TokenExists()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#dy-ReadClsNames">ReadClsNames()</a>, and <a class="el" href="classParserThread#p3-ReadVarNames">ReadVarNames()</a>.</p>

</div>
</div>
<a class="anchor" id="a8-RemoveTemplateArgs"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::RemoveTemplateArgs </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>expNoArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>templateArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove template arguments from an expression example: 'std::list&lt;string&gt;' will be separated into 'std::list' and '&lt;string&gt;' </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Complete expression with template arguments </td></tr>
    <tr><td class="paramname">expNoArgs</td><td>Returned expression without template arguments </td></tr>
    <tr><td class="paramname">templateArgs</td><td>The removed template arguments </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceParserConsts#vf-gt">ParserConsts::gt()</a>, <a class="el" href="namespaceParserConsts#c6-gt_chr">ParserConsts::gt_chr()</a>, <a class="el" href="namespaceParserConsts#ko-lt">ParserConsts::lt()</a>, <a class="el" href="namespaceParserConsts#pj-lt_chr">ParserConsts::lt_chr()</a>, and <a class="el" href="namespaceParserConsts#p0-space">ParserConsts::space()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#w4-HandleConditionalArguments">HandleConditionalArguments()</a>, and <a class="el" href="classParserThread#l5-HandleForLoopArguments">HandleForLoopArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="vw-ResolveTemplateArgs"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::ResolveTemplateArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>newToken</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function just associate the formal template argument to actual argument For example, we have such code: template &lt;typename t&gt;=""&gt; class AAA { T m_aaa;}; AAA&lt;int&gt; bbb; When handling the "bbb", we need to construct a TemplateMap, we store the map in the "bbb"'s member variable, which is "T"-&gt;"int". </p>

<p>References <a class="el" href="classToken#z1-m_FullType">Token::m_FullType</a>, <a class="el" href="classToken#nh-m_TemplateArgument">Token::m_TemplateArgument</a>, <a class="el" href="classParserThread#ly-m_TemplateArgument">m_TemplateArgument</a>, <a class="el" href="classToken#he-m_TemplateMap">Token::m_TemplateMap</a>, <a class="el" href="classToken#te-m_TemplateType">Token::m_TemplateType</a>, <a class="el" href="classParserThread#rd-ResolveTemplateMap">ResolveTemplateMap()</a>, <a class="el" href="classParserThread#mr-SplitTemplateActualParameters">SplitTemplateActualParameters()</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">HandleConditionalArguments()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, and <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>.</p>

</div>
</div>
<a class="anchor" id="rd-ResolveTemplateMap"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::ResolveTemplateMap </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>typeStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxArrayString &amp;&#160;</td>
          <td class="paramname"><em>actuals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; wxString, wxString &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>associate formal argument with actual template argument </p>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classTokenTree#tb-FindMatches">TokenTree::FindMatches()</a>, <a class="el" href="classToken#te-m_TemplateType">Token::m_TemplateType</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="token_8h#uj-TokenKind:tkClass">tkClass</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#vw-ResolveTemplateArgs">ResolveTemplateArgs()</a>.</p>

</div>
</div>
<a class="anchor" id="pl-SkipAngleBraces"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::SkipAngleBraces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>skip the template argument </p>

<p>References <a class="el" href="classTokenizer#kr-GetState">Tokenizer::GetState()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="namespaceParserConsts#vf-gt">ParserConsts::gt()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="namespaceParserConsts#ko-lt">ParserConsts::lt()</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="namespaceParserConsts#nf-semicolon">ParserConsts::semicolon()</a>, <a class="el" href="classTokenizer#no-SetState">Tokenizer::SetState()</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipNone">tsSkipNone</a>, and <a class="el" href="classTokenizer#jv-UngetToken">Tokenizer::UngetToken()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, and <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>.</p>

</div>
</div>
<a class="anchor" id="ru-SkipBlock"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::SkipBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>skip blocks () [] {} &lt;&gt; </p>

<p>References <a class="el" href="classTokenizer#el-GetNestingLevel">Tokenizer::GetNestingLevel()</a>, <a class="el" href="classTokenizer#kr-GetState">Tokenizer::GetState()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, <a class="el" href="classTokenizer#no-SetState">Tokenizer::SetState()</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipNone">tsSkipNone</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParseBufferForNamespaces()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="zh-SkipToOneOfChars"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxChar ParserThread::SkipToOneOfChars </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>supportNesting</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>singleCharToken</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Continuously eat the tokens until we meet one of the matching characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>wxString includes all the matching characters </td></tr>
    <tr><td class="paramname">supportNesting</td><td>if true, we need to consider the "{" and "}" nesting levels when skipping, </td></tr>
    <tr><td class="paramname">singleCharToken</td><td>if true, only single char tokens (like semicolon, brace etc.) are considered (speeds up parsing for queries like this) in this case, the function returned on a match by nesting/brace level preserved. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#el-GetNestingLevel">Tokenizer::GetNestingLevel()</a>, <a class="el" href="classTokenizer#p4-GetToken">Tokenizer::GetToken()</a>, <a class="el" href="parserthread_8cpp#vg-IS_ALIVE">IS_ALIVE</a>, <a class="el" href="classParserThread#xs-m_Tokenizer">m_Tokenizer</a>, and <a class="el" href="namespaceParserConsts#jm-null">ParserConsts::null()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">CalcEnumExpression()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">HandleNamespace()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParseBufferForNamespaces()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="mr-SplitTemplateActualParameters"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::SplitTemplateActualParameters </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>templateArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxArrayString &amp;&#160;</td>
          <td class="paramname"><em>actuals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split actual template argument list. </p>

<p>References <a class="el" href="namespaceParserConsts#wa-comma">ParserConsts::comma()</a>, <a class="el" href="classParserThread#xu-GetTemplateArgArray">GetTemplateArgArray()</a>, <a class="el" href="namespaceParserConsts#vf-gt">ParserConsts::gt()</a>, <a class="el" href="namespaceParserConsts#ko-lt">ParserConsts::lt()</a>, and <a class="el" href="parserthread_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#vw-ResolveTemplateArgs">ResolveTemplateArgs()</a>.</p>

</div>
</div>
<a class="anchor" id="y3-SplitTemplateFormalParameters"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserThread::SplitTemplateFormalParameters </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>templateArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxArrayString &amp;&#160;</td>
          <td class="paramname"><em>formals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split formal template argument list. </p>

<p>References <a class="el" href="classParserThread#xu-GetTemplateArgArray">GetTemplateArgArray()</a>, <a class="el" href="namespaceParserConsts#aq-kw_class">ParserConsts::kw_class()</a>, and <a class="el" href="namespaceParserConsts#up-kw_typename">ParserConsts::kw_typename()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>.</p>

</div>
</div>
<a class="anchor" id="mq-TokenExists"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken">Token</a> * ParserThread::TokenExists </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>kindMask</em> = <code>0xFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if parent is 0, then global namespace will be used, all tokens under parent scope are searched </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the search key string </td></tr>
    <tr><td class="paramname">parent</td><td>parent token pointer, we only search under the parent token scope </td></tr>
    <tr><td class="paramname">kindMask</td><td>filter for the result token, only the specified type of tokens were matched </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classToken#zl-m_Index">Token::m_Index</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="classParserThread#aw-m_UsedNamespacesIds">m_UsedNamespacesIds</a>, and <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#fp-FindTokenFromQueue">FindTokenFromQueue()</a>, <a class="el" href="classParserThread#vz-GetClassFromMacro">GetClassFromMacro()</a>, <a class="el" href="classParserThread#hy-GetRealTypeIfTokenIsMacro">GetRealTypeIfTokenIsMacro()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">HandleNamespace()</a>, <a class="el" href="classParserThread#sn-HandleUndefs">HandleUndefs()</a>, and <a class="el" href="classParserThread#gl-RefineAnonymousTypeToken">RefineAnonymousTypeToken()</a>.</p>

</div>
</div>
<a class="anchor" id="rw-TokenExists"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken">Token</a> * ParserThread::TokenExists </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>baseArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="token_8h#uj-TokenKind">TokenKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Support function overloading. </p>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classToken#zl-m_Index">Token::m_Index</a>, <a class="el" href="classParserThread#x5-m_TokenTree">m_TokenTree</a>, <a class="el" href="classParserThread#aw-m_UsedNamespacesIds">m_UsedNamespacesIds</a>, and <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="xe-m_Buffer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString ParserThread::m_Buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a wxString holding the parsing buffer </p>

<p>Referenced by <a class="el" href="classParserThread#zz-GetFilename">GetFilename()</a>, and <a class="el" href="classParserThread#fc-InitTokenizer">InitTokenizer()</a>.</p>

</div>
</div>
<a class="anchor" id="ge-m_EncounteredNamespaces"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;wxString&gt; ParserThread::m_EncounteredNamespaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for member funcs implementation or a function declaration below eg: int ClassA::FunctionB(); EncounteredNamespaces is 'ClassA' </p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="gg-m_EncounteredTypeNamespaces"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;wxString&gt; ParserThread::m_EncounteredTypeNamespaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>namespaces in function return types for a function declaration below: e.g. </p>
<p>: ClassC::returnValue ClassA::FunctionB(); m_EncounteredTypeNamespaces is 'ClassC' </p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="a8-m_EnumUnnamedCount"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ParserThread::m_EnumUnnamedCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>.</p>

</div>
</div>
<a class="anchor" id="ak-m_FileIdx"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ParserThread::m_FileIdx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>source file index on the "file map tree" </p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#fp-FindTokenFromQueue">FindTokenFromQueue()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">HandleNamespace()</a>, <a class="el" href="classParserThread#fc-InitTokenizer">InitTokenizer()</a>, <a class="el" href="classParserThread#te-Parse">Parse()</a>, and <a class="el" href="classParserThread#gl-RefineAnonymousTypeToken">RefineAnonymousTypeToken()</a>.</p>

</div>
</div>
<a class="anchor" id="ql-m_Filename"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString ParserThread::m_Filename</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the file name of the parsing source </p>

<p>Referenced by <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, <a class="el" href="classParserThread#ky-HandleIncludes">HandleIncludes()</a>, <a class="el" href="classParserThread#fc-InitTokenizer">InitTokenizer()</a>, and <a class="el" href="classParserThread#te-Parse">Parse()</a>.</p>

</div>
</div>
<a class="anchor" id="gi-m_FileSize"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ParserThread::m_FileSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>file size, actually the length of the wxString </p>

<p>Referenced by <a class="el" href="classParserThread#fc-InitTokenizer">InitTokenizer()</a>.</p>

</div>
</div>
<a class="anchor" id="wm-m_IsBuffer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::m_IsBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>local file or buffer in memory </p>

<p>Referenced by <a class="el" href="classParserThread#fc-InitTokenizer">InitTokenizer()</a>.</p>

</div>
</div>
<a class="anchor" id="gx-m_IsLocal"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::m_IsLocal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if true, means we are parsing a file which belongs to a C::B project, otherwise, we are parsing a file not belong to a C::B project(such as a system header file) </p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#fp-FindTokenFromQueue">FindTokenFromQueue()</a>, and <a class="el" href="classParserThread#ky-HandleIncludes">HandleIncludes()</a>.</p>

</div>
</div>
<a class="anchor" id="dn-m_LastParent"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classToken">Token</a>* ParserThread::m_LastParent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parent <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a>, for example, when you are parsing in the class member variables, m_LastParent holds a pointer to the current context, which is a token holding class name </p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#tp-HandleDefines">HandleDefines()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">HandleNamespace()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ReadClsNames()</a>, <a class="el" href="classParserThread#p3-ReadVarNames">ReadVarNames()</a>, and <a class="el" href="classParserThread#gl-RefineAnonymousTypeToken">RefineAnonymousTypeToken()</a>.</p>

</div>
</div>
<a class="anchor" id="rj-m_LastScope"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="token_8h#bs-TokenScope">TokenScope</a> ParserThread::m_LastScope</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this member define the scope type of member variables, which is: public, private protected or undefined </p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, and <a class="el" href="classParserThread#bg-HandleNamespace">HandleNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="kb-m_LastToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString ParserThread::m_LastToken</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hold the previous token string </p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>.</p>

</div>
</div>
<a class="anchor" id="vq-m_LastUnnamedTokenName"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString ParserThread::m_LastUnnamedTokenName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: describe me here. </p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="wi-m_Options"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structParserThreadOptions">ParserThreadOptions</a> ParserThread::m_Options</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parser options, see the <a class="el" href="structParserThreadOptions">ParserThreadOptions</a> structure </p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, <a class="el" href="classParserThread#ky-HandleIncludes">HandleIncludes()</a>, <a class="el" href="classParserThread#sa-HandleMacroExpansion">HandleMacroExpansion()</a>, <a class="el" href="classParserThread#fc-InitTokenizer">InitTokenizer()</a>, <a class="el" href="classParserThread#te-Parse">Parse()</a>, <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace()</a>, and <a class="el" href="classParserThread#js-ParserThread">~ParserThread()</a>.</p>

</div>
</div>
<a class="anchor" id="lq-m_Parent"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParserBase">ParserBase</a>* ParserThread::m_Parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a pointer to its parent <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> object, the Parserthread class has two place to communicate with <a class="el" href="classParser" title="Parser class holds all the tokens of a C::B project. ">Parser</a> class. </p>
<p>m_Parent-&gt;ParseFile() when it see an include directive. </p>

<p>Referenced by <a class="el" href="classParserThread#ky-HandleIncludes">HandleIncludes()</a>.</p>

</div>
</div>
<a class="anchor" id="qh-m_ParsingTypedef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParserThread::m_ParsingTypedef</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this makes a difference in unnamed class/struct/enum handling </p>

<p>Referenced by <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>, <a class="el" href="classParserThread#te-Parse">Parse()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParseBufferForNamespaces()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="ng-m_PointerOrRef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString ParserThread::m_PointerOrRef</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a pointer indicator or a references </p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">HandleConditionalArguments()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">HandleForLoopArguments()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ReadClsNames()</a>, and <a class="el" href="classParserThread#p3-ReadVarNames">ReadVarNames()</a>.</p>

</div>
</div>
<a class="anchor" id="x2-m_Str"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString ParserThread::m_Str</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a very important member variables! It serves as a type stack, eg: parsing the statement: "int wxString const varA;" we determine 'varA' is a token variable, until we searching to the last semicolon. </p>
<p>every token before 'varA' will be pushed to m_Str, at this time m_Str = "int wxString const" </p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#rj-GetTokenBaseType">GetTokenBaseType()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">HandleConditionalArguments()</a>, <a class="el" href="classParserThread#tp-HandleDefines">HandleDefines()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>, <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ReadClsNames()</a>, <a class="el" href="classParserThread#p3-ReadVarNames">ReadVarNames()</a>, and <a class="el" href="classParserThread#gl-RefineAnonymousTypeToken">RefineAnonymousTypeToken()</a>.</p>

</div>
</div>
<a class="anchor" id="ha-m_StructUnionUnnamedCount"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ParserThread::m_StructUnionUnnamedCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>.</p>

</div>
</div>
<a class="anchor" id="ly-m_TemplateArgument"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString ParserThread::m_TemplateArgument</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>holds current template argument(s) when a template occurs </p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">GetTemplateArgs()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">HandleConditionalArguments()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>, and <a class="el" href="classParserThread#vw-ResolveTemplateArgs">ResolveTemplateArgs()</a>.</p>

</div>
</div>
<a class="anchor" id="xs-m_Tokenizer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTokenizer">Tokenizer</a> ParserThread::m_Tokenizer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if we regard the parserThread class as a syntax analyzer, then the <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> class is regard as the lexer, which always feeds a wxString by calling m_Tokenizer.GetToken() </p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">CalcEnumExpression()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">GetTemplateArgs()</a>, <a class="el" href="classParserThread#s3-HandleClass">HandleClass()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">HandleConditionalArguments()</a>, <a class="el" href="classParserThread#tp-HandleDefines">HandleDefines()</a>, <a class="el" href="classParserThread#gm-HandleEnum">HandleEnum()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">HandleFunction()</a>, <a class="el" href="classParserThread#ky-HandleIncludes">HandleIncludes()</a>, <a class="el" href="classParserThread#sa-HandleMacroExpansion">HandleMacroExpansion()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">HandleNamespace()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">HandleTypedef()</a>, <a class="el" href="classParserThread#sn-HandleUndefs">HandleUndefs()</a>, <a class="el" href="classParserThread#fc-InitTokenizer">InitTokenizer()</a>, <a class="el" href="classParserThread#te-Parse">Parse()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParseBufferForNamespaces()</a>, <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParseBufferForUsingNamespace()</a>, <a class="el" href="classParserThread#kb-ParserThread">ParserThread()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ReadClsNames()</a>, <a class="el" href="classParserThread#p3-ReadVarNames">ReadVarNames()</a>, <a class="el" href="classParserThread#pl-SkipAngleBraces">SkipAngleBraces()</a>, <a class="el" href="classParserThread#ru-SkipBlock">SkipBlock()</a>, and <a class="el" href="classParserThread#zh-SkipToOneOfChars">SkipToOneOfChars()</a>.</p>

</div>
</div>
<a class="anchor" id="x5-m_TokenTree"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTokenTree">TokenTree</a>* ParserThread::m_TokenTree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a pointer to the token tree, all the tokens will be added to that tree structure </p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">CalcEnumExpression()</a>, <a class="el" href="classParserThread#hd-DoAddToken">DoAddToken()</a>, <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, <a class="el" href="classParserThread#fp-FindTokenFromQueue">FindTokenFromQueue()</a>, <a class="el" href="classParserThread#ky-HandleIncludes">HandleIncludes()</a>, <a class="el" href="classParserThread#sa-HandleMacroExpansion">HandleMacroExpansion()</a>, <a class="el" href="classParserThread#sn-HandleUndefs">HandleUndefs()</a>, <a class="el" href="classParserThread#fc-InitTokenizer">InitTokenizer()</a>, <a class="el" href="classParserThread#te-Parse">Parse()</a>, <a class="el" href="classParserThread#kb-ParserThread">ParserThread()</a>, <a class="el" href="classParserThread#gl-RefineAnonymousTypeToken">RefineAnonymousTypeToken()</a>, <a class="el" href="classParserThread#rd-ResolveTemplateMap">ResolveTemplateMap()</a>, and <a class="el" href="classParserThread#mq-TokenExists">TokenExists()</a>.</p>

</div>
</div>
<a class="anchor" id="aw-m_UsedNamespacesIds"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="token_8h#wh-TokenIdxSet">TokenIdxSet</a> ParserThread::m_UsedNamespacesIds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>globally included namespaces by "using namespace" statement </p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">DoParse()</a>, and <a class="el" href="classParserThread#mq-TokenExists">TokenExists()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="parserthread_8h_source">parserthread.h</a></li>
<li><a class="el" href="parserthread_8cpp">parserthread.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
