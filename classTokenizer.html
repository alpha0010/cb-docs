<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Code::Blocks: Tokenizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Code::Blocks
   &#160;<span id="projectnumber">SVN r10603</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated"><span>Classes</span></a></li>
      <li><a href="files"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated"><span>Class&#160;List</span></a></li>
      <li><a href="classes"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classTokenizer-members">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Tokenizer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is just a simple lexer class.  
 <a href="classTokenizer#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tokenizer_8h_source">tokenizer.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Tokenizer:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTokenizer__coll__graph.svg" width="1222" height="3318"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTokenizer_1_1ExpandedMacro">ExpandedMacro</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">replaced buffer information Here is an example of how macro are expanded  <a href="structTokenizer_1_1ExpandedMacro#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:lo-Tokenizer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#lo-Tokenizer">Tokenizer</a> (<a class="el" href="classTokenTree">TokenTree</a> *tokenTree, const wxString &amp;filename=wxEmptyString)</td></tr>
<tr class="memdesc:lo-Tokenizer"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> constructor.  <a href="#lo-Tokenizer">More...</a><br /></td></tr>
<tr class="separator:lo-Tokenizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zb-Tokenizer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#zb-Tokenizer">~Tokenizer</a> ()</td></tr>
<tr class="memdesc:zb-Tokenizer"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> destructor.  <a href="#zb-Tokenizer">More...</a><br /></td></tr>
<tr class="separator:zb-Tokenizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zq-Init"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#zq-Init">Init</a> (const wxString &amp;filename=wxEmptyString, <a class="el" href="classLoaderBase">LoaderBase</a> *loader=0)</td></tr>
<tr class="memdesc:zq-Init"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the buffer by opening a file through a loader, this function copy the contents from the loader's buffer to its own buffer, so after that, we can safely delete the loader after this function call.  <a href="#zq-Init">More...</a><br /></td></tr>
<tr class="separator:zq-Init"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jo-InitFromBuffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer</a> (const wxString &amp;buffer, const wxString &amp;fileOfBuffer=wxEmptyString, size_t initLineNumber=0)</td></tr>
<tr class="memdesc:jo-InitFromBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the buffer by directly using a wxString's content.  <a href="#jo-InitFromBuffer">More...</a><br /></td></tr>
<tr class="separator:jo-InitFromBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:p4-GetToken"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#p4-GetToken">GetToken</a> ()</td></tr>
<tr class="memdesc:p4-GetToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume and return the current token string.  <a href="#p4-GetToken">More...</a><br /></td></tr>
<tr class="separator:p4-GetToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pm-PeekToken"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#pm-PeekToken">PeekToken</a> ()</td></tr>
<tr class="memdesc:pm-PeekToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a "look ahead", and return the next token string.  <a href="#pm-PeekToken">More...</a><br /></td></tr>
<tr class="separator:pm-PeekToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jv-UngetToken"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jv-UngetToken">UngetToken</a> ()</td></tr>
<tr class="memdesc:jv-UngetToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the GetToken.  <a href="#jv-UngetToken">More...</a><br /></td></tr>
<tr class="separator:jv-UngetToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:uv-SetTokenizerOption"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#uv-SetTokenizerOption">SetTokenizerOption</a> (bool wantPreprocessor, bool storeDocumentation)</td></tr>
<tr class="memdesc:uv-SetTokenizerOption"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle condition preprocessor and store documentation or not.  <a href="#uv-SetTokenizerOption">More...</a><br /></td></tr>
<tr class="separator:uv-SetTokenizerOption"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:no-SetState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#no-SetState">SetState</a> (<a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a> state)</td></tr>
<tr class="memdesc:no-SetState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> skipping options.  <a href="#no-SetState">More...</a><br /></td></tr>
<tr class="separator:no-SetState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:kr-GetState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#kr-GetState">GetState</a> ()</td></tr>
<tr class="memdesc:kr-GetState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the skipping options value, see TokenizerState for more details.  <a href="#kr-GetState">More...</a><br /></td></tr>
<tr class="separator:kr-GetState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rn-GetFilename"><td class="memItemLeft" align="right" valign="top">const wxString &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#rn-GetFilename">GetFilename</a> () const </td></tr>
<tr class="memdesc:rn-GetFilename"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the opened files name.  <a href="#rn-GetFilename">More...</a><br /></td></tr>
<tr class="separator:rn-GetFilename"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jr-GetLineNumber"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jr-GetLineNumber">GetLineNumber</a> () const </td></tr>
<tr class="memdesc:jr-GetLineNumber"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the line number of the current token string.  <a href="#jr-GetLineNumber">More...</a><br /></td></tr>
<tr class="separator:jr-GetLineNumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:el-GetNestingLevel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#el-GetNestingLevel">GetNestingLevel</a> () const </td></tr>
<tr class="memdesc:el-GetNestingLevel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the brace "{}" level.  <a href="#el-GetNestingLevel">More...</a><br /></td></tr>
<tr class="separator:el-GetNestingLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:li-SaveNestingLevel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#li-SaveNestingLevel">SaveNestingLevel</a> ()</td></tr>
<tr class="memdesc:li-SaveNestingLevel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the brace "{" level, the parser might need to ignore the nesting level in some cases.  <a href="#li-SaveNestingLevel">More...</a><br /></td></tr>
<tr class="separator:li-SaveNestingLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jt-RestoreNestingLevel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jt-RestoreNestingLevel">RestoreNestingLevel</a> ()</td></tr>
<tr class="memdesc:jt-RestoreNestingLevel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the brace level.  <a href="#jt-RestoreNestingLevel">More...</a><br /></td></tr>
<tr class="separator:jt-RestoreNestingLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:f2-IsOK"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#f2-IsOK">IsOK</a> () const </td></tr>
<tr class="memdesc:f2-IsOK"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the buffer is correctly loaded, this function return true.  <a href="#f2-IsOK">More...</a><br /></td></tr>
<tr class="separator:f2-IsOK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:po-ReadToEOL"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL</a> (bool stripUnneeded=true)</td></tr>
<tr class="memdesc:po-ReadToEOL"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the string from the current position to the end of current line, in most case, this function is used in handling #define, use with care outside this class!  <a href="#po-ReadToEOL">More...</a><br /></td></tr>
<tr class="separator:po-ReadToEOL"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zl-ReadParentheses"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses</a> (wxString &amp;str)</td></tr>
<tr class="memdesc:zl-ReadParentheses"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a string from '(' to ')', note that inner parentheses considered  <a href="#zl-ReadParentheses">More...</a><br /></td></tr>
<tr class="separator:zl-ReadParentheses"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:l2-SkipToEOL"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL</a> ()</td></tr>
<tr class="memdesc:l2-SkipToEOL"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip from the current position to the end of line.  <a href="#l2-SkipToEOL">More...</a><br /></td></tr>
<tr class="separator:l2-SkipToEOL"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:e2-SkipToInlineCommentEnd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd</a> ()</td></tr>
<tr class="memdesc:e2-SkipToInlineCommentEnd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip to then end of the C++ style comment.  <a href="#e2-SkipToInlineCommentEnd">More...</a><br /></td></tr>
<tr class="separator:e2-SkipToInlineCommentEnd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:x9-IsEOF"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#x9-IsEOF">IsEOF</a> () const </td></tr>
<tr class="memdesc:x9-IsEOF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> reaches the end of the buffer (file)  <a href="#x9-IsEOF">More...</a><br /></td></tr>
<tr class="separator:x9-IsEOF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:c2-NotEOF"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#c2-NotEOF">NotEOF</a> () const </td></tr>
<tr class="memdesc:c2-NotEOF"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if it is Not the end of buffer  <a href="#c2-NotEOF">More...</a><br /></td></tr>
<tr class="separator:c2-NotEOF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:i3-ReplaceBufferText"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText</a> (const wxString &amp;target, const <a class="el" href="classToken">Token</a> *macro=0)</td></tr>
<tr class="memdesc:i3-ReplaceBufferText"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward buffer replacement for re-parsing.  <a href="#i3-ReplaceBufferText">More...</a><br /></td></tr>
<tr class="separator:i3-ReplaceBufferText"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:v8-ReplaceMacroUsage"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#v8-ReplaceMacroUsage">ReplaceMacroUsage</a> (const <a class="el" href="classToken">Token</a> *tk)</td></tr>
<tr class="memdesc:v8-ReplaceMacroUsage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get expanded text for the current macro usage, then replace buffer for re-parsing.  <a href="#v8-ReplaceMacroUsage">More...</a><br /></td></tr>
<tr class="separator:v8-ReplaceMacroUsage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ma-GetFirstTokenPosition"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ma-GetFirstTokenPosition">GetFirstTokenPosition</a> (const wxString &amp;buffer, const wxString &amp;target)</td></tr>
<tr class="memdesc:ma-GetFirstTokenPosition"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search "target" in the buffer, return first position in buffer.  <a href="#ma-GetFirstTokenPosition">More...</a><br /></td></tr>
<tr class="separator:ma-GetFirstTokenPosition"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ow-GetFirstTokenPosition"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ow-GetFirstTokenPosition">GetFirstTokenPosition</a> (const wxChar *buffer, const size_t bufferLen, const wxChar *key, const size_t keyLen)</td></tr>
<tr class="memdesc:ow-GetFirstTokenPosition"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the sub-string key in the whole buffer, return the first position of the key  <a href="#ow-GetFirstTokenPosition">More...</a><br /></td></tr>
<tr class="separator:ow-GetFirstTokenPosition"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:je-KMP_Find"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#je-KMP_Find">KMP_Find</a> (const wxChar *text, const wxChar *pattern, const int patternLen)</td></tr>
<tr class="memdesc:je-KMP_Find"><td class="mdescLeft">&#160;</td><td class="mdescRight">KMP find, get the first position, if find nothing, return -1 <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm</a>.  <a href="#je-KMP_Find">More...</a><br /></td></tr>
<tr class="separator:je-KMP_Find"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7-SetLastTokenIdx"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#d7-SetLastTokenIdx">SetLastTokenIdx</a> (int tokenIdx)</td></tr>
<tr class="memdesc:d7-SetLastTokenIdx"><td class="mdescLeft">&#160;</td><td class="mdescRight">a <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> is added, associate doxygen style documents(comments before the variables) to the <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a>  <a href="#d7-SetLastTokenIdx">More...</a><br /></td></tr>
<tr class="separator:d7-SetLastTokenIdx"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ti-BaseInit"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ti-BaseInit">BaseInit</a> ()</td></tr>
<tr class="memdesc:ti-BaseInit"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize some member variables.  <a href="#ti-BaseInit">More...</a><br /></td></tr>
<tr class="separator:ti-BaseInit"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nr-DoGetToken"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken</a> ()</td></tr>
<tr class="memdesc:nr-DoGetToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the actual lexical analysis, both <a class="el" href="classTokenizer#p4-GetToken" title="Consume and return the current token string. ">GetToken()</a> and <a class="el" href="classTokenizer#pm-PeekToken" title="Do a &quot;look ahead&quot;, and return the next token string. ">PeekToken()</a> will internally call this function.  <a href="#nr-DoGetToken">More...</a><br /></td></tr>
<tr class="separator:nr-DoGetToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oa-CheckMacroUsageAndReplace"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#oa-CheckMacroUsageAndReplace">CheckMacroUsageAndReplace</a> ()</td></tr>
<tr class="memdesc:oa-CheckMacroUsageAndReplace"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the m_Lex to see it is an identifier like token, and also if it is a macro usage, replace it.  <a href="#oa-CheckMacroUsageAndReplace">More...</a><br /></td></tr>
<tr class="separator:oa-CheckMacroUsageAndReplace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:xx-Lex"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#xx-Lex">Lex</a> ()</td></tr>
<tr class="memdesc:xx-Lex"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function only move the m_TokenIndex and get a lexeme and store it in m_Lex, the m_Lex will be further checked if it is a macro usage or not.  <a href="#xx-Lex">More...</a><br /></td></tr>
<tr class="separator:xx-Lex"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ey-ReadFile"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ey-ReadFile">ReadFile</a> ()</td></tr>
<tr class="memdesc:ey-ReadFile"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a file, and fill the m_Buffer.  <a href="#ey-ReadFile">More...</a><br /></td></tr>
<tr class="separator:ey-ReadFile"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vg-IsEscapedChar"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar</a> ()</td></tr>
<tr class="memdesc:vg-IsEscapedChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the current character is a C-Escape character in a string.  <a href="#vg-IsEscapedChar">More...</a><br /></td></tr>
<tr class="separator:vg-IsEscapedChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:xn-SkipToChar"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar</a> (const wxChar &amp;ch)</td></tr>
<tr class="memdesc:xn-SkipToChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip character until we meet a ch.  <a href="#xn-SkipToChar">More...</a><br /></td></tr>
<tr class="separator:xn-SkipToChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nb-SkipUnwanted"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted</a> ()</td></tr>
<tr class="memdesc:nb-SkipUnwanted"><td class="mdescLeft">&#160;</td><td class="mdescRight">skips comments, spaces, preprocessor branch.  <a href="#nb-SkipUnwanted">More...</a><br /></td></tr>
<tr class="separator:nb-SkipUnwanted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vm-SkipWhiteSpace"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace</a> ()</td></tr>
<tr class="memdesc:vm-SkipWhiteSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip any "tab" "white-space".  <a href="#vm-SkipWhiteSpace">More...</a><br /></td></tr>
<tr class="separator:vm-SkipWhiteSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:eo-SkipComment"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#eo-SkipComment">SkipComment</a> ()</td></tr>
<tr class="memdesc:eo-SkipComment"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip the C/C++ comment.  <a href="#eo-SkipComment">More...</a><br /></td></tr>
<tr class="separator:eo-SkipComment"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:z9-SkipPreprocessorBranch"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#z9-SkipPreprocessorBranch">SkipPreprocessorBranch</a> ()</td></tr>
<tr class="memdesc:z9-SkipPreprocessorBranch"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip the C preprocessor directive, such as #ifdef xxxx only the conditional preprocessor directives are handled here, the others such as #include or #warning and all kinds of ptOthers will passed to Parserthread class.  <a href="#z9-SkipPreprocessorBranch">More...</a><br /></td></tr>
<tr class="separator:z9-SkipPreprocessorBranch"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ah-SkipString"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ah-SkipString">SkipString</a> ()</td></tr>
<tr class="memdesc:ah-SkipString"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip the string literal(enclosed in double quotes) or character literal(enclosed in single quotes).  <a href="#ah-SkipString">More...</a><br /></td></tr>
<tr class="separator:ah-SkipString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:js-SkipToStringEnd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd</a> (const wxChar &amp;ch)</td></tr>
<tr class="memdesc:js-SkipToStringEnd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move to the end of string literal or character literal, the m_TokenIndex will at the closing quote character.  <a href="#js-SkipToStringEnd">More...</a><br /></td></tr>
<tr class="separator:js-SkipToStringEnd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:op-MoveToNextChar"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar</a> ()</td></tr>
<tr class="memdesc:op-MoveToNextChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move to the next character in the buffer.  <a href="#op-MoveToNextChar">More...</a><br /></td></tr>
<tr class="separator:op-MoveToNextChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:kq-CurrentChar"><td class="memItemLeft" align="right" valign="top">wxChar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar</a> () const </td></tr>
<tr class="memdesc:kq-CurrentChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current character indexed by m_TokenIndex in the m_Buffer.  <a href="#kq-CurrentChar">More...</a><br /></td></tr>
<tr class="separator:kq-CurrentChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mc-CurrentCharMoveNext"><td class="memItemLeft" align="right" valign="top">wxChar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#mc-CurrentCharMoveNext">CurrentCharMoveNext</a> ()</td></tr>
<tr class="memdesc:mc-CurrentCharMoveNext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the previous two functions sequentially.  <a href="#mc-CurrentCharMoveNext">More...</a><br /></td></tr>
<tr class="separator:mc-CurrentCharMoveNext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:k0-NextChar"><td class="memItemLeft" align="right" valign="top">wxChar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#k0-NextChar">NextChar</a> () const </td></tr>
<tr class="memdesc:k0-NextChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (peek) the next character.  <a href="#k0-NextChar">More...</a><br /></td></tr>
<tr class="separator:k0-NextChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lf-PreviousChar"><td class="memItemLeft" align="right" valign="top">wxChar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar</a> () const </td></tr>
<tr class="memdesc:lf-PreviousChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (peek) the previous character.  <a href="#lf-PreviousChar">More...</a><br /></td></tr>
<tr class="separator:lf-PreviousChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:oc-CharInString"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#oc-CharInString">CharInString</a> (const wxChar ch, const wxChar *chars) const </td></tr>
<tr class="memdesc:oc-CharInString"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a ch matches any characters in the wxChar array.  <a href="#oc-CharInString">More...</a><br /></td></tr>
<tr class="separator:oc-CharInString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:se-IsBackslashBeforeEOL"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL</a> ()</td></tr>
<tr class="memdesc:se-IsBackslashBeforeEOL"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the previous char before EOL is a backslash, call this function in the condition that the CurrentChar is '<br />
', here we have two cases:  <a href="#se-IsBackslashBeforeEOL">More...</a><br /></td></tr>
<tr class="separator:se-IsBackslashBeforeEOL"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pi-CalcConditionExpression"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression</a> ()</td></tr>
<tr class="memdesc:pi-CalcConditionExpression"><td class="mdescLeft">&#160;</td><td class="mdescRight">#if xxxx, calculate the value of "xxxx"  <a href="#pi-CalcConditionExpression">More...</a><br /></td></tr>
<tr class="separator:pi-CalcConditionExpression"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:wz-IsMacroDefined"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined</a> ()</td></tr>
<tr class="memdesc:wz-IsMacroDefined"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the next token string is macro usage, return true.  <a href="#wz-IsMacroDefined">More...</a><br /></td></tr>
<tr class="separator:wz-IsMacroDefined"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:bm-HandleDefines"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#bm-HandleDefines">HandleDefines</a> ()</td></tr>
<tr class="memdesc:bm-HandleDefines"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the statement: #define XXXXX  <a href="#bm-HandleDefines">More...</a><br /></td></tr>
<tr class="separator:bm-HandleDefines"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:us-HandleUndefs"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#us-HandleUndefs">HandleUndefs</a> ()</td></tr>
<tr class="memdesc:us-HandleUndefs"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the statement: #undef XXXXX  <a href="#us-HandleUndefs">More...</a><br /></td></tr>
<tr class="separator:us-HandleUndefs"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:bp-AddMacroDefinition"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#bp-AddMacroDefinition">AddMacroDefinition</a> (wxString name, int line, wxString para, wxString substitues)</td></tr>
<tr class="memdesc:bp-AddMacroDefinition"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a macro definition for example: #define AAA(x,y) x+y  <a href="#bp-AddMacroDefinition">More...</a><br /></td></tr>
<tr class="separator:bp-AddMacroDefinition"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:u0-SkipToNextConditionPreprocess"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor</a> ()</td></tr>
<tr class="memdesc:u0-SkipToNextConditionPreprocess"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip to the next conditional preprocessor directive branch.  <a href="#u0-SkipToNextConditionPreprocess">More...</a><br /></td></tr>
<tr class="separator:u0-SkipToNextConditionPreprocess"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:h4-SkipToEndConditionPreprocesso"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor</a> ()</td></tr>
<tr class="memdesc:h4-SkipToEndConditionPreprocesso"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip to the #endif conditional preprocessor directive.  <a href="#h4-SkipToEndConditionPreprocesso">More...</a><br /></td></tr>
<tr class="separator:h4-SkipToEndConditionPreprocesso"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qi-GetPreprocessorType"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tokenizer_8h#ck-PreprocessorType">PreprocessorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType</a> ()</td></tr>
<tr class="memdesc:qi-GetPreprocessorType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current conditional preprocessor type.  <a href="#qi-GetPreprocessorType">More...</a><br /></td></tr>
<tr class="separator:qi-GetPreprocessorType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:v8-HandleConditionPreprocessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor</a> (const <a class="el" href="tokenizer_8h#ck-PreprocessorType">PreprocessorType</a> type)</td></tr>
<tr class="memdesc:v8-HandleConditionPreprocessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the preprocessor directive: #ifdef XXX or #endif or #if or #elif or...  <a href="#v8-HandleConditionPreprocessor">More...</a><br /></td></tr>
<tr class="separator:v8-HandleConditionPreprocessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ew-SplitArguments"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments</a> (wxArrayString &amp;results)</td></tr>
<tr class="memdesc:ew-SplitArguments"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the macro arguments, and store them in results, when calling this function, we expect that m_TokenIndex point to the opening '(', or some spaces before the opening '('.  <a href="#ew-SplitArguments">More...</a><br /></td></tr>
<tr class="separator:ew-SplitArguments"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jw-GetMacroExpandedText"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jw-GetMacroExpandedText">GetMacroExpandedText</a> (const <a class="el" href="classToken">Token</a> *tk, wxString &amp;expandedText)</td></tr>
<tr class="memdesc:jw-GetMacroExpandedText"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text after macro expansion.  <a href="#jw-GetMacroExpandedText">More...</a><br /></td></tr>
<tr class="separator:jw-GetMacroExpandedText"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc-KMP_GetNextVal"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#dc-KMP_GetNextVal">KMP_GetNextVal</a> (const wxChar *pattern, int next[])</td></tr>
<tr class="memdesc:dc-KMP_GetNextVal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just for KMP find.  <a href="#dc-KMP_GetNextVal">More...</a><br /></td></tr>
<tr class="separator:dc-KMP_GetNextVal"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:xt-m_TokenizerOptions"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tokenizer_8h#structTokenizerOptions">TokenizerOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#xt-m_TokenizerOptions">m_TokenizerOptions</a></td></tr>
<tr class="memdesc:xt-m_TokenizerOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> options specify the skipping option.  <a href="#xt-m_TokenizerOptions">More...</a><br /></td></tr>
<tr class="separator:xt-m_TokenizerOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ti-m_TokenTree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a></td></tr>
<tr class="memdesc:ti-m_TokenTree"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> tree to store the macro definition  <a href="#ti-m_TokenTree">More...</a><br /></td></tr>
<tr class="separator:ti-m_TokenTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jr-m_Filename"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a></td></tr>
<tr class="memdesc:jr-m_Filename"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filename of the buffer.  <a href="#jr-m_Filename">More...</a><br /></td></tr>
<tr class="separator:jr-m_Filename"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:fn-m_FileIdx"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#fn-m_FileIdx">m_FileIdx</a></td></tr>
<tr class="memdesc:fn-m_FileIdx"><td class="mdescLeft">&#160;</td><td class="mdescRight">File index, useful when parsing documentation;.  <a href="#fn-m_FileIdx">More...</a><br /></td></tr>
<tr class="separator:fn-m_FileIdx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:g5-m_Buffer"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a></td></tr>
<tr class="memdesc:g5-m_Buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer content, all the lexical analysis is done on this.  <a href="#g5-m_Buffer">More...</a><br /></td></tr>
<tr class="separator:g5-m_Buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:k5-m_BufferLen"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a></td></tr>
<tr class="memdesc:k5-m_BufferLen"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer length.  <a href="#k5-m_BufferLen">More...</a><br /></td></tr>
<tr class="separator:k5-m_BufferLen"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab-m_Lex"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ab-m_Lex">m_Lex</a></td></tr>
<tr class="memdesc:ab-m_Lex"><td class="mdescLeft">&#160;</td><td class="mdescRight">a lexeme string return by the <a class="el" href="classTokenizer#xx-Lex" title="this function only move the m_TokenIndex and get a lexeme and store it in m_Lex, the m_Lex will be fu...">Lex()</a> function, this is a candidate token string, but may be replaced if it is a macro usage  <a href="#ab-m_Lex">More...</a><br /></td></tr>
<tr class="separator:ab-m_Lex"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:in-m_Token"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#in-m_Token">m_Token</a></td></tr>
<tr class="memdesc:in-m_Token"><td class="mdescLeft">&#160;</td><td class="mdescRight">These variables define the current token string and its auxiliary information, such as the token name, the line number of the token, the current brace nest level.  <a href="#in-m_Token">More...</a><br /></td></tr>
<tr class="separator:in-m_Token"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:c8-m_TokenIndex"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a></td></tr>
<tr class="memdesc:c8-m_TokenIndex"><td class="mdescLeft">&#160;</td><td class="mdescRight">index offset in buffer, when parsing a buffer  <a href="#c8-m_TokenIndex">More...</a><br /></td></tr>
<tr class="separator:c8-m_TokenIndex"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ko-m_LineNumber"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a></td></tr>
<tr class="memdesc:ko-m_LineNumber"><td class="mdescLeft">&#160;</td><td class="mdescRight">line offset in buffer, please note that it is 1 based, not 0 based  <a href="#ko-m_LineNumber">More...</a><br /></td></tr>
<tr class="separator:ko-m_LineNumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ru-m_NestLevel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a></td></tr>
<tr class="memdesc:ru-m_NestLevel"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep track of block nesting { }  <a href="#ru-m_NestLevel">More...</a><br /></td></tr>
<tr class="separator:ru-m_NestLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ky-m_UndoTokenIndex"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a></td></tr>
<tr class="memdesc:ky-m_UndoTokenIndex"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backup the previous <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> information.  <a href="#ky-m_UndoTokenIndex">More...</a><br /></td></tr>
<tr class="separator:ky-m_UndoTokenIndex"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ol-m_UndoLineNumber"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a></td></tr>
<tr class="separator:ol-m_UndoLineNumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:n2-m_UndoNestLevel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a></td></tr>
<tr class="separator:n2-m_UndoNestLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ve-m_PeekAvailable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ve-m_PeekAvailable">m_PeekAvailable</a></td></tr>
<tr class="memdesc:ve-m_PeekAvailable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek token information.  <a href="#ve-m_PeekAvailable">More...</a><br /></td></tr>
<tr class="separator:ve-m_PeekAvailable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:xt-m_PeekToken"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#xt-m_PeekToken">m_PeekToken</a></td></tr>
<tr class="separator:xt-m_PeekToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:o1-m_PeekTokenIndex"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#o1-m_PeekTokenIndex">m_PeekTokenIndex</a></td></tr>
<tr class="separator:o1-m_PeekTokenIndex"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oj-m_PeekLineNumber"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#oj-m_PeekLineNumber">m_PeekLineNumber</a></td></tr>
<tr class="separator:oj-m_PeekLineNumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:fy-m_PeekNestLevel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#fy-m_PeekNestLevel">m_PeekNestLevel</a></td></tr>
<tr class="separator:fy-m_PeekNestLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:n3-m_SavedTokenIndex"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#n3-m_SavedTokenIndex">m_SavedTokenIndex</a></td></tr>
<tr class="memdesc:n3-m_SavedTokenIndex"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saved token info (for <a class="el" href="classTokenizer#pm-PeekToken" title="Do a &quot;look ahead&quot;, and return the next token string. ">PeekToken()</a>), m_TokenIndex will be moved forward or backward when either <a class="el" href="classTokenizer#nr-DoGetToken" title="Do the actual lexical analysis, both GetToken() and PeekToken() will internally call this function...">DoGetToken()</a> or <a class="el" href="classTokenizer#nb-SkipUnwanted" title="skips comments, spaces, preprocessor branch. ">SkipUnwanted()</a> is called, so we should save m_TokenIndex before it get modified.  <a href="#n3-m_SavedTokenIndex">More...</a><br /></td></tr>
<tr class="separator:n3-m_SavedTokenIndex"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tn-m_SavedLineNumber"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#tn-m_SavedLineNumber">m_SavedLineNumber</a></td></tr>
<tr class="separator:tn-m_SavedLineNumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mi-m_SavedNestingLevel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a></td></tr>
<tr class="separator:mi-m_SavedNestingLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:hj-m_IsOK"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#hj-m_IsOK">m_IsOK</a></td></tr>
<tr class="memdesc:hj-m_IsOK"><td class="mdescLeft">&#160;</td><td class="mdescRight">bool variable specifies whether the buffer is ready for parsing  <a href="#hj-m_IsOK">More...</a><br /></td></tr>
<tr class="separator:hj-m_IsOK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:xa-m_State"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#xa-m_State">m_State</a></td></tr>
<tr class="memdesc:xa-m_State"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokeniser state specifies the skipping option.  <a href="#xa-m_State">More...</a><br /></td></tr>
<tr class="separator:xa-m_State"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ky-m_Loader"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoaderBase">LoaderBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ky-m_Loader">m_Loader</a></td></tr>
<tr class="memdesc:ky-m_Loader"><td class="mdescLeft">&#160;</td><td class="mdescRight">File loader.  <a href="#ky-m_Loader">More...</a><br /></td></tr>
<tr class="separator:ky-m_Loader"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:x8-m_ExpressionResult"><td class="memItemLeft" align="right" valign="top">std::stack&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#x8-m_ExpressionResult">m_ExpressionResult</a></td></tr>
<tr class="memdesc:x8-m_ExpressionResult"><td class="mdescLeft">&#160;</td><td class="mdescRight">preprocessor branch stack, if we meet a #if 1, then the value true will be pushed to to the stack, if we skip the #endif, the true value should be popped.  <a href="#x8-m_ExpressionResult">More...</a><br /></td></tr>
<tr class="separator:x8-m_ExpressionResult"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:je-m_ExpandedMacros"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structTokenizer_1_1ExpandedMacro">ExpandedMacro</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#je-m_ExpandedMacros">m_ExpandedMacros</a></td></tr>
<tr class="memdesc:je-m_ExpandedMacros"><td class="mdescLeft">&#160;</td><td class="mdescRight">this serves as a macro replacement stack, in the above example, if AAA is replaced by BBBB, we store the macro definition of AAA in the m_ExpandedMacros, and if BBBB is also defined as  <a href="#je-m_ExpandedMacros">More...</a><br /></td></tr>
<tr class="separator:je-m_ExpandedMacros"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:i9-m_NextTokenDoc"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#i9-m_NextTokenDoc">m_NextTokenDoc</a></td></tr>
<tr class="memdesc:i9-m_NextTokenDoc"><td class="mdescLeft">&#160;</td><td class="mdescRight">normally, this record the doxygen style comments for the next token definition for example, here is a comment  <a href="#i9-m_NextTokenDoc">More...</a><br /></td></tr>
<tr class="separator:i9-m_NextTokenDoc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cy-m_LastTokenIdx"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#cy-m_LastTokenIdx">m_LastTokenIdx</a></td></tr>
<tr class="memdesc:cy-m_LastTokenIdx"><td class="mdescLeft">&#160;</td><td class="mdescRight">store the recent added token index for example, here is a comment  <a href="#cy-m_LastTokenIdx">More...</a><br /></td></tr>
<tr class="separator:cy-m_LastTokenIdx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:g5-m_ReadingMacroDefinition"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#g5-m_ReadingMacroDefinition">m_ReadingMacroDefinition</a></td></tr>
<tr class="memdesc:g5-m_ReadingMacroDefinition"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates whether we are reading the macro definition This variable will affect how the doxygen comments will be associated to the <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a>.  <a href="#g5-m_ReadingMacroDefinition">More...</a><br /></td></tr>
<tr class="separator:g5-m_ReadingMacroDefinition"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is just a simple lexer class. </p>
<p>A <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> does the lexical analysis on a buffer. The buffer is either a wxString loaded from a local source/header file or a wxString already in memory(e.g. the scintilla text buffer). The most public interfaces are two member functions: <a class="el" href="classTokenizer#p4-GetToken" title="Consume and return the current token string. ">GetToken()</a> and <a class="el" href="classTokenizer#pm-PeekToken" title="Do a &quot;look ahead&quot;, and return the next token string. ">PeekToken()</a>. The former one eats one token string from buffer, the later one does a "look ahead" on the buffer and return the next token string(peeked string). The peeked string will be cached until the next <a class="el" href="classTokenizer#p4-GetToken" title="Consume and return the current token string. ">GetToken()</a> call, thus performance can be improved. Also, <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> class does some kind of handling "Macro expansion" on the buffer, from this point of view, this class is a kind of preprocessor Further more, it handles some "conditional preprocessor directives"(like "#if xxx"). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="lo-Tokenizer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tokenizer::Tokenizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tokenTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>wxEmptyString</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the file to be opened. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#zq-Init">Init()</a>, <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>, <a class="el" href="classTokenizer#xt-m_TokenizerOptions">m_TokenizerOptions</a>, <a class="el" href="tokenizer_8h#ru-storeDocumentation">TokenizerOptions::storeDocumentation</a>, and <a class="el" href="tokenizer_8h#vj-wantPreprocessor">TokenizerOptions::wantPreprocessor</a>.</p>

</div>
</div>
<a class="anchor" id="zb-Tokenizer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tokenizer::~Tokenizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="bp-AddMacroDefinition"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::AddMacroDefinition </td>
          <td>(</td>
          <td class="paramtype">wxString&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxString&#160;</td>
          <td class="paramname"><em>para</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxString&#160;</td>
          <td class="paramname"><em>substitues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a macro definition for example: #define AAA(x,y) x+y </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>macro name which is "AAA" </td></tr>
    <tr><td class="paramname">line</td><td>the line of the macro definition locates </td></tr>
    <tr><td class="paramname">para</td><td>the formal parameters, which is "(x,y)" </td></tr>
    <tr><td class="paramname">substitues</td><td>the definition which is "x+y" </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classTokenTree#fq-insert">TokenTree::insert()</a>, <a class="el" href="classToken#wh-m_Args">Token::m_Args</a>, <a class="el" href="classTokenizer#fn-m_FileIdx">m_FileIdx</a>, <a class="el" href="classToken#z1-m_FullType">Token::m_FullType</a>, <a class="el" href="classToken#wc-m_ParentIndex">Token::m_ParentIndex</a>, <a class="el" href="classToken#ky-m_TokenKind">Token::m_TokenKind</a>, <a class="el" href="classTokenTree#tm-m_TokenTicketCount">TokenTree::m_TokenTicketCount</a>, <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, and <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#bm-HandleDefines">HandleDefines()</a>.</p>

</div>
</div>
<a class="anchor" id="ti-BaseInit"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::BaseInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize some member variables. </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#hj-m_IsOK">m_IsOK</a>, <a class="el" href="classTokenizer#cy-m_LastTokenIdx">m_LastTokenIdx</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#i9-m_NextTokenDoc">m_NextTokenDoc</a>, <a class="el" href="classTokenizer#oj-m_PeekLineNumber">m_PeekLineNumber</a>, <a class="el" href="classTokenizer#fy-m_PeekNestLevel">m_PeekNestLevel</a>, <a class="el" href="classTokenizer#o1-m_PeekTokenIndex">m_PeekTokenIndex</a>, <a class="el" href="classTokenizer#tn-m_SavedLineNumber">m_SavedLineNumber</a>, <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>, <a class="el" href="classTokenizer#n3-m_SavedTokenIndex">m_SavedTokenIndex</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a>, <a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a>, and <a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#zq-Init">Init()</a>, and <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="pi-CalcConditionExpression"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::CalcConditionExpression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>#if xxxx, calculate the value of "xxxx" </p>

<p>References <a class="el" href="classExpression#do-AddToInfixExpression">Expression::AddToInfixExpression()</a>, <a class="el" href="classExpression#k0-CalcPostfix">Expression::CalcPostfix()</a>, <a class="el" href="classExpression#nc-ConvertInfixToPostfix">Expression::ConvertInfixToPostfix()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classExpression#hy-GetResult">Expression::GetResult()</a>, <a class="el" href="classExpression#ef-GetStatus">Expression::GetStatus()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#xa-m_State">m_State</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsRawExpression">tsRawExpression</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="oc-CharInString"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::CharInString </td>
          <td>(</td>
          <td class="paramtype">const wxChar&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a ch matches any characters in the wxChar array. </p>

<p>Referenced by <a class="el" href="classTokenizer#xx-Lex">Lex()</a>.</p>

</div>
</div>
<a class="anchor" id="oa-CheckMacroUsageAndReplace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::CheckMacroUsageAndReplace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the m_Lex to see it is an identifier like token, and also if it is a macro usage, replace it. </p>
<dl class="section return"><dt>Returns</dt><dd>true if some text replacement happens in the m_Buffer, otherwise return false </dd></dl>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classTokenizer#ab-m_Lex">m_Lex</a>, <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#v8-ReplaceMacroUsage">ReplaceMacroUsage()</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, and <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="kq-CurrentChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxChar Tokenizer::CurrentChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current character indexed by m_TokenIndex in the m_Buffer. </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#mc-CurrentCharMoveNext">CurrentCharMoveNext()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#z9-SkipPreprocessorBranch">SkipPreprocessorBranch()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, <a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="mc-CurrentCharMoveNext"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxChar Tokenizer::CurrentCharMoveNext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do the previous two functions sequentially. </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

</div>
</div>
<a class="anchor" id="nr-DoGetToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::DoGetToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do the actual lexical analysis, both <a class="el" href="classTokenizer#p4-GetToken" title="Consume and return the current token string. ">GetToken()</a> and <a class="el" href="classTokenizer#pm-PeekToken" title="Do a &quot;look ahead&quot;, and return the next token string. ">PeekToken()</a> will internally call this function. </p>
<p>It just move the m_TokenIndex one step forward, and return a lexeme before the m_TokenIndex. </p>

<p>References <a class="el" href="classTokenizer#oa-CheckMacroUsageAndReplace">CheckMacroUsageAndReplace()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#ab-m_Lex">m_Lex</a>, and <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>.</p>

</div>
</div>
<a class="anchor" id="rn-GetFilename"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wxString&amp; Tokenizer::GetFilename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the opened files name. </p>

<p>References <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#w4-HandleConditionalArguments">ParserThread::HandleConditionalArguments()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">ParserThread::HandleForLoopArguments()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ParserThread::ReadClsNames()</a>, and <a class="el" href="classParserThread#p3-ReadVarNames">ParserThread::ReadVarNames()</a>.</p>

</div>
</div>
<a class="anchor" id="ma-GetFirstTokenPosition"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Tokenizer::GetFirstTokenPosition </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search "target" in the buffer, return first position in buffer. </p>
<p>it is used to find the formal argument in the macro definition body. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the content </td></tr>
    <tr><td class="paramname">target</td><td>the search key </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classTokenizer#jw-GetMacroExpandedText">GetMacroExpandedText()</a>.</p>

</div>
</div>
<a class="anchor" id="ow-GetFirstTokenPosition"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tokenizer::GetFirstTokenPosition </td>
          <td>(</td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bufferLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>keyLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the sub-string key in the whole buffer, return the first position of the key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the content of the string </td></tr>
    <tr><td class="paramname">bufferLen</td><td>length of the string </td></tr>
    <tr><td class="paramname">key</td><td>the search key(sub-string) </td></tr>
    <tr><td class="paramname">keyLen</td><td>the search key length </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#je-KMP_Find">KMP_Find()</a>.</p>

</div>
</div>
<a class="anchor" id="jr-GetLineNumber"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::GetLineNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the line number of the current token string. </p>

<p>References <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">ParserThread::HandleConditionalArguments()</a>, <a class="el" href="classTokenizer#bm-HandleDefines">HandleDefines()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">ParserThread::HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">ParserThread::HandleFunction()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">ParserThread::HandleNamespace()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">ParserThread::HandleTypedef()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ParserThread::ReadClsNames()</a>, and <a class="el" href="classParserThread#p3-ReadVarNames">ParserThread::ReadVarNames()</a>.</p>

</div>
</div>
<a class="anchor" id="jw-GetMacroExpandedText"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::GetMacroExpandedText </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>tk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>expandedText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the text after macro expansion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tk</td><td>the macro definition token, usually a function like macro definition </td></tr>
    <tr><td class="paramname">expandedText</td><td>is an output string </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#ma-GetFirstTokenPosition">GetFirstTokenPosition()</a>, <a class="el" href="classToken#wh-m_Args">Token::m_Args</a>, <a class="el" href="classToken#z1-m_FullType">Token::m_FullType</a>, <a class="el" href="classTokenizer#ab-m_Lex">m_Lex</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>, <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#v8-ReplaceMacroUsage">ReplaceMacroUsage()</a>.</p>

</div>
</div>
<a class="anchor" id="el-GetNestingLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::GetNestingLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the brace "{}" level. </p>
<p>the value will increase by one when we meet a "{", decrease by one when we meet a "}". </p>

<p>References <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#ru-SkipBlock">ParserThread::SkipBlock()</a>, and <a class="el" href="classParserThread#zh-SkipToOneOfChars">ParserThread::SkipToOneOfChars()</a>.</p>

</div>
</div>
<a class="anchor" id="qi-GetPreprocessorType"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tokenizer_8h#ck-PreprocessorType">PreprocessorType</a> Tokenizer::GetPreprocessorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current conditional preprocessor type. </p>

<p>References <a class="el" href="namespaceTokenizerConsts#qb-kw_define">TokenizerConsts::kw_define()</a>, <a class="el" href="namespaceTokenizerConsts#p2-kw_elif">TokenizerConsts::kw_elif()</a>, <a class="el" href="namespaceTokenizerConsts#js-kw_elifdef">TokenizerConsts::kw_elifdef()</a>, <a class="el" href="namespaceTokenizerConsts#yp-kw_elifndef">TokenizerConsts::kw_elifndef()</a>, <a class="el" href="namespaceTokenizerConsts#jp-kw_else">TokenizerConsts::kw_else()</a>, <a class="el" href="namespaceTokenizerConsts#zc-kw_endif">TokenizerConsts::kw_endif()</a>, <a class="el" href="namespaceTokenizerConsts#sk-kw_if">TokenizerConsts::kw_if()</a>, <a class="el" href="namespaceTokenizerConsts#tt-kw_ifdef">TokenizerConsts::kw_ifdef()</a>, <a class="el" href="namespaceTokenizerConsts#kt-kw_ifndef">TokenizerConsts::kw_ifndef()</a>, <a class="el" href="namespaceTokenizerConsts#co-kw_undef">TokenizerConsts::kw_undef()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#ab-m_Lex">m_Lex</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptDefine">ptDefine</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElif">ptElif</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElifdef">ptElifdef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElifndef">ptElifndef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElse">ptElse</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptEndif">ptEndif</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIf">ptIf</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIfdef">ptIfdef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIfndef">ptIfndef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptOthers">ptOthers</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptUndef">ptUndef</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, and <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#z9-SkipPreprocessorBranch">SkipPreprocessorBranch()</a>.</p>

</div>
</div>
<a class="anchor" id="kr-GetState"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a> Tokenizer::GetState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the skipping options value, see TokenizerState for more details. </p>

<p>References <a class="el" href="classTokenizer#xa-m_State">m_State</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">ParserThread::CalcEnumExpression()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">ParserThread::GetTemplateArgs()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#pl-SkipAngleBraces">ParserThread::SkipAngleBraces()</a>, and <a class="el" href="classParserThread#ru-SkipBlock">ParserThread::SkipBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="p4-GetToken"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::GetToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consume and return the current token string. </p>

<p>References <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#ve-m_PeekAvailable">m_PeekAvailable</a>, <a class="el" href="classTokenizer#oj-m_PeekLineNumber">m_PeekLineNumber</a>, <a class="el" href="classTokenizer#fy-m_PeekNestLevel">m_PeekNestLevel</a>, <a class="el" href="classTokenizer#xt-m_PeekToken">m_PeekToken</a>, <a class="el" href="classTokenizer#o1-m_PeekTokenIndex">m_PeekTokenIndex</a>, <a class="el" href="classTokenizer#xa-m_State">m_State</a>, <a class="el" href="classTokenizer#in-m_Token">m_Token</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a>, <a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a>, <a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a>, <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsRawExpression">tsRawExpression</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">ParserThread::CalcEnumExpression()</a>, <a class="el" href="classNativeParserBase#aa-ComputeCallTip">NativeParserBase::ComputeCallTip()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">ParserThread::GetTemplateArgs()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">ParserThread::HandleConditionalArguments()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">ParserThread::HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">ParserThread::HandleFunction()</a>, <a class="el" href="classParserThread#ky-HandleIncludes">ParserThread::HandleIncludes()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">ParserThread::HandleNamespace()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">ParserThread::HandleTypedef()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParserThread::ParseBufferForUsingNamespace()</a>, <a class="el" href="classParserThread#it-ReadAngleBrackets">ParserThread::ReadAngleBrackets()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ParserThread::ReadClsNames()</a>, <a class="el" href="classParserThread#p3-ReadVarNames">ParserThread::ReadVarNames()</a>, <a class="el" href="classParserThread#pl-SkipAngleBraces">ParserThread::SkipAngleBraces()</a>, <a class="el" href="classParserThread#ru-SkipBlock">ParserThread::SkipBlock()</a>, and <a class="el" href="classParserThread#zh-SkipToOneOfChars">ParserThread::SkipToOneOfChars()</a>.</p>

</div>
</div>
<a class="anchor" id="v8-HandleConditionPreprocessor"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::HandleConditionPreprocessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="tokenizer_8h#ck-PreprocessorType">PreprocessorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle the preprocessor directive: #ifdef XXX or #endif or #if or #elif or... </p>
<p>If conditional preprocessor handles correctly, return true, otherwise return false. </p>

<p>References <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#bm-HandleDefines">HandleDefines()</a>, <a class="el" href="classTokenizer#us-HandleUndefs">HandleUndefs()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#x8-m_ExpressionResult">m_ExpressionResult</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#tn-m_SavedLineNumber">m_SavedLineNumber</a>, <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>, <a class="el" href="classTokenizer#n3-m_SavedTokenIndex">m_SavedTokenIndex</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#xt-m_TokenizerOptions">m_TokenizerOptions</a>, <a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a>, <a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a>, <a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptDefine">ptDefine</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElif">ptElif</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElifdef">ptElifdef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElifndef">ptElifndef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElse">ptElse</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptEndif">ptEndif</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIf">ptIf</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIfdef">ptIfdef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIfndef">ptIfndef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptOthers">ptOthers</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptUndef">ptUndef</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>, and <a class="el" href="tokenizer_8h#vj-wantPreprocessor">TokenizerOptions::wantPreprocessor</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#z9-SkipPreprocessorBranch">SkipPreprocessorBranch()</a>.</p>

</div>
</div>
<a class="anchor" id="bm-HandleDefines"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::HandleDefines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle the statement: #define XXXXX </p>

<p>References <a class="el" href="classTokenizer#bp-AddMacroDefinition">AddMacroDefinition()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">GetLineNumber()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#ab-m_Lex">m_Lex</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, and <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="us-HandleUndefs"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::HandleUndefs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle the statement: #undef XXXXX </p>

<p>References <a class="el" href="classTokenTree#ud-erase">TokenTree::erase()</a>, <a class="el" href="logmanager_8h#ug-F">F()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>, <a class="el" href="classTokenizer#ab-m_Lex">m_Lex</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="zq-Init"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::Init </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>wxEmptyString</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoaderBase">LoaderBase</a> *&#160;</td>
          <td class="paramname"><em>loader</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the buffer by opening a file through a loader, this function copy the contents from the loader's buffer to its own buffer, so after that, we can safely delete the loader after this function call. </p>

<p>References <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenTree#gi-GetFileIndex">TokenTree::GetFileIndex()</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#fn-m_FileIdx">m_FileIdx</a>, <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>, <a class="el" href="classTokenizer#hj-m_IsOK">m_IsOK</a>, <a class="el" href="classTokenizer#ky-m_Loader">m_Loader</a>, <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#ey-ReadFile">ReadFile()</a>, <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>, <a class="el" href="tokenizer_8cpp#td-TRACE2">TRACE2</a>, and <a class="el" href="tokenizer_8cpp#nm-TRACE2_SET_FLAG">TRACE2_SET_FLAG</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#fc-InitTokenizer">ParserThread::InitTokenizer()</a>, and <a class="el" href="classTokenizer#lo-Tokenizer">Tokenizer()</a>.</p>

</div>
</div>
<a class="anchor" id="jo-InitFromBuffer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::InitFromBuffer </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>fileOfBuffer</em> = <code>wxEmptyString</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initLineNumber</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the buffer by directly using a wxString's content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initLineNumber</td><td>the start line of the buffer, usually the parser try to parse a function body, so the line information of each local variable tokens are correct. </td></tr>
    <tr><td class="paramname">buffer</td><td>text content used for parsing </td></tr>
    <tr><td class="paramname">fileOfBuffer</td><td>the file name where the buffer come from. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenTree#gi-GetFileIndex">TokenTree::GetFileIndex()</a>, <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#fn-m_FileIdx">m_FileIdx</a>, <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>, <a class="el" href="classTokenizer#hj-m_IsOK">m_IsOK</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, and <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#aa-ComputeCallTip">NativeParserBase::ComputeCallTip()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">ParserThread::HandleConditionalArguments()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">ParserThread::HandleForLoopArguments()</a>, <a class="el" href="classParserThread#fc-InitTokenizer">ParserThread::InitTokenizer()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParserThread::ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="se-IsBackslashBeforeEOL"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::IsBackslashBeforeEOL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the previous char before EOL is a backslash, call this function in the condition that the CurrentChar is '<br />
', here we have two cases: </p>
<div class="fragment"><div class="line">......\ \ \r \n......</div>
<div class="line">              ^--current char, <span class="keyword">this</span> is DOS style EOL</div>
<div class="line">......\ \ \n......</div>
<div class="line">           ^--current char, <span class="keyword">this</span> is Linux style EOL</div>
</div><!-- fragment --> 
<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, and <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, and <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>.</p>

</div>
</div>
<a class="anchor" id="x9-IsEOF"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::IsEOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> reaches the end of the buffer (file) </p>

<p>References <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd()</a>, and <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="vg-IsEscapedChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::IsEscapedChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the current character is a C-Escape character in a string. </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, and <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd()</a>.</p>

</div>
</div>
<a class="anchor" id="wz-IsMacroDefined"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::IsMacroDefined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the next token string is macro usage, return true. </p>

<p>References <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#ab-m_Lex">m_Lex</a>, <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, and <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, and <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="f2-IsOK"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::IsOK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the buffer is correctly loaded, this function return true. </p>

<p>References <a class="el" href="classTokenizer#hj-m_IsOK">m_IsOK</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#te-Parse">ParserThread::Parse()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParserThread::ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="je-KMP_Find"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tokenizer::KMP_Find </td>
          <td>(</td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>patternLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>KMP find, get the first position, if find nothing, return -1 <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm</a>. </p>

<p>References <a class="el" href="classTokenizer#dc-KMP_GetNextVal">KMP_GetNextVal()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#ow-GetFirstTokenPosition">GetFirstTokenPosition()</a>.</p>

</div>
</div>
<a class="anchor" id="dc-KMP_GetNextVal"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::KMP_GetNextVal </td>
          <td>(</td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just for KMP find. </p>

<p>Referenced by <a class="el" href="classTokenizer#je-KMP_Find">KMP_Find()</a>.</p>

</div>
</div>
<a class="anchor" id="xx-Lex"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::Lex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function only move the m_TokenIndex and get a lexeme and store it in m_Lex, the m_Lex will be further checked if it is a macro usage or not. </p>
<dl class="section return"><dt>Returns</dt><dd>true if it is an identifier like token. note we need to check an identifier like token is a macro usage. </dd></dl>

<p>References <a class="el" href="classTokenizer#oc-CharInString">CharInString()</a>, <a class="el" href="namespaceTokenizerConsts#a9-colon">TokenizerConsts::colon()</a>, <a class="el" href="namespaceTokenizerConsts#kp-colon_colon">TokenizerConsts::colon_colon()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="namespaceTokenizerConsts#yv-equal">TokenizerConsts::equal()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#je-m_ExpandedMacros">m_ExpandedMacros</a>, <a class="el" href="classTokenizer#ab-m_Lex">m_Lex</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, and <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#bm-HandleDefines">HandleDefines()</a>, <a class="el" href="classTokenizer#us-HandleUndefs">HandleUndefs()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="op-MoveToNextChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::MoveToNextChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move to the next character in the buffer. </p>

<p>References <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, and <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, <a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="k0-NextChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxChar Tokenizer::NextChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return (peek) the next character. </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, and <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="c2-NotEOF"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::NotEOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return true if it is Not the end of buffer </p>

<p>References <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParserThread::ParseBufferForUsingNamespace()</a>, <a class="el" href="classParserThread#it-ReadAngleBrackets">ParserThread::ReadAngleBrackets()</a>, <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="pm-PeekToken"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::PeekToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a "look ahead", and return the next token string. </p>

<p>References <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#ve-m_PeekAvailable">m_PeekAvailable</a>, <a class="el" href="classTokenizer#oj-m_PeekLineNumber">m_PeekLineNumber</a>, <a class="el" href="classTokenizer#fy-m_PeekNestLevel">m_PeekNestLevel</a>, <a class="el" href="classTokenizer#xt-m_PeekToken">m_PeekToken</a>, <a class="el" href="classTokenizer#o1-m_PeekTokenIndex">m_PeekTokenIndex</a>, <a class="el" href="classTokenizer#tn-m_SavedLineNumber">m_SavedLineNumber</a>, <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>, <a class="el" href="classTokenizer#n3-m_SavedTokenIndex">m_SavedTokenIndex</a>, <a class="el" href="classTokenizer#xa-m_State">m_State</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsRawExpression">tsRawExpression</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#aa-ComputeCallTip">NativeParserBase::ComputeCallTip()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">ParserThread::HandleConditionalArguments()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">ParserThread::HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">ParserThread::HandleFunction()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">ParserThread::HandleNamespace()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">ParserThread::HandleTypedef()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParserThread::ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="lf-PreviousChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxChar Tokenizer::PreviousChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return (peek) the previous character. </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar()</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, and <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>.</p>

</div>
</div>
<a class="anchor" id="ey-ReadFile"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::ReadFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a file, and fill the m_Buffer. </p>

<p>References <a class="el" href="globals_8h#ss-cbRead">cbRead()</a>, <a class="el" href="classLoaderBase#xn-FileName">LoaderBase::FileName()</a>, <a class="el" href="classLoaderBase#d3-GetData">LoaderBase::GetData()</a>, <a class="el" href="classLoaderBase#es-GetLength">LoaderBase::GetLength()</a>, <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>, and <a class="el" href="classTokenizer#ky-m_Loader">m_Loader</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#zq-Init">Init()</a>.</p>

</div>
</div>
<a class="anchor" id="zl-ReadParentheses"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::ReadParentheses </td>
          <td>(</td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a string from '(' to ')', note that inner parentheses considered </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the returned string </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, and <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, and <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>.</p>

</div>
</div>
<a class="anchor" id="po-ReadToEOL"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::ReadToEOL </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stripUnneeded</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the string from the current position to the end of current line, in most case, this function is used in handling #define, use with care outside this class! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stripUnneeded</td><td>true if you are going to remove comments and compression spaces(two or more spaces should become one space) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#g5-m_ReadingMacroDefinition">m_ReadingMacroDefinition</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#bm-HandleDefines">HandleDefines()</a>.</p>

</div>
</div>
<a class="anchor" id="i3-ReplaceBufferText"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::ReplaceBufferText </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>macro</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backward buffer replacement for re-parsing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the new text going to replace some text on the m_Buffer </td></tr>
    <tr><td class="paramname">macro</td><td>if it is a macro expansion, we need to remember the referenced(used) macro token so that we can avoid the recursive macro expansion such as the below code: <div class="fragment"><div class="line"><span class="preprocessor">#define X Y</span></div>
<div class="line"><span class="preprocessor">#define Y X</span></div>
<div class="line"><span class="preprocessor">int X;</span></div>
</div><!-- fragment --> <a href="http://forums.codeblocks.org/index.php/topic,13384.msg90391.html#msg90391">http://forums.codeblocks.org/index.php/topic,13384.msg90391.html#msg90391</a></td></tr>
  </table>
  </dd>
</dl>
<p>Macro expansion is just replace some characters in the m_Buffer. </p><div class="fragment"><div class="line">xxxxxxxxxAAAA(u,v)yyyyyyyyy</div>
<div class="line">                  ^------ <a class="code" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a> (anchor point)</div>
</div><!-- fragment --><p> For example, the above is a wxChar Array(m_Buffer), a macro usage "AAAA(u,v)" is detected and need to expanded. We just do a "backward" text replace here. Before replacement, m_TokenIndex points to the next char of ")" in "AAAA(u,v)"(We say it as an anchor point). After replacement, the new buffer becomes: </p><div class="fragment"><div class="line">xxxNNNNNNNNNNNNNNNyyyyyyyyy</div>
<div class="line">   ^ &lt;----------- ^</div>
<div class="line">   <a class="code" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a> was moved backward</div>
</div><!-- fragment --><p> Note that "NNNNNNNNNNNNNNN" is the expanded new text. The m_TokenIndex was moved backward to the beginning of the new added text. If the new text is small enough, then m_Buffer's length do not need to increase. The situation when our m_Buffer's length need to be increased is that the new text is too long, so the buffer before "anchor point" can not hold the new text, this way, m_Buffer's length will adjusted. like below:</p>
<p>NNNNNNNNNNNNNNNNNNNNNNyyyyyyyyy ^&mdash;m_TokenIndex </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="structTokenizer_1_1ExpandedMacro#pa-m_End">Tokenizer::ExpandedMacro::m_End</a>, <a class="el" href="classTokenizer#je-m_ExpandedMacros">m_ExpandedMacros</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="structTokenizer_1_1ExpandedMacro#r1-m_Macro">Tokenizer::ExpandedMacro::m_Macro</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#ve-m_PeekAvailable">m_PeekAvailable</a>, <a class="el" href="classTokenizer#tn-m_SavedLineNumber">m_SavedLineNumber</a>, <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>, <a class="el" href="classTokenizer#n3-m_SavedTokenIndex">m_SavedTokenIndex</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a>, <a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a>, <a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a>, <a class="el" href="tokenizer_8cpp#tg-s_MaxMacroReplaceDepth">s_MaxMacroReplaceDepth</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#jw-GetMacroExpandedText">GetMacroExpandedText()</a>, and <a class="el" href="classTokenizer#v8-ReplaceMacroUsage">ReplaceMacroUsage()</a>.</p>

</div>
</div>
<a class="anchor" id="v8-ReplaceMacroUsage"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::ReplaceMacroUsage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>tk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get expanded text for the current macro usage, then replace buffer for re-parsing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tk</td><td>the macro definition token </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if macro expansion successes, thus buffer is really changed and m_TokenIndex moved backward a bit, and peek status get cleared Both the function like macro or variable like macro usage can be handled in this function. </dd></dl>

<p>References <a class="el" href="classTokenizer#jw-GetMacroExpandedText">GetMacroExpandedText()</a>, <a class="el" href="classTokenizer#je-m_ExpandedMacros">m_ExpandedMacros</a>, and <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#oa-CheckMacroUsageAndReplace">CheckMacroUsageAndReplace()</a>.</p>

</div>
</div>
<a class="anchor" id="jt-RestoreNestingLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::RestoreNestingLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore the brace level. </p>

<p>References <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, and <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>.</p>

</div>
</div>
<a class="anchor" id="li-SaveNestingLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SaveNestingLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save the brace "{" level, the parser might need to ignore the nesting level in some cases. </p>

<p>References <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, and <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>.</p>

</div>
</div>
<a class="anchor" id="d7-SetLastTokenIdx"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SetLastTokenIdx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tokenIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> is added, associate doxygen style documents(comments before the variables) to the <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> </p>

<p>References <a class="el" href="classTokenTree#fi-AppendDocumentation">TokenTree::AppendDocumentation()</a>, <a class="el" href="classTokenizer#x8-m_ExpressionResult">m_ExpressionResult</a>, <a class="el" href="classTokenizer#fn-m_FileIdx">m_FileIdx</a>, <a class="el" href="classTokenizer#cy-m_LastTokenIdx">m_LastTokenIdx</a>, <a class="el" href="classTokenizer#i9-m_NextTokenDoc">m_NextTokenDoc</a>, and <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">ParserThread::DoAddToken()</a>.</p>

</div>
</div>
<a class="anchor" id="no-SetState"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SetState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> skipping options. </p>
<p>E.g. sometimes, we need to skip the statement after "=", but sometimes, we should disable this options, see more details on TokenizerState. </p>

<p>References <a class="el" href="classTokenizer#xa-m_State">m_State</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">ParserThread::CalcEnumExpression()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">ParserThread::GetTemplateArgs()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">ParserThread::HandleNamespace()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, <a class="el" href="classParserThread#pl-SkipAngleBraces">ParserThread::SkipAngleBraces()</a>, and <a class="el" href="classParserThread#ru-SkipBlock">ParserThread::SkipBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="uv-SetTokenizerOption"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SetTokenizerOption </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wantPreprocessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>storeDocumentation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle condition preprocessor and store documentation or not. </p>

<p>References <a class="el" href="classTokenizer#xt-m_TokenizerOptions">m_TokenizerOptions</a>, <a class="el" href="tokenizer_8h#ru-storeDocumentation">TokenizerOptions::storeDocumentation</a>, and <a class="el" href="tokenizer_8h#vj-wantPreprocessor">TokenizerOptions::wantPreprocessor</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#kb-ParserThread">ParserThread::ParserThread()</a>.</p>

</div>
</div>
<a class="anchor" id="eo-SkipComment"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipComment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip the C/C++ comment. </p>
<dl class="section return"><dt>Returns</dt><dd>true if we do move m_TokenIndex When C comment is handled, m_TokenIndex point to the char AFTER the '/' When C++ comment is handled, m_TokenIndex point to '<br />
' </dd></dl>
<p>valid documents</p>
<p>invalid documents</p>

<p>References <a class="el" href="classTokenTree#fi-AppendDocumentation">TokenTree::AppendDocumentation()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#x8-m_ExpressionResult">m_ExpressionResult</a>, <a class="el" href="classTokenizer#fn-m_FileIdx">m_FileIdx</a>, <a class="el" href="classTokenizer#cy-m_LastTokenIdx">m_LastTokenIdx</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#i9-m_NextTokenDoc">m_NextTokenDoc</a>, <a class="el" href="classTokenizer#g5-m_ReadingMacroDefinition">m_ReadingMacroDefinition</a>, <a class="el" href="classTokenizer#xt-m_TokenizerOptions">m_TokenizerOptions</a>, <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, <a class="el" href="tokenizer_8h#ru-storeDocumentation">TokenizerOptions::storeDocumentation</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#bm-HandleDefines">HandleDefines()</a>, <a class="el" href="classTokenizer#us-HandleUndefs">HandleUndefs()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="z9-SkipPreprocessorBranch"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipPreprocessorBranch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip the C preprocessor directive, such as #ifdef xxxx only the conditional preprocessor directives are handled here, the others such as #include or #warning and all kinds of ptOthers will passed to Parserthread class. </p>
<dl class="section return"><dt>Returns</dt><dd>true if we do move m_TokenIndex </dd></dl>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, and <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptOthers">ptOthers</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>.</p>

</div>
</div>
<a class="anchor" id="ah-SkipString"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip the string literal(enclosed in double quotes) or character literal(enclosed in single quotes). </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, and <a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, and <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="xn-SkipToChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipToChar </td>
          <td>(</td>
          <td class="paramtype">const wxChar &amp;&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip character until we meet a ch. </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, and <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, and <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>.</p>

</div>
</div>
<a class="anchor" id="h4-SkipToEndConditionPreprocesso"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SkipToEndConditionPreprocessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip to the #endif conditional preprocessor directive. </p>
<p>for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#if 1</span></div>
<div class="line">  <span class="comment">// active statements</span></div>
<div class="line"><span class="preprocessor">#elif x</span></div>
<div class="line">  <span class="comment">// skipped statements</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// skipped statements</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> if we see a "#if 1" branch we need to skip the next two branches, and go to "#endif" </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, and <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, and <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="l2-SkipToEOL"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipToEOL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip from the current position to the end of line. </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#us-HandleUndefs">HandleUndefs()</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, and <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="e2-SkipToInlineCommentEnd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipToInlineCommentEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip to then end of the C++ style comment. </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="u0-SkipToNextConditionPreprocess"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SkipToNextConditionPreprocessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip to the next conditional preprocessor directive branch. </p>
<p>for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#if 0</span></div>
<div class="line">  <span class="comment">// skipped statements</span></div>
<div class="line"><span class="preprocessor">#elif 0</span></div>
<div class="line">  <span class="comment">// skipped statements</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// active statements</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> if we see a "#if 0", we need to jump to the next "#elif xxx" </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, and <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="js-SkipToStringEnd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipToStringEnd </td>
          <td>(</td>
          <td class="paramtype">const wxChar &amp;&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move to the end of string literal or character literal, the m_TokenIndex will at the closing quote character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>is a character either double quote or single quote </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we reach the closing quote character </dd></dl>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar()</a>, and <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>.</p>

</div>
</div>
<a class="anchor" id="nb-SkipUnwanted"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipUnwanted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>skips comments, spaces, preprocessor branch. </p>

<p>References <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#z9-SkipPreprocessorBranch">SkipPreprocessorBranch()</a>, and <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, and <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>.</p>

</div>
</div>
<a class="anchor" id="vm-SkipWhiteSpace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipWhiteSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip any "tab" "white-space". </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, and <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#bm-HandleDefines">HandleDefines()</a>, <a class="el" href="classTokenizer#us-HandleUndefs">HandleUndefs()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="ew-SplitArguments"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SplitArguments </td>
          <td>(</td>
          <td class="paramtype">wxArrayString &amp;&#160;</td>
          <td class="paramname"><em>results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the macro arguments, and store them in results, when calling this function, we expect that m_TokenIndex point to the opening '(', or some spaces before the opening '('. </p>
<p>such as below </p><div class="fragment"><div class="line">..... ABC  ( xxx, yyy ) zzz .....</div>
<div class="line">         ^--------<a class="code" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>in the above example, the result contains two items (xxx and yyy) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if arguments (the parenthesis) are not found. </dd></dl>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#ab-m_Lex">m_Lex</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#xa-m_State">m_State</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsRawExpression">tsRawExpression</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#jw-GetMacroExpandedText">GetMacroExpandedText()</a>.</p>

</div>
</div>
<a class="anchor" id="jv-UngetToken"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::UngetToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the GetToken. </p>

<p>References <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#ve-m_PeekAvailable">m_PeekAvailable</a>, <a class="el" href="classTokenizer#oj-m_PeekLineNumber">m_PeekLineNumber</a>, <a class="el" href="classTokenizer#fy-m_PeekNestLevel">m_PeekNestLevel</a>, <a class="el" href="classTokenizer#xt-m_PeekToken">m_PeekToken</a>, <a class="el" href="classTokenizer#o1-m_PeekTokenIndex">m_PeekTokenIndex</a>, <a class="el" href="classTokenizer#in-m_Token">m_Token</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a>, <a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a>, and <a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">ParserThread::CalcEnumExpression()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">ParserThread::GetTemplateArgs()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#oq-HandleFunction">ParserThread::HandleFunction()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">ParserThread::HandleTypedef()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ParserThread::ReadClsNames()</a>, and <a class="el" href="classParserThread#pl-SkipAngleBraces">ParserThread::SkipAngleBraces()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="g5-m_Buffer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::m_Buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer content, all the lexical analysis is done on this. </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#ey-ReadFile">ReadFile()</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, and <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>.</p>

</div>
</div>
<a class="anchor" id="k5-m_BufferLen"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_BufferLen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer length. </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#zq-Init">Init()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar()</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#ey-ReadFile">ReadFile()</a>, and <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>.</p>

</div>
</div>
<a class="anchor" id="je-m_ExpandedMacros"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="structTokenizer_1_1ExpandedMacro">ExpandedMacro</a>&gt; Tokenizer::m_ExpandedMacros</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this serves as a macro replacement stack, in the above example, if AAA is replaced by BBBB, we store the macro definition of AAA in the m_ExpandedMacros, and if BBBB is also defined as </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BBBB CCC + DDD</span></div>
<div class="line"><span class="preprocessor">#define CCC 1</span></div>
<div class="line"></div>
<div class="line">When expanding BBBB, the <span class="keyword">new</span> <a class="code" href="classTokenizer#g5-m_Buffer">m_Buffer</a> becomes</div>
<div class="line"></div>
<div class="line">....CCC + DDD..................[EOF]</div>
<div class="line">    ^</div>
<div class="line">here, <a class="code" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a> is moved back to the beginning of CCC, and you have the macro replacement</div>
<div class="line">stack <a class="code" href="classTokenizer#je-m_ExpandedMacros">m_ExpandedMacros</a> like below</div>
<div class="line"></div>
<div class="line"> The stack becomes</div>
<div class="line"> top -&gt; macro BBBB</div>
<div class="line">     -&gt; macro AAA</div>
<div class="line"></div>
<div class="line">next, <span class="keywordflow">if</span> CCC is expand to 1, you have <span class="keyword">this</span></div>
<div class="line"></div>
<div class="line">......1 + DDD..................[EOF]</div>
<div class="line">      ^</div>
<div class="line"> The stack becomes</div>
<div class="line"> top -&gt; macro CCC</div>
<div class="line">     -&gt; macro BBBB</div>
<div class="line">     -&gt; macro AAA</div>
</div><!-- fragment --><p> if 1 is parsed, and we get a next token '+', the CCC in the top is popped.</p>
<p>when we try to expand a macro usage, we can look up in the stack to see whether the macro is already used. C preprocessor don't allow recursively expand a same macro twice. since std::stack does not allow us to loop all its elements, we use std::list. </p>

<p>Referenced by <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>, and <a class="el" href="classTokenizer#v8-ReplaceMacroUsage">ReplaceMacroUsage()</a>.</p>

</div>
</div>
<a class="anchor" id="x8-m_ExpressionResult"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt;bool&gt; Tokenizer::m_ExpressionResult</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>preprocessor branch stack, if we meet a #if 1, then the value true will be pushed to to the stack, if we skip the #endif, the true value should be popped. </p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#d7-SetLastTokenIdx">SetLastTokenIdx()</a>, and <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="fn-m_FileIdx"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_FileIdx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File index, useful when parsing documentation;. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTokenizer#eo-SkipComment" title="Skip the C/C++ comment. ">SkipComment</a> </dd></dl>

<p>Referenced by <a class="el" href="classTokenizer#bp-AddMacroDefinition">AddMacroDefinition()</a>, <a class="el" href="classTokenizer#zq-Init">Init()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, <a class="el" href="classTokenizer#d7-SetLastTokenIdx">SetLastTokenIdx()</a>, and <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="jr-m_Filename"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::m_Filename</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filename of the buffer. </p>

<p>Referenced by <a class="el" href="classTokenizer#rn-GetFilename">GetFilename()</a>, <a class="el" href="classTokenizer#us-HandleUndefs">HandleUndefs()</a>, <a class="el" href="classTokenizer#zq-Init">Init()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, <a class="el" href="classTokenizer#ey-ReadFile">ReadFile()</a>, and <a class="el" href="classTokenizer#lo-Tokenizer">Tokenizer()</a>.</p>

</div>
</div>
<a class="anchor" id="hj-m_IsOK"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::m_IsOK</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bool variable specifies whether the buffer is ready for parsing </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#zq-Init">Init()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, and <a class="el" href="classTokenizer#f2-IsOK">IsOK()</a>.</p>

</div>
</div>
<a class="anchor" id="cy-m_LastTokenIdx"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Tokenizer::m_LastTokenIdx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>store the recent added token index for example, here is a comment </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> aaa; <span class="comment">//!&lt; description of aaa</span></div>
</div><!-- fragment --><p> the token "aaa" is added to the token tree before reading the description. After that the token index is stored, and later if we read the "description of aaa", we will attach the document to the token </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#d7-SetLastTokenIdx">SetLastTokenIdx()</a>, and <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="ab-m_Lex"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::m_Lex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a lexeme string return by the <a class="el" href="classTokenizer#xx-Lex" title="this function only move the m_TokenIndex and get a lexeme and store it in m_Lex, the m_Lex will be fu...">Lex()</a> function, this is a candidate token string, but may be replaced if it is a macro usage </p>

<p>Referenced by <a class="el" href="classTokenizer#oa-CheckMacroUsageAndReplace">CheckMacroUsageAndReplace()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#jw-GetMacroExpandedText">GetMacroExpandedText()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#bm-HandleDefines">HandleDefines()</a>, <a class="el" href="classTokenizer#us-HandleUndefs">HandleUndefs()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="ko-m_LineNumber"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_LineNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>line offset in buffer, please note that it is 1 based, not 0 based </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">GetLineNumber()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#us-HandleUndefs">HandleUndefs()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#l2-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="ky-m_Loader"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoaderBase">LoaderBase</a>* Tokenizer::m_Loader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File loader. </p>

<p>Referenced by <a class="el" href="classTokenizer#zq-Init">Init()</a>, and <a class="el" href="classTokenizer#ey-ReadFile">ReadFile()</a>.</p>

</div>
</div>
<a class="anchor" id="ru-m_NestLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_NestLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>keep track of block nesting { } </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#el-GetNestingLevel">GetNestingLevel()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>, <a class="el" href="classTokenizer#jt-RestoreNestingLevel">RestoreNestingLevel()</a>, <a class="el" href="classTokenizer#li-SaveNestingLevel">SaveNestingLevel()</a>, <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="i9-m_NextTokenDoc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::m_NextTokenDoc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normally, this record the doxygen style comments for the next token definition for example, here is a comment </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> aaa;</div>
</div><!-- fragment --><p> Then, the "description of aaa" is stored in this variable when the token "aaa" is added to the <a class="el" href="classTokenTree" title="a container class to hold all the Tokens getting from parsing stage ">TokenTree</a>, it will associate the documen and token </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#d7-SetLastTokenIdx">SetLastTokenIdx()</a>, and <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="ve-m_PeekAvailable"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::m_PeekAvailable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek token information. </p>

<p>Referenced by <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="oj-m_PeekLineNumber"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_PeekLineNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="fy-m_PeekNestLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_PeekNestLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="xt-m_PeekToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::m_PeekToken</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="o1-m_PeekTokenIndex"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_PeekTokenIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="g5-m_ReadingMacroDefinition"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::m_ReadingMacroDefinition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicates whether we are reading the macro definition This variable will affect how the doxygen comments will be associated to the <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTokenizer#eo-SkipComment" title="Skip the C/C++ comment. ">Tokenizer::SkipComment</a> for details </dd></dl>

<p>Referenced by <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, and <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="tn-m_SavedLineNumber"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_SavedLineNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>.</p>

</div>
</div>
<a class="anchor" id="mi-m_SavedNestingLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_SavedNestingLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>, <a class="el" href="classTokenizer#jt-RestoreNestingLevel">RestoreNestingLevel()</a>, and <a class="el" href="classTokenizer#li-SaveNestingLevel">SaveNestingLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="n3-m_SavedTokenIndex"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_SavedTokenIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saved token info (for <a class="el" href="classTokenizer#pm-PeekToken" title="Do a &quot;look ahead&quot;, and return the next token string. ">PeekToken()</a>), m_TokenIndex will be moved forward or backward when either <a class="el" href="classTokenizer#nr-DoGetToken" title="Do the actual lexical analysis, both GetToken() and PeekToken() will internally call this function...">DoGetToken()</a> or <a class="el" href="classTokenizer#nb-SkipUnwanted" title="skips comments, spaces, preprocessor branch. ">SkipUnwanted()</a> is called, so we should save m_TokenIndex before it get modified. </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>.</p>

</div>
</div>
<a class="anchor" id="xa-m_State"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a> Tokenizer::m_State</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tokeniser state specifies the skipping option. </p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#kr-GetState">GetState()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, <a class="el" href="classTokenizer#no-SetState">SetState()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="in-m_Token"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::m_Token</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These variables define the current token string and its auxiliary information, such as the token name, the line number of the token, the current brace nest level. </p>
<p>token name </p>

<p>Referenced by <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="c8-m_TokenIndex"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_TokenIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>index offset in buffer, when parsing a buffer </p>
<div class="fragment"><div class="line">....... <span class="keyword">namespace </span><a class="code" href="namespacestd">std</a> { <span class="keywordtype">int</span> a; .......</div>
<div class="line">                     ^ --- <a class="code" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="code" href="classTokenizer#in-m_Token">m_Token</a> = <span class="stringliteral">&quot;std&quot;</span></div>
</div><!-- fragment --><p> m_TokenIndex always points to the next character of a valid token, in the above example, it points to the space after "std". </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#mc-CurrentCharMoveNext">CurrentCharMoveNext()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar()</a>, <a class="el" href="classTokenizer#xx-Lex">Lex()</a>, <a class="el" href="classTokenizer#op-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#po-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>, <a class="el" href="classTokenizer#z9-SkipPreprocessorBranch">SkipPreprocessorBranch()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="xt-m_TokenizerOptions"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tokenizer_8h#structTokenizerOptions">TokenizerOptions</a> Tokenizer::m_TokenizerOptions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> options specify the skipping option. </p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#uv-SetTokenizerOption">SetTokenizerOption()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, and <a class="el" href="classTokenizer#lo-Tokenizer">Tokenizer()</a>.</p>

</div>
</div>
<a class="anchor" id="ti-m_TokenTree"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTokenTree">TokenTree</a>* Tokenizer::m_TokenTree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> tree to store the macro definition </p>

<p>Referenced by <a class="el" href="classTokenizer#bp-AddMacroDefinition">AddMacroDefinition()</a>, <a class="el" href="classTokenizer#oa-CheckMacroUsageAndReplace">CheckMacroUsageAndReplace()</a>, <a class="el" href="classTokenizer#us-HandleUndefs">HandleUndefs()</a>, <a class="el" href="classTokenizer#zq-Init">Init()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#d7-SetLastTokenIdx">SetLastTokenIdx()</a>, and <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="ol-m_UndoLineNumber"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_UndoLineNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="n2-m_UndoNestLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_UndoNestLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="ky-m_UndoTokenIndex"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_UndoTokenIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backup the previous <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> information. </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#i3-ReplaceBufferText">ReplaceBufferText()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="tokenizer_8h_source">tokenizer.h</a></li>
<li><a class="el" href="tokenizer_8cpp">tokenizer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
