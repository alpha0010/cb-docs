<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Code::Blocks: Tokenizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Code::Blocks
   &#160;<span id="projectnumber">SVN r10345</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated"><span>Classes</span></a></li>
      <li><a href="files"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated"><span>Class&#160;List</span></a></li>
      <li><a href="classes"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classTokenizer-members">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Tokenizer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is just a simple lexer class.  
 <a href="classTokenizer#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tokenizer_8h_source">tokenizer.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Tokenizer:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTokenizer__coll__graph.svg" width="1767" height="2700"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:lo-Tokenizer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#lo-Tokenizer">Tokenizer</a> (<a class="el" href="classTokenTree">TokenTree</a> *tokenTree, const wxString &amp;filename=wxEmptyString)</td></tr>
<tr class="memdesc:lo-Tokenizer"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> constructor.  <a href="#lo-Tokenizer">More...</a><br /></td></tr>
<tr class="separator:lo-Tokenizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zb-Tokenizer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#zb-Tokenizer">~Tokenizer</a> ()</td></tr>
<tr class="memdesc:zb-Tokenizer"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> destructor.  <a href="#zb-Tokenizer">More...</a><br /></td></tr>
<tr class="separator:zb-Tokenizer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zq-Init"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#zq-Init">Init</a> (const wxString &amp;filename=wxEmptyString, <a class="el" href="classLoaderBase">LoaderBase</a> *loader=0)</td></tr>
<tr class="memdesc:zq-Init"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the buffer by opening a file through a loader, this function copy the contents from the loader's buffer to its own buffer, so after that, we can safely delete the loader after this function call.  <a href="#zq-Init">More...</a><br /></td></tr>
<tr class="separator:zq-Init"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jo-InitFromBuffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer</a> (const wxString &amp;buffer, const wxString &amp;fileOfBuffer=wxEmptyString, size_t initLineNumber=0)</td></tr>
<tr class="memdesc:jo-InitFromBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the buffer by directly using a wxString's content.  <a href="#jo-InitFromBuffer">More...</a><br /></td></tr>
<tr class="separator:jo-InitFromBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:p4-GetToken"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#p4-GetToken">GetToken</a> ()</td></tr>
<tr class="memdesc:p4-GetToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume and return the current token string.  <a href="#p4-GetToken">More...</a><br /></td></tr>
<tr class="separator:p4-GetToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pm-PeekToken"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#pm-PeekToken">PeekToken</a> ()</td></tr>
<tr class="memdesc:pm-PeekToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a "look ahead", and return the next token string.  <a href="#pm-PeekToken">More...</a><br /></td></tr>
<tr class="separator:pm-PeekToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jv-UngetToken"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jv-UngetToken">UngetToken</a> ()</td></tr>
<tr class="memdesc:jv-UngetToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the GetToken.  <a href="#jv-UngetToken">More...</a><br /></td></tr>
<tr class="separator:jv-UngetToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:uv-SetTokenizerOption"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#uv-SetTokenizerOption">SetTokenizerOption</a> (bool wantPreprocessor, bool storeDocumentation)</td></tr>
<tr class="memdesc:uv-SetTokenizerOption"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle condition preprocessor and store documentation or not.  <a href="#uv-SetTokenizerOption">More...</a><br /></td></tr>
<tr class="separator:uv-SetTokenizerOption"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:no-SetState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#no-SetState">SetState</a> (<a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a> state)</td></tr>
<tr class="memdesc:no-SetState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> skipping options.  <a href="#no-SetState">More...</a><br /></td></tr>
<tr class="separator:no-SetState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:kr-GetState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#kr-GetState">GetState</a> ()</td></tr>
<tr class="memdesc:kr-GetState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the skipping options value, see TokenizerState for more details.  <a href="#kr-GetState">More...</a><br /></td></tr>
<tr class="separator:kr-GetState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oz-IsSkippingUnwantedTokens"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#oz-IsSkippingUnwantedTokens">IsSkippingUnwantedTokens</a> () const </td></tr>
<tr class="memdesc:oz-IsSkippingUnwantedTokens"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking the TokenizerState.  <a href="#oz-IsSkippingUnwantedTokens">More...</a><br /></td></tr>
<tr class="separator:oz-IsSkippingUnwantedTokens"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rn-GetFilename"><td class="memItemLeft" align="right" valign="top">const wxString &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#rn-GetFilename">GetFilename</a> () const </td></tr>
<tr class="memdesc:rn-GetFilename"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the opened files name.  <a href="#rn-GetFilename">More...</a><br /></td></tr>
<tr class="separator:rn-GetFilename"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jr-GetLineNumber"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jr-GetLineNumber">GetLineNumber</a> () const </td></tr>
<tr class="memdesc:jr-GetLineNumber"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the line number of the current token string.  <a href="#jr-GetLineNumber">More...</a><br /></td></tr>
<tr class="separator:jr-GetLineNumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:el-GetNestingLevel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#el-GetNestingLevel">GetNestingLevel</a> () const </td></tr>
<tr class="memdesc:el-GetNestingLevel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the brace "{}" level.  <a href="#el-GetNestingLevel">More...</a><br /></td></tr>
<tr class="separator:el-GetNestingLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:li-SaveNestingLevel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#li-SaveNestingLevel">SaveNestingLevel</a> ()</td></tr>
<tr class="memdesc:li-SaveNestingLevel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the brace "{" level, the parser might need to ignore the nesting level in some cases.  <a href="#li-SaveNestingLevel">More...</a><br /></td></tr>
<tr class="separator:li-SaveNestingLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jt-RestoreNestingLevel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jt-RestoreNestingLevel">RestoreNestingLevel</a> ()</td></tr>
<tr class="memdesc:jt-RestoreNestingLevel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the brace level.  <a href="#jt-RestoreNestingLevel">More...</a><br /></td></tr>
<tr class="separator:jt-RestoreNestingLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:f2-IsOK"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#f2-IsOK">IsOK</a> () const </td></tr>
<tr class="memdesc:f2-IsOK"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the buffer is correctly loaded, this function return true.  <a href="#f2-IsOK">More...</a><br /></td></tr>
<tr class="separator:f2-IsOK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:j7-ReadToEOL"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL</a> (bool nestBraces=true, bool stripUnneeded=true)</td></tr>
<tr class="memdesc:j7-ReadToEOL"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the string from the current position to the end of current line, in most case, this function is used in handling #define, use with care outside this class!  <a href="#j7-ReadToEOL">More...</a><br /></td></tr>
<tr class="separator:j7-ReadToEOL"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:zl-ReadParentheses"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses</a> (wxString &amp;str)</td></tr>
<tr class="memdesc:zl-ReadParentheses"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a string from '(' to ')', note that inner parentheses considered  <a href="#zl-ReadParentheses">More...</a><br /></td></tr>
<tr class="separator:zl-ReadParentheses"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:hc-SkipToEOL"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL</a> (bool nestBraces=true)</td></tr>
<tr class="memdesc:hc-SkipToEOL"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip from the current position to the end of line.  <a href="#hc-SkipToEOL">More...</a><br /></td></tr>
<tr class="separator:hc-SkipToEOL"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:e2-SkipToInlineCommentEnd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd</a> ()</td></tr>
<tr class="memdesc:e2-SkipToInlineCommentEnd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip to then end of the C++ style comment.  <a href="#e2-SkipToInlineCommentEnd">More...</a><br /></td></tr>
<tr class="separator:e2-SkipToInlineCommentEnd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:x9-IsEOF"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#x9-IsEOF">IsEOF</a> () const </td></tr>
<tr class="memdesc:x9-IsEOF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> reaches the end of the buffer (file)  <a href="#x9-IsEOF">More...</a><br /></td></tr>
<tr class="separator:x9-IsEOF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:c2-NotEOF"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#c2-NotEOF">NotEOF</a> () const </td></tr>
<tr class="memdesc:c2-NotEOF"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if it is Not the end of buffer  <a href="#c2-NotEOF">More...</a><br /></td></tr>
<tr class="separator:c2-NotEOF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:hh-ReplaceBufferText"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText</a> (const wxString &amp;target)</td></tr>
<tr class="memdesc:hh-ReplaceBufferText"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward buffer replacement for re-parsing.  <a href="#hh-ReplaceBufferText">More...</a><br /></td></tr>
<tr class="separator:hh-ReplaceBufferText"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:v8-ReplaceMacroUsage"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#v8-ReplaceMacroUsage">ReplaceMacroUsage</a> (const <a class="el" href="classToken">Token</a> *tk)</td></tr>
<tr class="memdesc:v8-ReplaceMacroUsage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get expanded text for the current macro usage, then replace buffer for re-parsing.  <a href="#v8-ReplaceMacroUsage">More...</a><br /></td></tr>
<tr class="separator:v8-ReplaceMacroUsage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ma-GetFirstTokenPosition"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ma-GetFirstTokenPosition">GetFirstTokenPosition</a> (const wxString &amp;buffer, const wxString &amp;target)</td></tr>
<tr class="memdesc:ma-GetFirstTokenPosition"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first token position in buffer.  <a href="#ma-GetFirstTokenPosition">More...</a><br /></td></tr>
<tr class="separator:ma-GetFirstTokenPosition"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ow-GetFirstTokenPosition"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ow-GetFirstTokenPosition">GetFirstTokenPosition</a> (const wxChar *buffer, const size_t bufferLen, const wxChar *key, const size_t keyLen)</td></tr>
<tr class="memdesc:ow-GetFirstTokenPosition"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the sub-string key in the whole buffer, return the first position of the key  <a href="#ow-GetFirstTokenPosition">More...</a><br /></td></tr>
<tr class="separator:ow-GetFirstTokenPosition"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:je-KMP_Find"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#je-KMP_Find">KMP_Find</a> (const wxChar *text, const wxChar *pattern, const int patternLen)</td></tr>
<tr class="memdesc:je-KMP_Find"><td class="mdescLeft">&#160;</td><td class="mdescRight">KMP find, get the first position, if find nothing, return -1.  <a href="#je-KMP_Find">More...</a><br /></td></tr>
<tr class="separator:je-KMP_Find"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7-SetLastTokenIdx"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#d7-SetLastTokenIdx">SetLastTokenIdx</a> (int tokenIdx)</td></tr>
<tr class="memdesc:d7-SetLastTokenIdx"><td class="mdescLeft">&#160;</td><td class="mdescRight">a <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> is added, this function also add doxygen style document attached to the <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a>  <a href="#d7-SetLastTokenIdx">More...</a><br /></td></tr>
<tr class="separator:d7-SetLastTokenIdx"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ai-SetReplacementString"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ai-SetReplacementString">SetReplacementString</a> (const wxString &amp;from, const wxString &amp;to)</td></tr>
<tr class="memdesc:ai-SetReplacementString"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add one "replacement rule", this is just a simple way of defining a macro definition.  <a href="#ai-SetReplacementString">More...</a><br /></td></tr>
<tr class="separator:ai-SetReplacementString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lk-RemoveReplacementString"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#lk-RemoveReplacementString">RemoveReplacementString</a> (const wxString &amp;from)</td></tr>
<tr class="memdesc:lk-RemoveReplacementString"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a macro replacement rule.  <a href="#lk-RemoveReplacementString">More...</a><br /></td></tr>
<tr class="separator:lk-RemoveReplacementString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cx-GetTokenReplacementsMap"><td class="memItemLeft" align="right" valign="top">static wxStringHashMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#cx-GetTokenReplacementsMap">GetTokenReplacementsMap</a> ()</td></tr>
<tr class="memdesc:cx-GetTokenReplacementsMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the macro replacement map  <a href="#cx-GetTokenReplacementsMap">More...</a><br /></td></tr>
<tr class="separator:cx-GetTokenReplacementsMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:uk-ConvertToHashReplacementMap"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#uk-ConvertToHashReplacementMap">ConvertToHashReplacementMap</a> (const <a class="el" href="namespaceConfigManagerContainer#fj-StringToStringMap">ConfigManagerContainer::StringToStringMap</a> &amp;map)</td></tr>
<tr class="separator:uk-ConvertToHashReplacementMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ti-BaseInit"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ti-BaseInit">BaseInit</a> ()</td></tr>
<tr class="memdesc:ti-BaseInit"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize some member variables.  <a href="#ti-BaseInit">More...</a><br /></td></tr>
<tr class="separator:ti-BaseInit"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nr-DoGetToken"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken</a> ()</td></tr>
<tr class="memdesc:nr-DoGetToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the actual lexical analysis, both <a class="el" href="classTokenizer#p4-GetToken" title="Consume and return the current token string. ">GetToken()</a> and <a class="el" href="classTokenizer#pm-PeekToken" title="Do a &quot;look ahead&quot;, and return the next token string. ">PeekToken()</a> will internally call this function.  <a href="#nr-DoGetToken">More...</a><br /></td></tr>
<tr class="separator:nr-DoGetToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ey-ReadFile"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ey-ReadFile">ReadFile</a> ()</td></tr>
<tr class="memdesc:ey-ReadFile"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a file, and fill the m_Buffer.  <a href="#ey-ReadFile">More...</a><br /></td></tr>
<tr class="separator:ey-ReadFile"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vg-IsEscapedChar"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar</a> ()</td></tr>
<tr class="memdesc:vg-IsEscapedChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the current character is a C-Escape character in a string.  <a href="#vg-IsEscapedChar">More...</a><br /></td></tr>
<tr class="separator:vg-IsEscapedChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:xn-SkipToChar"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar</a> (const wxChar &amp;ch)</td></tr>
<tr class="memdesc:xn-SkipToChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip character until we meet a ch.  <a href="#xn-SkipToChar">More...</a><br /></td></tr>
<tr class="separator:xn-SkipToChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:l7-SkipToOneOfChars"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars</a> (const wxChar *chars, bool supportNesting=false, bool skipPreprocessor=false, bool skipAngleBrace=true)</td></tr>
<tr class="memdesc:l7-SkipToOneOfChars"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip characters until we meet any characters in a wxChar Array.  <a href="#l7-SkipToOneOfChars">More...</a><br /></td></tr>
<tr class="separator:l7-SkipToOneOfChars"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dm-SkipBlock"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#dm-SkipBlock">SkipBlock</a> (const wxChar &amp;ch)</td></tr>
<tr class="memdesc:dm-SkipBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip the blocks like &lt;&gt;, {}, [], ()  <a href="#dm-SkipBlock">More...</a><br /></td></tr>
<tr class="separator:dm-SkipBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:nb-SkipUnwanted"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted</a> ()</td></tr>
<tr class="memdesc:nb-SkipUnwanted"><td class="mdescLeft">&#160;</td><td class="mdescRight">skips comments, assignments, preprocessor etc.  <a href="#nb-SkipUnwanted">More...</a><br /></td></tr>
<tr class="separator:nb-SkipUnwanted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vm-SkipWhiteSpace"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace</a> ()</td></tr>
<tr class="memdesc:vm-SkipWhiteSpace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip any "tab" "white-space".  <a href="#vm-SkipWhiteSpace">More...</a><br /></td></tr>
<tr class="separator:vm-SkipWhiteSpace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:eo-SkipComment"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#eo-SkipComment">SkipComment</a> ()</td></tr>
<tr class="memdesc:eo-SkipComment"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip the C/C++ comment.  <a href="#eo-SkipComment">More...</a><br /></td></tr>
<tr class="separator:eo-SkipComment"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ah-SkipString"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ah-SkipString">SkipString</a> ()</td></tr>
<tr class="memdesc:ah-SkipString"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip the string literal(enclosed in double quotes) or character literal(enclosed in single quotes).  <a href="#ah-SkipString">More...</a><br /></td></tr>
<tr class="separator:ah-SkipString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:js-SkipToStringEnd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd</a> (const wxChar &amp;ch)</td></tr>
<tr class="memdesc:js-SkipToStringEnd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move to the end of string literal or character literal, the m_TokenIndex will at the closing quote character.  <a href="#js-SkipToStringEnd">More...</a><br /></td></tr>
<tr class="separator:js-SkipToStringEnd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ti-MoveToNextChar"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar</a> (const unsigned int amount=1)</td></tr>
<tr class="memdesc:ti-MoveToNextChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move to the next character in the buffer, amount defines the steps (by default, it is one)  <a href="#ti-MoveToNextChar">More...</a><br /></td></tr>
<tr class="separator:ti-MoveToNextChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:kq-CurrentChar"><td class="memItemLeft" align="right" valign="top">wxChar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar</a> () const </td></tr>
<tr class="memdesc:kq-CurrentChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current character indexed by m_TokenIndex in the m_Buffer.  <a href="#kq-CurrentChar">More...</a><br /></td></tr>
<tr class="separator:kq-CurrentChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mc-CurrentCharMoveNext"><td class="memItemLeft" align="right" valign="top">wxChar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#mc-CurrentCharMoveNext">CurrentCharMoveNext</a> ()</td></tr>
<tr class="memdesc:mc-CurrentCharMoveNext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the previous two functions sequentially.  <a href="#mc-CurrentCharMoveNext">More...</a><br /></td></tr>
<tr class="separator:mc-CurrentCharMoveNext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:k0-NextChar"><td class="memItemLeft" align="right" valign="top">wxChar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#k0-NextChar">NextChar</a> () const </td></tr>
<tr class="memdesc:k0-NextChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (peek) the next character.  <a href="#k0-NextChar">More...</a><br /></td></tr>
<tr class="separator:k0-NextChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:lf-PreviousChar"><td class="memItemLeft" align="right" valign="top">wxChar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar</a> () const </td></tr>
<tr class="memdesc:lf-PreviousChar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (peek) the previous character.  <a href="#lf-PreviousChar">More...</a><br /></td></tr>
<tr class="separator:lf-PreviousChar"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:oc-CharInString"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#oc-CharInString">CharInString</a> (const wxChar ch, const wxChar *chars) const </td></tr>
<tr class="memdesc:oc-CharInString"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a ch matches any characters in the wxChar array.  <a href="#oc-CharInString">More...</a><br /></td></tr>
<tr class="separator:oc-CharInString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:se-IsBackslashBeforeEOL"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL</a> ()</td></tr>
<tr class="memdesc:se-IsBackslashBeforeEOL"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the previous char before EOL is a backslash, call this function in the condition that the CurrentChar is '<br />
', here we have two cases: ......\<br />
......  <a href="#se-IsBackslashBeforeEOL">More...</a><br /></td></tr>
<tr class="separator:se-IsBackslashBeforeEOL"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:u0-GetReplacedToken"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken</a> (wxString &amp;str)</td></tr>
<tr class="memdesc:u0-GetReplacedToken"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the Macro replacement according to the macro replacement rules, generally we have two kinds of macro replacements.  <a href="#u0-GetReplacedToken">More...</a><br /></td></tr>
<tr class="separator:u0-GetReplacedToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:pi-CalcConditionExpression"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression</a> ()</td></tr>
<tr class="memdesc:pi-CalcConditionExpression"><td class="mdescLeft">&#160;</td><td class="mdescRight">Judge what is the first block It will call 'SkipToEOL(false, true)' before returned.  <a href="#pi-CalcConditionExpression">More...</a><br /></td></tr>
<tr class="separator:pi-CalcConditionExpression"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:wz-IsMacroDefined"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined</a> ()</td></tr>
<tr class="memdesc:wz-IsMacroDefined"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the next token string is macro usage, return true.  <a href="#wz-IsMacroDefined">More...</a><br /></td></tr>
<tr class="separator:wz-IsMacroDefined"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:u0-SkipToNextConditionPreprocess"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor</a> ()</td></tr>
<tr class="memdesc:u0-SkipToNextConditionPreprocess"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip to the next conditional preprocessor directive branch.  <a href="#u0-SkipToNextConditionPreprocess">More...</a><br /></td></tr>
<tr class="separator:u0-SkipToNextConditionPreprocess"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:h4-SkipToEndConditionPreprocesso"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor</a> ()</td></tr>
<tr class="memdesc:h4-SkipToEndConditionPreprocesso"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip to the #endif conditional preprocessor directive.  <a href="#h4-SkipToEndConditionPreprocesso">More...</a><br /></td></tr>
<tr class="separator:h4-SkipToEndConditionPreprocesso"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qi-GetPreprocessorType"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tokenizer_8h#ck-PreprocessorType">PreprocessorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType</a> ()</td></tr>
<tr class="memdesc:qi-GetPreprocessorType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current conditional preprocessor type.  <a href="#qi-GetPreprocessorType">More...</a><br /></td></tr>
<tr class="separator:qi-GetPreprocessorType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:v8-HandleConditionPreprocessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor</a> (const <a class="el" href="tokenizer_8h#ck-PreprocessorType">PreprocessorType</a> type)</td></tr>
<tr class="memdesc:v8-HandleConditionPreprocessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the preprocessor directive: #ifdef XXX or #endif or #if or #elif or...  <a href="#v8-HandleConditionPreprocessor">More...</a><br /></td></tr>
<tr class="separator:v8-HandleConditionPreprocessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ew-SplitArguments"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments</a> (wxArrayString &amp;results)</td></tr>
<tr class="memdesc:ew-SplitArguments"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the macro arguments, and store them in results, when calling this function, we expect that m_TokenIndex point to the opening parthense, or some spaces befor the opening parthense.  <a href="#ew-SplitArguments">More...</a><br /></td></tr>
<tr class="separator:ew-SplitArguments"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jw-GetMacroExpandedText"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jw-GetMacroExpandedText">GetMacroExpandedText</a> (const <a class="el" href="classToken">Token</a> *tk, wxString &amp;expandedText)</td></tr>
<tr class="memdesc:jw-GetMacroExpandedText"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text after macro expansion.  <a href="#jw-GetMacroExpandedText">More...</a><br /></td></tr>
<tr class="separator:jw-GetMacroExpandedText"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc-KMP_GetNextVal"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#dc-KMP_GetNextVal">KMP_GetNextVal</a> (const wxChar *pattern, int next[])</td></tr>
<tr class="memdesc:dc-KMP_GetNextVal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just for KMP find.  <a href="#dc-KMP_GetNextVal">More...</a><br /></td></tr>
<tr class="separator:dc-KMP_GetNextVal"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:xt-m_TokenizerOptions"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tokenizer_8h#structTokenizerOptions">TokenizerOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#xt-m_TokenizerOptions">m_TokenizerOptions</a></td></tr>
<tr class="memdesc:xt-m_TokenizerOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> options specify the skipping option.  <a href="#xt-m_TokenizerOptions">More...</a><br /></td></tr>
<tr class="separator:xt-m_TokenizerOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ti-m_TokenTree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a></td></tr>
<tr class="separator:ti-m_TokenTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:jr-m_Filename"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a></td></tr>
<tr class="memdesc:jr-m_Filename"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filename of the buffer.  <a href="#jr-m_Filename">More...</a><br /></td></tr>
<tr class="separator:jr-m_Filename"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ky-m_FileIdx"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ky-m_FileIdx">m_FileIdx</a></td></tr>
<tr class="memdesc:ky-m_FileIdx"><td class="mdescLeft">&#160;</td><td class="mdescRight">File index, useful when parsing documentation;.  <a href="#ky-m_FileIdx">More...</a><br /></td></tr>
<tr class="separator:ky-m_FileIdx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:g5-m_Buffer"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a></td></tr>
<tr class="memdesc:g5-m_Buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer content, all the lexical analysis is done on this.  <a href="#g5-m_Buffer">More...</a><br /></td></tr>
<tr class="separator:g5-m_Buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:k5-m_BufferLen"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a></td></tr>
<tr class="memdesc:k5-m_BufferLen"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer length.  <a href="#k5-m_BufferLen">More...</a><br /></td></tr>
<tr class="separator:k5-m_BufferLen"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:in-m_Token"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#in-m_Token">m_Token</a></td></tr>
<tr class="memdesc:in-m_Token"><td class="mdescLeft">&#160;</td><td class="mdescRight">These variables define the current token string and its auxiliary information, such as the token name, the line number of the token, the current brace nest level.  <a href="#in-m_Token">More...</a><br /></td></tr>
<tr class="separator:in-m_Token"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:c8-m_TokenIndex"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a></td></tr>
<tr class="memdesc:c8-m_TokenIndex"><td class="mdescLeft">&#160;</td><td class="mdescRight">index offset in buffer, when parsing a buffer .......  <a href="#c8-m_TokenIndex">More...</a><br /></td></tr>
<tr class="separator:c8-m_TokenIndex"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ko-m_LineNumber"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a></td></tr>
<tr class="memdesc:ko-m_LineNumber"><td class="mdescLeft">&#160;</td><td class="mdescRight">line offset in buffer, please note that it is 1 based, not 0 based  <a href="#ko-m_LineNumber">More...</a><br /></td></tr>
<tr class="separator:ko-m_LineNumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ru-m_NestLevel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a></td></tr>
<tr class="memdesc:ru-m_NestLevel"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep track of block nesting { }  <a href="#ru-m_NestLevel">More...</a><br /></td></tr>
<tr class="separator:ru-m_NestLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ky-m_UndoTokenIndex"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a></td></tr>
<tr class="memdesc:ky-m_UndoTokenIndex"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backup the previous <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> information.  <a href="#ky-m_UndoTokenIndex">More...</a><br /></td></tr>
<tr class="separator:ky-m_UndoTokenIndex"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ol-m_UndoLineNumber"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a></td></tr>
<tr class="separator:ol-m_UndoLineNumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:n2-m_UndoNestLevel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a></td></tr>
<tr class="separator:n2-m_UndoNestLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ve-m_PeekAvailable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ve-m_PeekAvailable">m_PeekAvailable</a></td></tr>
<tr class="memdesc:ve-m_PeekAvailable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek token information.  <a href="#ve-m_PeekAvailable">More...</a><br /></td></tr>
<tr class="separator:ve-m_PeekAvailable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:xt-m_PeekToken"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#xt-m_PeekToken">m_PeekToken</a></td></tr>
<tr class="separator:xt-m_PeekToken"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:o1-m_PeekTokenIndex"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#o1-m_PeekTokenIndex">m_PeekTokenIndex</a></td></tr>
<tr class="separator:o1-m_PeekTokenIndex"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oj-m_PeekLineNumber"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#oj-m_PeekLineNumber">m_PeekLineNumber</a></td></tr>
<tr class="separator:oj-m_PeekLineNumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:fy-m_PeekNestLevel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#fy-m_PeekNestLevel">m_PeekNestLevel</a></td></tr>
<tr class="separator:fy-m_PeekNestLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:n3-m_SavedTokenIndex"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#n3-m_SavedTokenIndex">m_SavedTokenIndex</a></td></tr>
<tr class="memdesc:n3-m_SavedTokenIndex"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saved token info (for <a class="el" href="classTokenizer#pm-PeekToken" title="Do a &quot;look ahead&quot;, and return the next token string. ">PeekToken()</a>), m_TokenIndex will be moved forward or backward when either <a class="el" href="classTokenizer#nr-DoGetToken" title="Do the actual lexical analysis, both GetToken() and PeekToken() will internally call this function...">DoGetToken()</a> or <a class="el" href="classTokenizer#nb-SkipUnwanted" title="skips comments, assignments, preprocessor etc. ">SkipUnwanted()</a> is called, so we should save m_TokenIndex before it get modified.  <a href="#n3-m_SavedTokenIndex">More...</a><br /></td></tr>
<tr class="separator:n3-m_SavedTokenIndex"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tn-m_SavedLineNumber"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#tn-m_SavedLineNumber">m_SavedLineNumber</a></td></tr>
<tr class="separator:tn-m_SavedLineNumber"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mi-m_SavedNestingLevel"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a></td></tr>
<tr class="separator:mi-m_SavedNestingLevel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:hj-m_IsOK"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#hj-m_IsOK">m_IsOK</a></td></tr>
<tr class="memdesc:hj-m_IsOK"><td class="mdescLeft">&#160;</td><td class="mdescRight">bool variable specifies whether the buffer is ready for parsing  <a href="#hj-m_IsOK">More...</a><br /></td></tr>
<tr class="separator:hj-m_IsOK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:xa-m_State"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#xa-m_State">m_State</a></td></tr>
<tr class="memdesc:xa-m_State"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokeniser state specifies the skipping option.  <a href="#xa-m_State">More...</a><br /></td></tr>
<tr class="separator:xa-m_State"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ky-m_Loader"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoaderBase">LoaderBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#ky-m_Loader">m_Loader</a></td></tr>
<tr class="memdesc:ky-m_Loader"><td class="mdescLeft">&#160;</td><td class="mdescRight">File loader.  <a href="#ky-m_Loader">More...</a><br /></td></tr>
<tr class="separator:ky-m_Loader"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:x8-m_ExpressionResult"><td class="memItemLeft" align="right" valign="top">std::stack&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#x8-m_ExpressionResult">m_ExpressionResult</a></td></tr>
<tr class="memdesc:x8-m_ExpressionResult"><td class="mdescLeft">&#160;</td><td class="mdescRight">preprocessor branch stack, if we meet a #if 1, then the value true will be pushed to to the stack, if we skip the #endif, the true value should be popped.  <a href="#x8-m_ExpressionResult">More...</a><br /></td></tr>
<tr class="separator:x8-m_ExpressionResult"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:kk-m_FirstRemainingLength"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#kk-m_FirstRemainingLength">m_FirstRemainingLength</a></td></tr>
<tr class="memdesc:kk-m_FirstRemainingLength"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the remaining length from m_TokenIndex to the end of m_Buffer before replace m_Buffer.  <a href="#kk-m_FirstRemainingLength">More...</a><br /></td></tr>
<tr class="separator:kk-m_FirstRemainingLength"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:e9-m_RepeatReplaceCount"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#e9-m_RepeatReplaceCount">m_RepeatReplaceCount</a></td></tr>
<tr class="memdesc:e9-m_RepeatReplaceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the repeat replace buffer count if currently in replace parsing, if it is 0, this means replace buffer does not happen.  <a href="#e9-m_RepeatReplaceCount">More...</a><br /></td></tr>
<tr class="separator:e9-m_RepeatReplaceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:i9-m_NextTokenDoc"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#i9-m_NextTokenDoc">m_NextTokenDoc</a></td></tr>
<tr class="separator:i9-m_NextTokenDoc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cy-m_LastTokenIdx"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#cy-m_LastTokenIdx">m_LastTokenIdx</a></td></tr>
<tr class="separator:cy-m_LastTokenIdx"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:cp-s_Replacements"><td class="memItemLeft" align="right" valign="top">static wxStringHashMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTokenizer#cp-s_Replacements">s_Replacements</a></td></tr>
<tr class="memdesc:cp-s_Replacements"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static member, this is a hash map storing all user defined macro replacement rules.  <a href="#cp-s_Replacements">More...</a><br /></td></tr>
<tr class="separator:cp-s_Replacements"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is just a simple lexer class. </p>
<p>A <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> does the lexical analysis on a buffer. The buffer is either a wxString loaded from a local source/header file or a wxString already in memory(e.g. the scintilla text buffer). The most public interfaces are two member functions: <a class="el" href="classTokenizer#p4-GetToken" title="Consume and return the current token string. ">GetToken()</a> and <a class="el" href="classTokenizer#pm-PeekToken" title="Do a &quot;look ahead&quot;, and return the next token string. ">PeekToken()</a>. The former one eats one token string from buffer, the later one does a "look ahead" on the buffer and return the next token string(peeked string). The peeked string will be cached until the next <a class="el" href="classTokenizer#p4-GetToken" title="Consume and return the current token string. ">GetToken()</a> call, thus performance can be improved. Also, <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> class does some kind of handling "Macro replacement" on the buffer to imitate the macro expansion in C-preprocessor, see member-function <a class="el" href="classTokenizer#u0-GetReplacedToken" title="Do the Macro replacement according to the macro replacement rules, generally we have two kinds of mac...">GetReplacedToken()</a> for details. Further more, it handles some "conditional preprocessor directives"(like "#if xxx"). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="lo-Tokenizer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tokenizer::Tokenizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenTree">TokenTree</a> *&#160;</td>
          <td class="paramname"><em>tokenTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>wxEmptyString</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the file to be opened. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#zq-Init">Init()</a>, <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>, <a class="el" href="classTokenizer#xt-m_TokenizerOptions">m_TokenizerOptions</a>, <a class="el" href="tokenizer_8h#ru-storeDocumentation">TokenizerOptions::storeDocumentation</a>, and <a class="el" href="tokenizer_8h#vj-wantPreprocessor">TokenizerOptions::wantPreprocessor</a>.</p>

</div>
</div>
<a class="anchor" id="zb-Tokenizer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tokenizer::~Tokenizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ti-BaseInit"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::BaseInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize some member variables. </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#kk-m_FirstRemainingLength">m_FirstRemainingLength</a>, <a class="el" href="classTokenizer#hj-m_IsOK">m_IsOK</a>, <a class="el" href="classTokenizer#cy-m_LastTokenIdx">m_LastTokenIdx</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#i9-m_NextTokenDoc">m_NextTokenDoc</a>, <a class="el" href="classTokenizer#oj-m_PeekLineNumber">m_PeekLineNumber</a>, <a class="el" href="classTokenizer#fy-m_PeekNestLevel">m_PeekNestLevel</a>, <a class="el" href="classTokenizer#o1-m_PeekTokenIndex">m_PeekTokenIndex</a>, <a class="el" href="classTokenizer#e9-m_RepeatReplaceCount">m_RepeatReplaceCount</a>, <a class="el" href="classTokenizer#tn-m_SavedLineNumber">m_SavedLineNumber</a>, <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>, <a class="el" href="classTokenizer#n3-m_SavedTokenIndex">m_SavedTokenIndex</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a>, <a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a>, and <a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#zq-Init">Init()</a>, and <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="pi-CalcConditionExpression"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::CalcConditionExpression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Judge what is the first block It will call 'SkipToEOL(false, true)' before returned. </p>

<p>References <a class="el" href="classExpression#do-AddToInfixExpression">Expression::AddToInfixExpression()</a>, <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classExpression#k0-CalcPostfix">Expression::CalcPostfix()</a>, <a class="el" href="classExpression#nc-ConvertInfixToPostfix">Expression::ConvertInfixToPostfix()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classExpression#hy-GetResult">Expression::GetResult()</a>, <a class="el" href="classExpression#ef-GetStatus">Expression::GetStatus()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#xa-m_State">m_State</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#v8-ReplaceMacroUsage">ReplaceMacroUsage()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>, <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsReadRawExpression">tsReadRawExpression</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="oc-CharInString"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::CharInString </td>
          <td>(</td>
          <td class="paramtype">const wxChar&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a ch matches any characters in the wxChar array. </p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, and <a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars()</a>.</p>

</div>
</div>
<a class="anchor" id="uk-ConvertToHashReplacementMap"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Tokenizer::ConvertToHashReplacementMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceConfigManagerContainer#fj-StringToStringMap">ConfigManagerContainer::StringToStringMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classTokenizer#cp-s_Replacements">s_Replacements</a>.</p>

<p>Referenced by <a class="el" href="classCodeCompletion#f6-LoadTokenReplacements">CodeCompletion::LoadTokenReplacements()</a>.</p>

</div>
</div>
<a class="anchor" id="kq-CurrentChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxChar Tokenizer::CurrentChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current character indexed by m_TokenIndex in the m_Buffer. </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#mc-CurrentCharMoveNext">CurrentCharMoveNext()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#dm-SkipBlock">SkipBlock()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, <a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="mc-CurrentCharMoveNext"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxChar Tokenizer::CurrentCharMoveNext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do the previous two functions sequentially. </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

</div>
</div>
<a class="anchor" id="nr-DoGetToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::DoGetToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do the actual lexical analysis, both <a class="el" href="classTokenizer#p4-GetToken" title="Consume and return the current token string. ">GetToken()</a> and <a class="el" href="classTokenizer#pm-PeekToken" title="Do a &quot;look ahead&quot;, and return the next token string. ">PeekToken()</a> will internally call this function. </p>
<p>It just move the m_TokenIndex one step forward, and return a lexeme before the m_TokenIndex. </p>

<p>References <a class="el" href="classTokenizer#oc-CharInString">CharInString()</a>, <a class="el" href="namespaceTokenizerConsts#a9-colon">TokenizerConsts::colon()</a>, <a class="el" href="namespaceTokenizerConsts#kp-colon_colon">TokenizerConsts::colon_colon()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#kk-m_FirstRemainingLength">m_FirstRemainingLength</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#e9-m_RepeatReplaceCount">m_RepeatReplaceCount</a>, <a class="el" href="classTokenizer#xa-m_State">m_State</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, <a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsReadRawExpression">tsReadRawExpression</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSingleAngleBrace">tsSingleAngleBrace</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="rn-GetFilename"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wxString&amp; Tokenizer::GetFilename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the opened files name. </p>

<p>References <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#w4-HandleConditionalArguments">ParserThread::HandleConditionalArguments()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">ParserThread::HandleForLoopArguments()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ParserThread::ReadClsNames()</a>, and <a class="el" href="classParserThread#p3-ReadVarNames">ParserThread::ReadVarNames()</a>.</p>

</div>
</div>
<a class="anchor" id="ma-GetFirstTokenPosition"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Tokenizer::GetFirstTokenPosition </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get first token position in buffer. </p>

<p>Referenced by <a class="el" href="classTokenizer#jw-GetMacroExpandedText">GetMacroExpandedText()</a>.</p>

</div>
</div>
<a class="anchor" id="ow-GetFirstTokenPosition"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tokenizer::GetFirstTokenPosition </td>
          <td>(</td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bufferLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>keyLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the sub-string key in the whole buffer, return the first position of the key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the content of the string </td></tr>
    <tr><td class="paramname">bufferLen</td><td>length of the string </td></tr>
    <tr><td class="paramname">key</td><td>the search key(sub-string) </td></tr>
    <tr><td class="paramname">keyLen</td><td>the search key length </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#je-KMP_Find">KMP_Find()</a>.</p>

</div>
</div>
<a class="anchor" id="jr-GetLineNumber"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::GetLineNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the line number of the current token string. </p>

<p>References <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">ParserThread::HandleConditionalArguments()</a>, <a class="el" href="classParserThread#tp-HandleDefines">ParserThread::HandleDefines()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">ParserThread::HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">ParserThread::HandleFunction()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">ParserThread::HandleNamespace()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">ParserThread::HandleTypedef()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ParserThread::ReadClsNames()</a>, and <a class="el" href="classParserThread#p3-ReadVarNames">ParserThread::ReadVarNames()</a>.</p>

</div>
</div>
<a class="anchor" id="jw-GetMacroExpandedText"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::GetMacroExpandedText </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>tk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>expandedText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the text after macro expansion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tk</td><td>the macro definition token, usually a function like macro definition </td></tr>
    <tr><td class="paramname">expandedText</td><td>is an output string </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#ma-GetFirstTokenPosition">GetFirstTokenPosition()</a>, <a class="el" href="classToken#wh-m_Args">Token::m_Args</a>, <a class="el" href="classToken#z1-m_FullType">Token::m_FullType</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>, <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#v8-ReplaceMacroUsage">ReplaceMacroUsage()</a>.</p>

</div>
</div>
<a class="anchor" id="el-GetNestingLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::GetNestingLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the brace "{}" level. </p>
<p>the value will increase by one when we meet a "{", decrease by one when we meet a "}". </p>

<p>References <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#ru-SkipBlock">ParserThread::SkipBlock()</a>, and <a class="el" href="classParserThread#zh-SkipToOneOfChars">ParserThread::SkipToOneOfChars()</a>.</p>

</div>
</div>
<a class="anchor" id="qi-GetPreprocessorType"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tokenizer_8h#ck-PreprocessorType">PreprocessorType</a> Tokenizer::GetPreprocessorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current conditional preprocessor type. </p>

<p>References <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="namespaceTokenizerConsts#p2-kw_elif">TokenizerConsts::kw_elif()</a>, <a class="el" href="namespaceTokenizerConsts#js-kw_elifdef">TokenizerConsts::kw_elifdef()</a>, <a class="el" href="namespaceTokenizerConsts#yp-kw_elifndef">TokenizerConsts::kw_elifndef()</a>, <a class="el" href="namespaceTokenizerConsts#jp-kw_else">TokenizerConsts::kw_else()</a>, <a class="el" href="namespaceTokenizerConsts#zc-kw_endif">TokenizerConsts::kw_endif()</a>, <a class="el" href="namespaceTokenizerConsts#sk-kw_if">TokenizerConsts::kw_if()</a>, <a class="el" href="namespaceTokenizerConsts#tt-kw_ifdef">TokenizerConsts::kw_ifdef()</a>, <a class="el" href="namespaceTokenizerConsts#kt-kw_ifndef">TokenizerConsts::kw_ifndef()</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElif">ptElif</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElifdef">ptElifdef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElifndef">ptElifndef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElse">ptElse</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptEndif">ptEndif</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIf">ptIf</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIfdef">ptIfdef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIfndef">ptIfndef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptOthers">ptOthers</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, and <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, and <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>.</p>

</div>
</div>
<a class="anchor" id="u0-GetReplacedToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::GetReplacedToken </td>
          <td>(</td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do the Macro replacement according to the macro replacement rules, generally we have two kinds of macro replacements. </p>
<p>One is the user defined macro replacement rules, which is hold by static member variable s_Replacements, you can let the tokenizer directly return a "BBB" string if the origin token is"AAA" , but you have a "AAA" -&gt; "BBB" rule. Another kind of macro replacement is that the tokenizer try to look up the token tree to see whether a token is a macro definition, if yes, it can expand the macro. The first kind of macro replacement happens every time when a tokenizer try to return a token, it is very fast as s_Replacements is a hash table, and have very limited entries, on the other side, looking up a token in the token tree takes more time, the later case only happens in some special cases, such has we are handling #if directives. </p>

<p>References <a class="el" href="classTokenTree#z7-at">TokenTree::at()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classToken#wh-m_Args">Token::m_Args</a>, <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>, <a class="el" href="classToken#z1-m_FullType">Token::m_FullType</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classToken#el-m_Name">Token::m_Name</a>, <a class="el" href="classTokenizer#e9-m_RepeatReplaceCount">m_RepeatReplaceCount</a>, <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>, <a class="el" href="classTokenizer#v8-ReplaceMacroUsage">ReplaceMacroUsage()</a>, <a class="el" href="classTokenizer#cp-s_Replacements">s_Replacements</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="kr-GetState"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a> Tokenizer::GetState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the skipping options value, see TokenizerState for more details. </p>

<p>References <a class="el" href="classTokenizer#xa-m_State">m_State</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">ParserThread::CalcEnumExpression()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">ParserThread::GetTemplateArgs()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#tp-HandleDefines">ParserThread::HandleDefines()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#sn-HandleUndefs">ParserThread::HandleUndefs()</a>, <a class="el" href="classParserThread#pl-SkipAngleBraces">ParserThread::SkipAngleBraces()</a>, and <a class="el" href="classParserThread#ru-SkipBlock">ParserThread::SkipBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="p4-GetToken"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::GetToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consume and return the current token string. </p>

<p>References <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#ve-m_PeekAvailable">m_PeekAvailable</a>, <a class="el" href="classTokenizer#oj-m_PeekLineNumber">m_PeekLineNumber</a>, <a class="el" href="classTokenizer#fy-m_PeekNestLevel">m_PeekNestLevel</a>, <a class="el" href="classTokenizer#xt-m_PeekToken">m_PeekToken</a>, <a class="el" href="classTokenizer#o1-m_PeekTokenIndex">m_PeekTokenIndex</a>, <a class="el" href="classTokenizer#in-m_Token">m_Token</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a>, <a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a>, <a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a>, and <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">ParserThread::CalcEnumExpression()</a>, <a class="el" href="classNativeParserBase#aa-ComputeCallTip">NativeParserBase::ComputeCallTip()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">ParserThread::GetTemplateArgs()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">ParserThread::HandleConditionalArguments()</a>, <a class="el" href="classParserThread#tp-HandleDefines">ParserThread::HandleDefines()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">ParserThread::HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">ParserThread::HandleFunction()</a>, <a class="el" href="classParserThread#ky-HandleIncludes">ParserThread::HandleIncludes()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">ParserThread::HandleNamespace()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">ParserThread::HandleTypedef()</a>, <a class="el" href="classParserThread#sn-HandleUndefs">ParserThread::HandleUndefs()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParserThread::ParseBufferForUsingNamespace()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ParserThread::ReadClsNames()</a>, <a class="el" href="classParserThread#p3-ReadVarNames">ParserThread::ReadVarNames()</a>, <a class="el" href="classParserThread#pl-SkipAngleBraces">ParserThread::SkipAngleBraces()</a>, <a class="el" href="classParserThread#ru-SkipBlock">ParserThread::SkipBlock()</a>, and <a class="el" href="classParserThread#zh-SkipToOneOfChars">ParserThread::SkipToOneOfChars()</a>.</p>

</div>
</div>
<a class="anchor" id="cx-GetTokenReplacementsMap"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static wxStringHashMap&amp; Tokenizer::GetTokenReplacementsMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the macro replacement map </p>

<p>References <a class="el" href="classTokenizer#cp-s_Replacements">s_Replacements</a>.</p>

<p>Referenced by <a class="el" href="classCCOptionsDlg#i4-CCOptionsDlg">CCOptionsDlg::CCOptionsDlg()</a>, and <a class="el" href="classCodeCompletion#qz-SaveTokenReplacements">CodeCompletion::SaveTokenReplacements()</a>.</p>

</div>
</div>
<a class="anchor" id="v8-HandleConditionPreprocessor"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::HandleConditionPreprocessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="tokenizer_8h#ck-PreprocessorType">PreprocessorType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handle the preprocessor directive: #ifdef XXX or #endif or #if or #elif or... </p>
<p>If conditional preprocessor handles correctly, return true, otherwise return false. </p>

<p>References <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#x8-m_ExpressionResult">m_ExpressionResult</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#tn-m_SavedLineNumber">m_SavedLineNumber</a>, <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>, <a class="el" href="classTokenizer#n3-m_SavedTokenIndex">m_SavedTokenIndex</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#xt-m_TokenizerOptions">m_TokenizerOptions</a>, <a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a>, <a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a>, <a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElif">ptElif</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElifdef">ptElifdef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElifndef">ptElifndef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptElse">ptElse</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptEndif">ptEndif</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIf">ptIf</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIfdef">ptIfdef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptIfndef">ptIfndef</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptOthers">ptOthers</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>, and <a class="el" href="tokenizer_8h#vj-wantPreprocessor">TokenizerOptions::wantPreprocessor</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, and <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>.</p>

</div>
</div>
<a class="anchor" id="zq-Init"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::Init </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>wxEmptyString</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoaderBase">LoaderBase</a> *&#160;</td>
          <td class="paramname"><em>loader</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the buffer by opening a file through a loader, this function copy the contents from the loader's buffer to its own buffer, so after that, we can safely delete the loader after this function call. </p>

<p>References <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenTree#gi-GetFileIndex">TokenTree::GetFileIndex()</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#ky-m_FileIdx">m_FileIdx</a>, <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>, <a class="el" href="classTokenizer#hj-m_IsOK">m_IsOK</a>, <a class="el" href="classTokenizer#ky-m_Loader">m_Loader</a>, <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#ey-ReadFile">ReadFile()</a>, <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>, <a class="el" href="tokenizer_8cpp#td-TRACE2">TRACE2</a>, and <a class="el" href="tokenizer_8cpp#nm-TRACE2_SET_FLAG">TRACE2_SET_FLAG</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#fc-InitTokenizer">ParserThread::InitTokenizer()</a>, and <a class="el" href="classTokenizer#lo-Tokenizer">Tokenizer()</a>.</p>

</div>
</div>
<a class="anchor" id="jo-InitFromBuffer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::InitFromBuffer </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>fileOfBuffer</em> = <code>wxEmptyString</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initLineNumber</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the buffer by directly using a wxString's content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initLineNumber</td><td>the start line of the buffer, usually the parser try to parse a function body, so the line information of each local variable tokens are correct. </td></tr>
    <tr><td class="paramname">buffer</td><td>text used for parsing </td></tr>
    <tr><td class="paramname">fileOfBuffer</td><td>the file name where the buffer come from. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenTree#gi-GetFileIndex">TokenTree::GetFileIndex()</a>, <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#ky-m_FileIdx">m_FileIdx</a>, <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>, <a class="el" href="classTokenizer#hj-m_IsOK">m_IsOK</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, and <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#aa-ComputeCallTip">NativeParserBase::ComputeCallTip()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">ParserThread::HandleConditionalArguments()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">ParserThread::HandleForLoopArguments()</a>, <a class="el" href="classParserThread#fc-InitTokenizer">ParserThread::InitTokenizer()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParserThread::ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="se-IsBackslashBeforeEOL"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::IsBackslashBeforeEOL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the previous char before EOL is a backslash, call this function in the condition that the CurrentChar is '<br />
', here we have two cases: ......\<br />
...... </p>
<p>^&ndash;current char, this is DOS style EOL ......\<br />
...... ^&ndash;current char, this is Linux style EOL </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, and <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, and <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>.</p>

</div>
</div>
<a class="anchor" id="x9-IsEOF"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::IsEOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> reaches the end of the buffer (file) </p>

<p>References <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, and <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="vg-IsEscapedChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::IsEscapedChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the current character is a C-Escape character in a string. </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, and <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd()</a>.</p>

</div>
</div>
<a class="anchor" id="wz-IsMacroDefined"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::IsMacroDefined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the next token string is macro usage, return true. </p>

<p>References <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, <a class="el" href="token_8h#uj-TokenKind:tkMacroDef">tkMacroDef</a>, and <a class="el" href="classTokenTree#b7-TokenExists">TokenTree::TokenExists()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, and <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="f2-IsOK"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::IsOK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the buffer is correctly loaded, this function return true. </p>

<p>References <a class="el" href="classTokenizer#hj-m_IsOK">m_IsOK</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#te-Parse">ParserThread::Parse()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParserThread::ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="oz-IsSkippingUnwantedTokens"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::IsSkippingUnwantedTokens </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking the TokenizerState. </p>

<p>References <a class="el" href="classTokenizer#xa-m_State">m_State</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipUnWanted">tsSkipUnWanted</a>.</p>

</div>
</div>
<a class="anchor" id="je-KMP_Find"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tokenizer::KMP_Find </td>
          <td>(</td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>patternLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>KMP find, get the first position, if find nothing, return -1. </p>

<p>References <a class="el" href="classTokenizer#dc-KMP_GetNextVal">KMP_GetNextVal()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#ow-GetFirstTokenPosition">GetFirstTokenPosition()</a>.</p>

</div>
</div>
<a class="anchor" id="dc-KMP_GetNextVal"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::KMP_GetNextVal </td>
          <td>(</td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just for KMP find. </p>

<p>Referenced by <a class="el" href="classTokenizer#je-KMP_Find">KMP_Find()</a>.</p>

</div>
</div>
<a class="anchor" id="ti-MoveToNextChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::MoveToNextChar </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>amount</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move to the next character in the buffer, amount defines the steps (by default, it is one) </p>

<p>References <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, and <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#dm-SkipBlock">SkipBlock()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, <a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="k0-NextChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxChar Tokenizer::NextChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return (peek) the next character. </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars()</a>, and <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>.</p>

</div>
</div>
<a class="anchor" id="c2-NotEOF"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::NotEOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return true if it is Not the end of buffer </p>

<p>References <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParserThread::ParseBufferForUsingNamespace()</a>, <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#dm-SkipBlock">SkipBlock()</a>, <a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="pm-PeekToken"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::PeekToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a "look ahead", and return the next token string. </p>

<p>References <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#ve-m_PeekAvailable">m_PeekAvailable</a>, <a class="el" href="classTokenizer#oj-m_PeekLineNumber">m_PeekLineNumber</a>, <a class="el" href="classTokenizer#fy-m_PeekNestLevel">m_PeekNestLevel</a>, <a class="el" href="classTokenizer#xt-m_PeekToken">m_PeekToken</a>, <a class="el" href="classTokenizer#o1-m_PeekTokenIndex">m_PeekTokenIndex</a>, <a class="el" href="classTokenizer#tn-m_SavedLineNumber">m_SavedLineNumber</a>, <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>, <a class="el" href="classTokenizer#n3-m_SavedTokenIndex">m_SavedTokenIndex</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, and <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>.</p>

<p>Referenced by <a class="el" href="classNativeParserBase#aa-ComputeCallTip">NativeParserBase::ComputeCallTip()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#w4-HandleConditionalArguments">ParserThread::HandleConditionalArguments()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#l5-HandleForLoopArguments">ParserThread::HandleForLoopArguments()</a>, <a class="el" href="classParserThread#oq-HandleFunction">ParserThread::HandleFunction()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">ParserThread::HandleNamespace()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">ParserThread::HandleTypedef()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, and <a class="el" href="classParserThread#cc-ParseBufferForUsingNamespace">ParserThread::ParseBufferForUsingNamespace()</a>.</p>

</div>
</div>
<a class="anchor" id="lf-PreviousChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxChar Tokenizer::PreviousChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return (peek) the previous character. </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, and <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar()</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, and <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>.</p>

</div>
</div>
<a class="anchor" id="ey-ReadFile"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::ReadFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a file, and fill the m_Buffer. </p>

<p>References <a class="el" href="globals_8h#ss-cbRead">cbRead()</a>, <a class="el" href="classLoaderBase#xn-FileName">LoaderBase::FileName()</a>, <a class="el" href="classLoaderBase#d3-GetData">LoaderBase::GetData()</a>, <a class="el" href="classLoaderBase#es-GetLength">LoaderBase::GetLength()</a>, <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#jr-m_Filename">m_Filename</a>, and <a class="el" href="classTokenizer#ky-m_Loader">m_Loader</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#zq-Init">Init()</a>.</p>

</div>
</div>
<a class="anchor" id="zl-ReadParentheses"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::ReadParentheses </td>
          <td>(</td>
          <td class="paramtype">wxString &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a string from '(' to ')', note that inner parentheses considered </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptOthers">ptOthers</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="j7-ReadToEOL"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::ReadToEOL </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nestBraces</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stripUnneeded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the string from the current position to the end of current line, in most case, this function is used in handling #define, use with care outside this class! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nestBraces</td><td>true if you still need to count the '{' and '}' levels </td></tr>
    <tr><td class="paramname">stripUnneeded</td><td>true if you are going to remove comments and compression spaces(two or more spaces should become one space) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#tp-HandleDefines">ParserThread::HandleDefines()</a>.</p>

</div>
</div>
<a class="anchor" id="lk-RemoveReplacementString"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Tokenizer::RemoveReplacementString </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a macro replacement rule. </p>

<p>References <a class="el" href="classTokenizer#cp-s_Replacements">s_Replacements</a>.</p>

<p>Referenced by <a class="el" href="classCCOptionsDlg#cj-OnDelRepl">CCOptionsDlg::OnDelRepl()</a>.</p>

</div>
</div>
<a class="anchor" id="hh-ReplaceBufferText"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::ReplaceBufferText </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backward buffer replacement for re-parsing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>the new text going to replace some other text on the m_Buffer</td></tr>
  </table>
  </dd>
</dl>
<p><a href="http://forums.codeblocks.org/index.php/topic,13384.msg90391.html#msg90391">http://forums.codeblocks.org/index.php/topic,13384.msg90391.html#msg90391</a></p>
<p>Macro expansion is just replace some characters in the m_Buffer.</p>
<p>xxxxxxxxxAAAA(u,v)yyyyyyyyy ^---&mdash; m_TokenIndex (anchor point)</p>
<p>For example, the above is a wxChar Array(m_Buffer), a macro expansion is needed to replace "AAAA(u,v)" to some new text. We just do a "backward" text replace here. Before the replacement, m_TokenIndex point to the next char of ")" in "AAAA(u,v)" (We say it as an anchor point), so the new buffer becomes:</p>
<p>xxxNNNNNNNNNNNNNNNyyyyyyyyy ^ &lt;--------&mdash; ^ m_TokenIndex was moved backward</p>
<p>Note that "NNNNNNNNNNNNNNN" is the new text. The m_TokenIndex was moved backward to the beginning of the new added text. if the new text is small enough, then m_Buffer's length do not need to increase. The situation when our m_Buffer's length need to be increased is that the new text is too long, so the buffer before "anchor point" can not hold the new text, this way, m_Buffer's length will adjusted. like below:</p>
<p>NNNNNNNNNNNNNNNNNNNNNNyyyyyyyyy ^&mdash;m_TokenIndex </p>

<p>References <a class="el" href="classTokenizer#g5-m_Buffer">m_Buffer</a>, <a class="el" href="classTokenizer#k5-m_BufferLen">m_BufferLen</a>, <a class="el" href="classTokenizer#kk-m_FirstRemainingLength">m_FirstRemainingLength</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#ve-m_PeekAvailable">m_PeekAvailable</a>, <a class="el" href="classTokenizer#e9-m_RepeatReplaceCount">m_RepeatReplaceCount</a>, <a class="el" href="classTokenizer#tn-m_SavedLineNumber">m_SavedLineNumber</a>, <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>, <a class="el" href="classTokenizer#n3-m_SavedTokenIndex">m_SavedTokenIndex</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a>, <a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a>, <a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a>, <a class="el" href="tokenizer_8cpp#lg-s_MaxRepeatReplaceCount">s_MaxRepeatReplaceCount</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">ParserThread::CalcEnumExpression()</a>, <a class="el" href="classTokenizer#jw-GetMacroExpandedText">GetMacroExpandedText()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">ParserThread::HandleNamespace()</a>, and <a class="el" href="classTokenizer#v8-ReplaceMacroUsage">ReplaceMacroUsage()</a>.</p>

</div>
</div>
<a class="anchor" id="v8-ReplaceMacroUsage"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::ReplaceMacroUsage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classToken">Token</a> *&#160;</td>
          <td class="paramname"><em>tk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get expanded text for the current macro usage, then replace buffer for re-parsing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tk</td><td>the macro definition token </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if macro expansion successes, thus buffer is really changed and m_TokenIndex moved backward a bit, and peek status get cleared Both the function like macro or variable like macro usage can be handled in this function. </dd></dl>

<p>References <a class="el" href="classTokenizer#jw-GetMacroExpandedText">GetMacroExpandedText()</a>, and <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classParserThread#nq-CalcEnumExpression">ParserThread::CalcEnumExpression()</a>, <a class="el" href="classNativeParserBase#aa-ComputeCallTip">NativeParserBase::ComputeCallTip()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, and <a class="el" href="classParserThread#sa-HandleMacroExpansion">ParserThread::HandleMacroExpansion()</a>.</p>

</div>
</div>
<a class="anchor" id="jt-RestoreNestingLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::RestoreNestingLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore the brace level. </p>

<p>References <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, and <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>.</p>

</div>
</div>
<a class="anchor" id="li-SaveNestingLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SaveNestingLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save the brace "{" level, the parser might need to ignore the nesting level in some cases. </p>

<p>References <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, and <a class="el" href="classTokenizer#mi-m_SavedNestingLevel">m_SavedNestingLevel</a>.</p>

</div>
</div>
<a class="anchor" id="d7-SetLastTokenIdx"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SetLastTokenIdx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tokenIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> is added, this function also add doxygen style document attached to the <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> </p>

<p>References <a class="el" href="classTokenTree#hm-AppendDocumentation">TokenTree::AppendDocumentation()</a>, <a class="el" href="classTokenizer#x8-m_ExpressionResult">m_ExpressionResult</a>, <a class="el" href="classTokenizer#cy-m_LastTokenIdx">m_LastTokenIdx</a>, <a class="el" href="classTokenizer#i9-m_NextTokenDoc">m_NextTokenDoc</a>, and <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#hd-DoAddToken">ParserThread::DoAddToken()</a>.</p>

</div>
</div>
<a class="anchor" id="ai-SetReplacementString"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Tokenizer::SetReplacementString </td>
          <td>(</td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wxString &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add one "replacement rule", this is just a simple way of defining a macro definition. </p>
<p>The rule composites two strings: the key string and the value string. When the <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> gets an identifier kind string, it is lookuped in the replacement rules map, if it matches one rule, the rule's value string will be returned instead.. Other rules are some function like macro definition, E.g. to replace the "_GLIBCXX_BEGIN_NAMESPACE(std)" to "namespace std {" We can use: <a class="el" href="classTokenizer#ai-SetReplacementString" title="Add one &quot;replacement rule&quot;, this is just a simple way of defining a macro definition. ">Tokenizer::SetReplacementString</a>(_T("_GLIBCXX_BEGIN_NAMESPACE"), _T("+namespace")); See more details in <a class="el" href="classCodeCompletion#f6-LoadTokenReplacements" title="load the token replacement map (macro definitions) from configuration file ">CodeCompletion::LoadTokenReplacements()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the matching key string </td></tr>
    <tr><td class="paramname">to</td><td>the matching value string </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#cp-s_Replacements">s_Replacements</a>.</p>

<p>Referenced by <a class="el" href="classCCOptionsDlg#mp-OnAddRepl">CCOptionsDlg::OnAddRepl()</a>, and <a class="el" href="classCCOptionsDlg#cj-OnEditRepl">CCOptionsDlg::OnEditRepl()</a>.</p>

</div>
</div>
<a class="anchor" id="no-SetState"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SetState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> skipping options. </p>
<p>E.g. sometimes, we need to skip the statement after "=", but sometimes, we should disable this options, see more details on TokenizerState. </p>

<p>References <a class="el" href="classTokenizer#xa-m_State">m_State</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">ParserThread::CalcEnumExpression()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">ParserThread::GetTemplateArgs()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#tp-HandleDefines">ParserThread::HandleDefines()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#bg-HandleNamespace">ParserThread::HandleNamespace()</a>, <a class="el" href="classParserThread#sn-HandleUndefs">ParserThread::HandleUndefs()</a>, <a class="el" href="classParserThread#i9-ParseBufferForNamespaces">ParserThread::ParseBufferForNamespaces()</a>, <a class="el" href="classParserThread#pl-SkipAngleBraces">ParserThread::SkipAngleBraces()</a>, and <a class="el" href="classParserThread#ru-SkipBlock">ParserThread::SkipBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="uv-SetTokenizerOption"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SetTokenizerOption </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wantPreprocessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>storeDocumentation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle condition preprocessor and store documentation or not. </p>

<p>References <a class="el" href="classTokenizer#xt-m_TokenizerOptions">m_TokenizerOptions</a>, <a class="el" href="tokenizer_8h#ru-storeDocumentation">TokenizerOptions::storeDocumentation</a>, and <a class="el" href="tokenizer_8h#vj-wantPreprocessor">TokenizerOptions::wantPreprocessor</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#kb-ParserThread">ParserThread::ParserThread()</a>.</p>

</div>
</div>
<a class="anchor" id="dm-SkipBlock"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipBlock </td>
          <td>(</td>
          <td class="paramtype">const wxChar &amp;&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip the blocks like &lt;&gt;, {}, [], () </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, and <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars()</a>, and <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>.</p>

</div>
</div>
<a class="anchor" id="eo-SkipComment"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipComment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip the C/C++ comment. </p>
<dl class="section return"><dt>Returns</dt><dd>true if we do move m_TokenIndex When C comment is handled, m_TokenIndex point to the char AFTER the '/' When C++ comment is handled, m_TokenIndex point to '<br />
' </dd></dl>

<p>References <a class="el" href="classTokenTree#hm-AppendDocumentation">TokenTree::AppendDocumentation()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#x8-m_ExpressionResult">m_ExpressionResult</a>, <a class="el" href="classTokenizer#cy-m_LastTokenIdx">m_LastTokenIdx</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#i9-m_NextTokenDoc">m_NextTokenDoc</a>, <a class="el" href="classTokenizer#xt-m_TokenizerOptions">m_TokenizerOptions</a>, <a class="el" href="classTokenizer#ti-m_TokenTree">m_TokenTree</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, <a class="el" href="tokenizer_8h#ru-storeDocumentation">TokenizerOptions::storeDocumentation</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#dm-SkipBlock">SkipBlock()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="ah-SkipString"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip the string literal(enclosed in double quotes) or character literal(enclosed in single quotes). </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, and <a class="el" href="classTokenizer#js-SkipToStringEnd">SkipToStringEnd()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#dm-SkipBlock">SkipBlock()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, and <a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars()</a>.</p>

</div>
</div>
<a class="anchor" id="xn-SkipToChar"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipToChar </td>
          <td>(</td>
          <td class="paramtype">const wxChar &amp;&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip character until we meet a ch. </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, and <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, and <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>.</p>

</div>
</div>
<a class="anchor" id="h4-SkipToEndConditionPreprocesso"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SkipToEndConditionPreprocessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip to the #endif conditional preprocessor directive. </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, and <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, and <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="hc-SkipToEOL"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipToEOL </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nestBraces</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip from the current position to the end of line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nestBraces</td><td>if true, we should still counting the brace levels in this function. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classParserThread#sn-HandleUndefs">ParserThread::HandleUndefs()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, and <a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars()</a>.</p>

</div>
</div>
<a class="anchor" id="e2-SkipToInlineCommentEnd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipToInlineCommentEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip to then end of the C++ style comment. </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#xn-SkipToChar">SkipToChar()</a>, and <a class="el" href="tokenizer_8cpp#qa-TRACE">TRACE</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="u0-SkipToNextConditionPreprocess"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::SkipToNextConditionPreprocessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip to the next conditional preprocessor directive branch. </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, and <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>.</p>

</div>
</div>
<a class="anchor" id="l7-SkipToOneOfChars"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipToOneOfChars </td>
          <td>(</td>
          <td class="paramtype">const wxChar *&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>supportNesting</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipPreprocessor</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipAngleBrace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip characters until we meet any characters in a wxChar Array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">supportNesting</td><td>handling brace level in this function. </td></tr>
    <tr><td class="paramname">skipPreprocessor</td><td>handling preprocessor directive. </td></tr>
    <tr><td class="paramname">skipAngleBrace</td><td>if this value is false, we will not do a match of "&lt; &gt; " </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTokenizer#oc-CharInString">CharInString()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#dm-SkipBlock">SkipBlock()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>, and <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, and <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>.</p>

</div>
</div>
<a class="anchor" id="js-SkipToStringEnd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipToStringEnd </td>
          <td>(</td>
          <td class="paramtype">const wxChar &amp;&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move to the end of string literal or character literal, the m_TokenIndex will at the closing quote character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>is a character either double quote or single quote </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we reach the closing quote character </dd></dl>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar()</a>, and <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, and <a class="el" href="classTokenizer#ah-SkipString">SkipString()</a>.</p>

</div>
</div>
<a class="anchor" id="nb-SkipUnwanted"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipUnwanted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>skips comments, assignments, preprocessor etc. </p>
<p>Eg, sometimes, it will skip the statement after the "=" statement (depend on the TokenizerState value). </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#xa-m_State">m_State</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="tokenizer_8h#ck-PreprocessorType:ptOthers">ptOthers</a>, <a class="el" href="classTokenizer#dm-SkipBlock">SkipBlock()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#l7-SkipToOneOfChars">SkipToOneOfChars()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipEqual">tsSkipEqual</a>, <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipQuestion">tsSkipQuestion</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsSkipSubScrip">tsSkipSubScrip</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, and <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>.</p>

</div>
</div>
<a class="anchor" id="vm-SkipWhiteSpace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SkipWhiteSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip any "tab" "white-space". </p>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, and <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#dm-SkipBlock">SkipBlock()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#h4-SkipToEndConditionPreprocesso">SkipToEndConditionPreprocessor()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="ew-SplitArguments"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::SplitArguments </td>
          <td>(</td>
          <td class="paramtype">wxArrayString &amp;&#160;</td>
          <td class="paramname"><em>results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the macro arguments, and store them in results, when calling this function, we expect that m_TokenIndex point to the opening parthense, or some spaces befor the opening parthense. </p>
<p>such as below</p>
<p>..... ABC ( xxx, yyy ) zzz ..... ^-----&mdash;m_TokenIndex</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>in the above example, the result contains two items (xxx and yyy) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if arguments (the parenthesis) are not found. </dd></dl>

<p>References <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#xa-m_State">m_State</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#vm-SkipWhiteSpace">SkipWhiteSpace()</a>, and <a class="el" href="tokenizer_8h#fr-TokenizerState:tsReadRawExpression">tsReadRawExpression</a>.</p>

<p>Referenced by <a class="el" href="classTokenizer#jw-GetMacroExpandedText">GetMacroExpandedText()</a>.</p>

</div>
</div>
<a class="anchor" id="jv-UngetToken"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tokenizer::UngetToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the GetToken. </p>

<p>References <a class="el" href="classTokenizer#ko-m_LineNumber">m_LineNumber</a>, <a class="el" href="classTokenizer#ru-m_NestLevel">m_NestLevel</a>, <a class="el" href="classTokenizer#ve-m_PeekAvailable">m_PeekAvailable</a>, <a class="el" href="classTokenizer#oj-m_PeekLineNumber">m_PeekLineNumber</a>, <a class="el" href="classTokenizer#fy-m_PeekNestLevel">m_PeekNestLevel</a>, <a class="el" href="classTokenizer#xt-m_PeekToken">m_PeekToken</a>, <a class="el" href="classTokenizer#o1-m_PeekTokenIndex">m_PeekTokenIndex</a>, <a class="el" href="classTokenizer#in-m_Token">m_Token</a>, <a class="el" href="classTokenizer#c8-m_TokenIndex">m_TokenIndex</a>, <a class="el" href="classTokenizer#ol-m_UndoLineNumber">m_UndoLineNumber</a>, <a class="el" href="classTokenizer#n2-m_UndoNestLevel">m_UndoNestLevel</a>, and <a class="el" href="classTokenizer#ky-m_UndoTokenIndex">m_UndoTokenIndex</a>.</p>

<p>Referenced by <a class="el" href="classParserThread#nq-CalcEnumExpression">ParserThread::CalcEnumExpression()</a>, <a class="el" href="classParserThread#tn-DoParse">ParserThread::DoParse()</a>, <a class="el" href="classParserThread#zx-GetTemplateArgs">ParserThread::GetTemplateArgs()</a>, <a class="el" href="classParserThread#s3-HandleClass">ParserThread::HandleClass()</a>, <a class="el" href="classParserThread#gm-HandleEnum">ParserThread::HandleEnum()</a>, <a class="el" href="classParserThread#oq-HandleFunction">ParserThread::HandleFunction()</a>, <a class="el" href="classParserThread#pm-HandleTypedef">ParserThread::HandleTypedef()</a>, <a class="el" href="classParserThread#dy-ReadClsNames">ParserThread::ReadClsNames()</a>, and <a class="el" href="classParserThread#pl-SkipAngleBraces">ParserThread::SkipAngleBraces()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="g5-m_Buffer"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::m_Buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer content, all the lexical analysis is done on this. </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#ey-ReadFile">ReadFile()</a>, <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, and <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>.</p>

</div>
</div>
<a class="anchor" id="k5-m_BufferLen"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_BufferLen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer length. </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#zq-Init">Init()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar()</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#ey-ReadFile">ReadFile()</a>, and <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>.</p>

</div>
</div>
<a class="anchor" id="x8-m_ExpressionResult"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt;bool&gt; Tokenizer::m_ExpressionResult</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>preprocessor branch stack, if we meet a #if 1, then the value true will be pushed to to the stack, if we skip the #endif, the true value should be popped. </p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#d7-SetLastTokenIdx">SetLastTokenIdx()</a>, and <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="ky-m_FileIdx"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Tokenizer::m_FileIdx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File index, useful when parsing documentation;. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTokenizer#eo-SkipComment" title="Skip the C/C++ comment. ">SkipComment</a> </dd></dl>

<p>Referenced by <a class="el" href="classTokenizer#zq-Init">Init()</a>, and <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="jr-m_Filename"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::m_Filename</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filename of the buffer. </p>

<p>Referenced by <a class="el" href="classTokenizer#rn-GetFilename">GetFilename()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classTokenizer#zq-Init">Init()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, <a class="el" href="classTokenizer#ey-ReadFile">ReadFile()</a>, and <a class="el" href="classTokenizer#lo-Tokenizer">Tokenizer()</a>.</p>

</div>
</div>
<a class="anchor" id="kk-m_FirstRemainingLength"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Tokenizer::m_FirstRemainingLength</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save the remaining length from m_TokenIndex to the end of m_Buffer before replace m_Buffer. </p>
<p>..........AAA.................. ^ [EOF]</p>
<p>It is the length between '^'(m_TokenIndex) and [EOF], sometimes there are not enough spaces to put the substitute before TokenIndex, so the m_Buffer will grows after the replacement:</p>
<p>BBBBBBBBBBBBBBBBBBBBBBBBB.................. ^ ! [EOF]</p>
<p>Here, m_TokenIndex is moved backward to the beginning of the new substitute string, but the length between '!' and [EOF] should not be changed. </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, and <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>.</p>

</div>
</div>
<a class="anchor" id="hj-m_IsOK"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::m_IsOK</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bool variable specifies whether the buffer is ready for parsing </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#zq-Init">Init()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, and <a class="el" href="classTokenizer#f2-IsOK">IsOK()</a>.</p>

</div>
</div>
<a class="anchor" id="cy-m_LastTokenIdx"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Tokenizer::m_LastTokenIdx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#d7-SetLastTokenIdx">SetLastTokenIdx()</a>, and <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="ko-m_LineNumber"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_LineNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>line offset in buffer, please note that it is 1 based, not 0 based </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#jr-GetLineNumber">GetLineNumber()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, <a class="el" href="classTokenizer#e2-SkipToInlineCommentEnd">SkipToInlineCommentEnd()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="ky-m_Loader"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoaderBase">LoaderBase</a>* Tokenizer::m_Loader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File loader. </p>

<p>Referenced by <a class="el" href="classTokenizer#zq-Init">Init()</a>, and <a class="el" href="classTokenizer#ey-ReadFile">ReadFile()</a>.</p>

</div>
</div>
<a class="anchor" id="ru-m_NestLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_NestLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>keep track of block nesting { } </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#el-GetNestingLevel">GetNestingLevel()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>, <a class="el" href="classTokenizer#jt-RestoreNestingLevel">RestoreNestingLevel()</a>, <a class="el" href="classTokenizer#li-SaveNestingLevel">SaveNestingLevel()</a>, <a class="el" href="classTokenizer#hc-SkipToEOL">SkipToEOL()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="i9-m_NextTokenDoc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::m_NextTokenDoc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#d7-SetLastTokenIdx">SetLastTokenIdx()</a>, and <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="ve-m_PeekAvailable"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tokenizer::m_PeekAvailable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek token information. </p>

<p>Referenced by <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="oj-m_PeekLineNumber"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_PeekLineNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="fy-m_PeekNestLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_PeekNestLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="xt-m_PeekToken"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::m_PeekToken</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="o1-m_PeekTokenIndex"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_PeekTokenIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="e9-m_RepeatReplaceCount"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Tokenizer::m_RepeatReplaceCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save the repeat replace buffer count if currently in replace parsing, if it is 0, this means replace buffer does not happen. </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, and <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>.</p>

</div>
</div>
<a class="anchor" id="tn-m_SavedLineNumber"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_SavedLineNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>.</p>

</div>
</div>
<a class="anchor" id="mi-m_SavedNestingLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_SavedNestingLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>, <a class="el" href="classTokenizer#jt-RestoreNestingLevel">RestoreNestingLevel()</a>, and <a class="el" href="classTokenizer#li-SaveNestingLevel">SaveNestingLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="n3-m_SavedTokenIndex"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_SavedTokenIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saved token info (for <a class="el" href="classTokenizer#pm-PeekToken" title="Do a &quot;look ahead&quot;, and return the next token string. ">PeekToken()</a>), m_TokenIndex will be moved forward or backward when either <a class="el" href="classTokenizer#nr-DoGetToken" title="Do the actual lexical analysis, both GetToken() and PeekToken() will internally call this function...">DoGetToken()</a> or <a class="el" href="classTokenizer#nb-SkipUnwanted" title="skips comments, assignments, preprocessor etc. ">SkipUnwanted()</a> is called, so we should save m_TokenIndex before it get modified. </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, and <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>.</p>

</div>
</div>
<a class="anchor" id="xa-m_State"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tokenizer_8h#fr-TokenizerState">TokenizerState</a> Tokenizer::m_State</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tokeniser state specifies the skipping option. </p>

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#kr-GetState">GetState()</a>, <a class="el" href="classTokenizer#oz-IsSkippingUnwantedTokens">IsSkippingUnwantedTokens()</a>, <a class="el" href="classTokenizer#no-SetState">SetState()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, and <a class="el" href="classTokenizer#ew-SplitArguments">SplitArguments()</a>.</p>

</div>
</div>
<a class="anchor" id="in-m_Token"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxString Tokenizer::m_Token</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These variables define the current token string and its auxiliary information, such as the token name, the line number of the token, the current brace nest level. </p>
<p>token name </p>

<p>Referenced by <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="c8-m_TokenIndex"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_TokenIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>index offset in buffer, when parsing a buffer ....... </p>
<p>namespace std { int a; ....... ^ &mdash; m_TokenIndex, m_Token = "std" m_TokenIndex always points to the next character of a valid token, in the above example, it points to the space after "std". </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#kq-CurrentChar">CurrentChar()</a>, <a class="el" href="classTokenizer#mc-CurrentCharMoveNext">CurrentCharMoveNext()</a>, <a class="el" href="classTokenizer#nr-DoGetToken">DoGetToken()</a>, <a class="el" href="classTokenizer#qi-GetPreprocessorType">GetPreprocessorType()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#se-IsBackslashBeforeEOL">IsBackslashBeforeEOL()</a>, <a class="el" href="classTokenizer#x9-IsEOF">IsEOF()</a>, <a class="el" href="classTokenizer#vg-IsEscapedChar">IsEscapedChar()</a>, <a class="el" href="classTokenizer#ti-MoveToNextChar">MoveToNextChar()</a>, <a class="el" href="classTokenizer#k0-NextChar">NextChar()</a>, <a class="el" href="classTokenizer#c2-NotEOF">NotEOF()</a>, <a class="el" href="classTokenizer#pm-PeekToken">PeekToken()</a>, <a class="el" href="classTokenizer#lf-PreviousChar">PreviousChar()</a>, <a class="el" href="classTokenizer#zl-ReadParentheses">ReadParentheses()</a>, <a class="el" href="classTokenizer#j7-ReadToEOL">ReadToEOL()</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>, <a class="el" href="classTokenizer#u0-SkipToNextConditionPreprocess">SkipToNextConditionPreprocessor()</a>, <a class="el" href="classTokenizer#nb-SkipUnwanted">SkipUnwanted()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="xt-m_TokenizerOptions"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tokenizer_8h#structTokenizerOptions">TokenizerOptions</a> Tokenizer::m_TokenizerOptions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classTokenizer" title="This is just a simple lexer class. ">Tokenizer</a> options specify the skipping option. </p>

<p>Referenced by <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#uv-SetTokenizerOption">SetTokenizerOption()</a>, <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>, and <a class="el" href="classTokenizer#lo-Tokenizer">Tokenizer()</a>.</p>

</div>
</div>
<a class="anchor" id="ti-m_TokenTree"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTokenTree">TokenTree</a>* Tokenizer::m_TokenTree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#pi-CalcConditionExpression">CalcConditionExpression()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classTokenizer#zq-Init">Init()</a>, <a class="el" href="classTokenizer#jo-InitFromBuffer">InitFromBuffer()</a>, <a class="el" href="classTokenizer#wz-IsMacroDefined">IsMacroDefined()</a>, <a class="el" href="classTokenizer#d7-SetLastTokenIdx">SetLastTokenIdx()</a>, and <a class="el" href="classTokenizer#eo-SkipComment">SkipComment()</a>.</p>

</div>
</div>
<a class="anchor" id="ol-m_UndoLineNumber"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_UndoLineNumber</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="n2-m_UndoNestLevel"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_UndoNestLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="ky-m_UndoTokenIndex"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Tokenizer::m_UndoTokenIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backup the previous <a class="el" href="classToken" title="a symbol found in the parsed files, it can be many kinds, such as a variable, a class and so on...">Token</a> information. </p>

<p>Referenced by <a class="el" href="classTokenizer#ti-BaseInit">BaseInit()</a>, <a class="el" href="classTokenizer#p4-GetToken">GetToken()</a>, <a class="el" href="classTokenizer#v8-HandleConditionPreprocessor">HandleConditionPreprocessor()</a>, <a class="el" href="classTokenizer#hh-ReplaceBufferText">ReplaceBufferText()</a>, and <a class="el" href="classTokenizer#jv-UngetToken">UngetToken()</a>.</p>

</div>
</div>
<a class="anchor" id="cp-s_Replacements"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxStringHashMap Tokenizer::s_Replacements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static member, this is a hash map storing all user defined macro replacement rules. </p>

<p>Referenced by <a class="el" href="classTokenizer#uk-ConvertToHashReplacementMap">ConvertToHashReplacementMap()</a>, <a class="el" href="classTokenizer#u0-GetReplacedToken">GetReplacedToken()</a>, <a class="el" href="classTokenizer#cx-GetTokenReplacementsMap">GetTokenReplacementsMap()</a>, <a class="el" href="classTokenizer#lk-RemoveReplacementString">RemoveReplacementString()</a>, and <a class="el" href="classTokenizer#ai-SetReplacementString">SetReplacementString()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="tokenizer_8h_source">tokenizer.h</a></li>
<li><a class="el" href="tokenizer_8cpp">tokenizer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
