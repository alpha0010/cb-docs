<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Code::Blocks: cbThreadPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Code::Blocks
   &#160;<span id="projectnumber">SVN r10170</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.xhtml"><span>Class&#160;List</span></a></li>
      <li><a href="classes.xhtml"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.xhtml"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.xhtml"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcbThreadPool-members.xhtml">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cbThreadPool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A Thread Pool implementation.  
 <a href="classcbThreadPool.xhtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cbthreadpool_8h_source.xhtml">cbthreadpool.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for cbThreadPool:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcbThreadPool__coll__graph.svg" width="607" height="1434"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcbThreadPool_1_1cbThreadedTaskElement.xhtml">cbThreadedTaskElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All tasks are added to one of these. It'll also save the autodelete value.  <a href="structcbThreadPool_1_1cbThreadedTaskElement.xhtml#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool_1_1cbWorkerThread.xhtml">cbWorkerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool_1_1CountedPtr.xhtml">CountedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Josuttis' implementation of <a class="el" href="classcbThreadPool_1_1CountedPtr.xhtml" title="Josuttis&#39; implementation of CountedPtr. ">CountedPtr</a>.  <a href="classcbThreadPool_1_1CountedPtr.xhtml#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a410ba875cd41fa884cd22391acbaba8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a410ba875cd41fa884cd22391acbaba8a">cbThreadPool</a> (wxEvtHandler *owner, int id=-1, int concurrentThreads=-1, unsigned int stackSize=0)</td></tr>
<tr class="separator:a410ba875cd41fa884cd22391acbaba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947eb1874b38fcdbe954f45be70d8f5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a947eb1874b38fcdbe954f45be70d8f5f">~cbThreadPool</a> ()</td></tr>
<tr class="memdesc:a947eb1874b38fcdbe954f45be70d8f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcbThreadPool.xhtml" title="A Thread Pool implementation. ">cbThreadPool</a> dtor  <a href="#a947eb1874b38fcdbe954f45be70d8f5f">More...</a><br /></td></tr>
<tr class="separator:a947eb1874b38fcdbe954f45be70d8f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a39495772bd50d7beff8390325f802a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a5a39495772bd50d7beff8390325f802a">SetConcurrentThreads</a> (int concurrentThreads)</td></tr>
<tr class="separator:a5a39495772bd50d7beff8390325f802a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a28b9a6ac7fb3dff239ded95ca2b597"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a1a28b9a6ac7fb3dff239ded95ca2b597">GetConcurrentThreads</a> () const </td></tr>
<tr class="separator:a1a28b9a6ac7fb3dff239ded95ca2b597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18516a470a7b247852b520d81cc1912"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#aa18516a470a7b247852b520d81cc1912">GetId</a> () const </td></tr>
<tr class="separator:aa18516a470a7b247852b520d81cc1912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eaa422e66369ebf78bcb0dbd36029f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a25eaa422e66369ebf78bcb0dbd36029f">AddTask</a> (<a class="el" href="classcbThreadedTask.xhtml">cbThreadedTask</a> *task, bool autodelete=true)</td></tr>
<tr class="separator:a25eaa422e66369ebf78bcb0dbd36029f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3477c26b54ed024450576fc3fa7f865f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a3477c26b54ed024450576fc3fa7f865f">AbortAllTasks</a> ()</td></tr>
<tr class="separator:a3477c26b54ed024450576fc3fa7f865f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19335d0513fa16c010ac61d3f458d05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#ac19335d0513fa16c010ac61d3f458d05">Done</a> () const </td></tr>
<tr class="separator:ac19335d0513fa16c010ac61d3f458d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fefa088d9022fdb08b6001c18b1a357"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a9fefa088d9022fdb08b6001c18b1a357">BatchBegin</a> ()</td></tr>
<tr class="separator:a9fefa088d9022fdb08b6001c18b1a357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7ac1651ebd8e2d2a046b0a0260a105"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#aae7ac1651ebd8e2d2a046b0a0260a105">BatchEnd</a> ()</td></tr>
<tr class="separator:aae7ac1651ebd8e2d2a046b0a0260a105"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6719c00db33ad55026471eafd6a845fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcbThreadPool_1_1cbThreadedTaskElement.xhtml">cbThreadedTaskElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a6719c00db33ad55026471eafd6a845fb">GetNextTask</a> ()</td></tr>
<tr class="separator:a6719c00db33ad55026471eafd6a845fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2d4b57d490b1f7680db022ac9796d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a3e2d4b57d490b1f7680db022ac9796d5">WorkingThread</a> ()</td></tr>
<tr class="separator:a3e2d4b57d490b1f7680db022ac9796d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d30d5ce1f2e6930b54a50c89df62a26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a6d30d5ce1f2e6930b54a50c89df62a26">WaitingThread</a> ()</td></tr>
<tr class="separator:a6d30d5ce1f2e6930b54a50c89df62a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615deb87b87df9b1432a262c96b24441"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a615deb87b87df9b1432a262c96b24441">TaskDone</a> (<a class="el" href="classcbThreadPool_1_1cbWorkerThread.xhtml">cbWorkerThread</a> *thread)</td></tr>
<tr class="separator:a615deb87b87df9b1432a262c96b24441"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ac2fb989a07ad9a99ff99be235d32e5dc"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak" />
&lt; <a class="el" href="classcbThreadPool_1_1cbWorkerThread.xhtml">cbWorkerThread</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#ac2fb989a07ad9a99ff99be235d32e5dc">WorkerThreadsArray</a></td></tr>
<tr class="separator:ac2fb989a07ad9a99ff99be235d32e5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b8e09dfd610b36e62c92e3ef6e194b"><td class="memItemLeft" align="right" valign="top">typedef std::list<br class="typebreak" />
&lt; <a class="el" href="structcbThreadPool_1_1cbThreadedTaskElement.xhtml">cbThreadedTaskElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a76b8e09dfd610b36e62c92e3ef6e194b">TasksQueue</a></td></tr>
<tr class="separator:a76b8e09dfd610b36e62c92e3ef6e194b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a456ce2e9e7e26e9cfad7078399b84065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a456ce2e9e7e26e9cfad7078399b84065">_SetConcurrentThreads</a> (int concurrentThreads)</td></tr>
<tr class="separator:a456ce2e9e7e26e9cfad7078399b84065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359b3827cdfbd4fff10d1aa4b6fa0dae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a359b3827cdfbd4fff10d1aa4b6fa0dae">Broadcast</a> ()</td></tr>
<tr class="separator:a359b3827cdfbd4fff10d1aa4b6fa0dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6fb53db233bca4d16589193d0c92ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a2a6fb53db233bca4d16589193d0c92ea">AwakeNeeded</a> ()</td></tr>
<tr class="separator:a2a6fb53db233bca4d16589193d0c92ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a25fe7ba24172c29abc0b47c18d518f76"><td class="memItemLeft" align="right" valign="top">wxEvtHandler *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a25fe7ba24172c29abc0b47c18d518f76">m_pOwner</a></td></tr>
<tr class="separator:a25fe7ba24172c29abc0b47c18d518f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42760ffb005c34832e2cbf15ef642144"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a42760ffb005c34832e2cbf15ef642144">m_ID</a></td></tr>
<tr class="separator:a42760ffb005c34832e2cbf15ef642144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbccda9298660730efed413e8b84750"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a0fbccda9298660730efed413e8b84750">m_batching</a></td></tr>
<tr class="separator:a0fbccda9298660730efed413e8b84750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad795dc459b74be6a3455de3f24cadb32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#ad795dc459b74be6a3455de3f24cadb32">m_concurrentThreads</a></td></tr>
<tr class="separator:ad795dc459b74be6a3455de3f24cadb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2152884ee6df9ad1772dfe2c879906b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#ad2152884ee6df9ad1772dfe2c879906b">m_stackSize</a></td></tr>
<tr class="separator:ad2152884ee6df9ad1772dfe2c879906b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1516ed39ec647bd4133375b21d9ddf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#aa1516ed39ec647bd4133375b21d9ddf8">m_concurrentThreadsSchedule</a></td></tr>
<tr class="separator:aa1516ed39ec647bd4133375b21d9ddf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e5c264770f8934e49211febd399da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcbThreadPool.xhtml#ac2fb989a07ad9a99ff99be235d32e5dc">WorkerThreadsArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#aa8e5c264770f8934e49211febd399da4">m_threads</a></td></tr>
<tr class="separator:aa8e5c264770f8934e49211febd399da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf43b1e2415efaf8e199796890d9400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcbThreadPool.xhtml#a76b8e09dfd610b36e62c92e3ef6e194b">TasksQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#abdf43b1e2415efaf8e199796890d9400">m_tasksQueue</a></td></tr>
<tr class="separator:abdf43b1e2415efaf8e199796890d9400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48ac7048eab2e87f3324d952f5c4c84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#ad48ac7048eab2e87f3324d952f5c4c84">m_taskAdded</a></td></tr>
<tr class="separator:ad48ac7048eab2e87f3324d952f5c4c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352cdd00957d729e5e37d1895d8e3dad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a352cdd00957d729e5e37d1895d8e3dad">m_workingThreads</a></td></tr>
<tr class="separator:a352cdd00957d729e5e37d1895d8e3dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69199fbb98970a3d16bc0a54fbd29cfa"><td class="memItemLeft" align="right" valign="top">wxMutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a></td></tr>
<tr class="separator:a69199fbb98970a3d16bc0a54fbd29cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810a0448ebb198e02502b413cccbafd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcbThreadPool_1_1CountedPtr.xhtml">CountedPtr</a>&lt; wxSemaphore &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a810a0448ebb198e02502b413cccbafd8">m_semaphore</a></td></tr>
<tr class="separator:a810a0448ebb198e02502b413cccbafd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a518ba3d520b04b3459bba18146d1d51d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcbThreadPool.xhtml#a518ba3d520b04b3459bba18146d1d51d">cbWorkerThread</a></td></tr>
<tr class="separator:a518ba3d520b04b3459bba18146d1d51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Thread Pool implementation. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a76b8e09dfd610b36e62c92e3ef6e194b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="structcbThreadPool_1_1cbThreadedTaskElement.xhtml">cbThreadedTaskElement</a>&gt; <a class="el" href="classcbThreadPool.xhtml#a76b8e09dfd610b36e62c92e3ef6e194b">cbThreadPool::TasksQueue</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2fb989a07ad9a99ff99be235d32e5dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classcbThreadPool_1_1cbWorkerThread.xhtml">cbWorkerThread</a> *&gt; <a class="el" href="classcbThreadPool.xhtml#ac2fb989a07ad9a99ff99be235d32e5dc">cbThreadPool::WorkerThreadsArray</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a410ba875cd41fa884cd22391acbaba8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cbThreadPool::cbThreadPool </td>
          <td>(</td>
          <td class="paramtype">wxEvtHandler *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>concurrentThreads</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stackSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classcbThreadPool.xhtml" title="A Thread Pool implementation. ">cbThreadPool</a> ctor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>Event handler to receive cbEVT_THREADTASK_ENDED and cbEVT_THREADTASK_ALLDONE events </td></tr>
    <tr><td class="paramname">id</td><td>Used with the events </td></tr>
    <tr><td class="paramname">concurrentThreads</td><td>Number of threads in the pool. -1 means current CPU count </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classcbThreadPool.xhtml#a5a39495772bd50d7beff8390325f802a">SetConcurrentThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="a947eb1874b38fcdbe954f45be70d8f5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cbThreadPool::~cbThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classcbThreadPool.xhtml" title="A Thread Pool implementation. ">cbThreadPool</a> dtor </p>

<p>References <a class="el" href="classcbThreadPool_1_1cbWorkerThread.xhtml#a104198703e3732e1273e2e7ef187b13f">cbThreadPool::cbWorkerThread::Abort()</a>, <a class="el" href="classcbThreadPool.xhtml#a359b3827cdfbd4fff10d1aa4b6fa0dae">Broadcast()</a>, <a class="el" href="structcbThreadPool_1_1cbThreadedTaskElement.xhtml#af42b56648c5ce11ac5b3f9f5063fa082">cbThreadPool::cbThreadedTaskElement::Delete()</a>, <a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a>, <a class="el" href="classcbThreadPool.xhtml#abdf43b1e2415efaf8e199796890d9400">m_tasksQueue</a>, and <a class="el" href="classcbThreadPool.xhtml#aa8e5c264770f8934e49211febd399da4">m_threads</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a456ce2e9e7e26e9cfad7078399b84065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cbThreadPool::_SetConcurrentThreads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>concurrentThreads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classcbThreadPool_1_1cbWorkerThread.xhtml#a104198703e3732e1273e2e7ef187b13f">cbThreadPool::cbWorkerThread::Abort()</a>, <a class="el" href="classcbThreadPool.xhtml#a359b3827cdfbd4fff10d1aa4b6fa0dae">Broadcast()</a>, <a class="el" href="classcbThreadPool.xhtml#a518ba3d520b04b3459bba18146d1d51d">cbWorkerThread</a>, <a class="el" href="classcbThreadPool.xhtml#ad795dc459b74be6a3455de3f24cadb32">m_concurrentThreads</a>, <a class="el" href="classcbThreadPool.xhtml#aa1516ed39ec647bd4133375b21d9ddf8">m_concurrentThreadsSchedule</a>, <a class="el" href="classcbThreadPool.xhtml#a810a0448ebb198e02502b413cccbafd8">m_semaphore</a>, <a class="el" href="classcbThreadPool.xhtml#ad2152884ee6df9ad1772dfe2c879906b">m_stackSize</a>, <a class="el" href="classcbThreadPool.xhtml#aa8e5c264770f8934e49211febd399da4">m_threads</a>, and <a class="el" href="classcbThreadPool.xhtml#a352cdd00957d729e5e37d1895d8e3dad">m_workingThreads</a>.</p>

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a5a39495772bd50d7beff8390325f802a">SetConcurrentThreads()</a>, and <a class="el" href="classcbThreadPool.xhtml#a6d30d5ce1f2e6930b54a50c89df62a26">WaitingThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a3477c26b54ed024450576fc3fa7f865f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbThreadPool::AbortAllTasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aborts all running and pending tasks</p>
<dl class="section note"><dt>Note</dt><dd>Calls <a class="el" href="classcbThreadedTask.xhtml#aa627c91a6405188001870a4191bf87c7" title="This function is called to tell the task to abort (check cbThreadPool::AbortAllTasks) ...">cbThreadedTask::Abort</a> for all running tasks and just removes the pending ones. </dd></dl>

<p>References <a class="el" href="classcbThreadPool_1_1cbWorkerThread.xhtml#ad6c5348857fd028c4ca25ab200659737">cbThreadPool::cbWorkerThread::AbortTask()</a>, <a class="el" href="structcbThreadPool_1_1cbThreadedTaskElement.xhtml#af42b56648c5ce11ac5b3f9f5063fa082">cbThreadPool::cbThreadedTaskElement::Delete()</a>, <a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a>, <a class="el" href="classcbThreadPool.xhtml#abdf43b1e2415efaf8e199796890d9400">m_tasksQueue</a>, and <a class="el" href="classcbThreadPool.xhtml#aa8e5c264770f8934e49211febd399da4">m_threads</a>.</p>

<p>Referenced by <a class="el" href="classParser.xhtml#a9019bf0250a6e34645f9936666ab69c3">Parser::TerminateAllThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="a25eaa422e66369ebf78bcb0dbd36029f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbThreadPool::AddTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcbThreadedTask.xhtml">cbThreadedTask</a> *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autodelete</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new task to the pool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to execute </td></tr>
    <tr><td class="paramname">autodelete</td><td>If true, the task will be deleted when it finish or be aborted </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classcbThreadPool.xhtml#a2a6fb53db233bca4d16589193d0c92ea">AwakeNeeded()</a>, <a class="el" href="classcbThreadPool.xhtml#a0fbccda9298660730efed413e8b84750">m_batching</a>, <a class="el" href="classcbThreadPool.xhtml#ad795dc459b74be6a3455de3f24cadb32">m_concurrentThreads</a>, <a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a>, <a class="el" href="classcbThreadPool.xhtml#ad48ac7048eab2e87f3324d952f5c4c84">m_taskAdded</a>, <a class="el" href="classcbThreadPool.xhtml#abdf43b1e2415efaf8e199796890d9400">m_tasksQueue</a>, and <a class="el" href="classcbThreadPool.xhtml#a352cdd00957d729e5e37d1895d8e3dad">m_workingThreads</a>.</p>

<p>Referenced by <a class="el" href="classParser.xhtml#a1fdd7a2304dc66b5a469ca0ebf26476f">Parser::OnAllThreadsDone()</a>, <a class="el" href="classParser.xhtml#a7edb662c9b2f5c17b26a0bd5a3632c08">Parser::OnBatchTimer()</a>, and <a class="el" href="classParser.xhtml#a58fb7a53e004350257a8456b90b98ad0">Parser::Parse()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a6fb53db233bca4d16589193d0c92ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cbThreadPool::AwakeNeeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classcbThreadPool.xhtml#ad795dc459b74be6a3455de3f24cadb32">m_concurrentThreads</a>, <a class="el" href="classcbThreadPool.xhtml#a810a0448ebb198e02502b413cccbafd8">m_semaphore</a>, <a class="el" href="classcbThreadPool.xhtml#abdf43b1e2415efaf8e199796890d9400">m_tasksQueue</a>, and <a class="el" href="classcbThreadPool.xhtml#a352cdd00957d729e5e37d1895d8e3dad">m_workingThreads</a>.</p>

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a25eaa422e66369ebf78bcb0dbd36029f">AddTask()</a>, and <a class="el" href="classcbThreadPool.xhtml#aae7ac1651ebd8e2d2a046b0a0260a105">BatchEnd()</a>.</p>

</div>
</div>
<a class="anchor" id="a9fefa088d9022fdb08b6001c18b1a357"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cbThreadPool::BatchBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin a batch process</p>
<dl class="section note"><dt>Note</dt><dd>EVIL: Call it if you want to add all tasks first and get none executed yet. If you DON'T call it, tasks will be executed as you add them (in fact it's what one would expect). </dd></dl>

<p>References <a class="el" href="classcbThreadPool.xhtml#a0fbccda9298660730efed413e8b84750">m_batching</a>, and <a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a>.</p>

</div>
</div>
<a class="anchor" id="aae7ac1651ebd8e2d2a046b0a0260a105"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbThreadPool::BatchEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End a batch process</p>
<dl class="section note"><dt>Note</dt><dd>EVIL: Call it when you have finished adding tasks and want them to execute. BEWARE: if you call BatchBegin but DON'T call BatchEnd, the tasks WON'T execute. </dd></dl>

<p>References <a class="el" href="classcbThreadPool.xhtml#a2a6fb53db233bca4d16589193d0c92ea">AwakeNeeded()</a>, <a class="el" href="classcbThreadPool.xhtml#a0fbccda9298660730efed413e8b84750">m_batching</a>, and <a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a>.</p>

</div>
</div>
<a class="anchor" id="a359b3827cdfbd4fff10d1aa4b6fa0dae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cbThreadPool::Broadcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classcbThreadPool.xhtml#ad795dc459b74be6a3455de3f24cadb32">m_concurrentThreads</a>, <a class="el" href="classcbThreadPool.xhtml#a810a0448ebb198e02502b413cccbafd8">m_semaphore</a>, and <a class="el" href="classcbThreadPool.xhtml#a352cdd00957d729e5e37d1895d8e3dad">m_workingThreads</a>.</p>

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a456ce2e9e7e26e9cfad7078399b84065">_SetConcurrentThreads()</a>, and <a class="el" href="classcbThreadPool.xhtml#a947eb1874b38fcdbe954f45be70d8f5f">~cbThreadPool()</a>.</p>

</div>
</div>
<a class="anchor" id="ac19335d0513fa16c010ac61d3f458d05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cbThreadPool::Done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tells if the pool has finished its job</p>
<dl class="section return"><dt>Returns</dt><dd>true if it has nothing to do, false if it's executing tasks </dd></dl>

<p>References <a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a>, and <a class="el" href="classcbThreadPool.xhtml#a352cdd00957d729e5e37d1895d8e3dad">m_workingThreads</a>.</p>

<p>Referenced by <a class="el" href="classParser.xhtml#a2369584c371c106ae594153818f9031a">Parser::Done()</a>, <a class="el" href="classParser.xhtml#afaa8b89804686eb4f631aafb6eb9e536">Parser::NotDoneReason()</a>, and <a class="el" href="classParser.xhtml#a9019bf0250a6e34645f9936666ab69c3">Parser::TerminateAllThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a28b9a6ac7fb3dff239ded95ca2b597"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cbThreadPool::GetConcurrentThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the current number of threads in the pool</p>
<dl class="section return"><dt>Returns</dt><dd>Number of threads in the pool </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If a call to SetConcurrentThreads hasn't been applied, it'll return the number of threads that will be set by it when all tasks be done. </dd></dl>

<p>References <a class="el" href="classcbThreadPool.xhtml#ad795dc459b74be6a3455de3f24cadb32">m_concurrentThreads</a>, <a class="el" href="classcbThreadPool.xhtml#aa1516ed39ec647bd4133375b21d9ddf8">m_concurrentThreadsSchedule</a>, and <a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a>.</p>

<p>Referenced by <a class="el" href="classParser.xhtml#aca7bd44e0f0557a78968540c6fe18bdf">Parser::GetMaxThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="aa18516a470a7b247852b520d81cc1912"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cbThreadPool::GetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return the pool <a class="el" href="classID.xhtml">ID</a> </p>

<p>Referenced by <a class="el" href="classParser.xhtml#a7f6a2ebd907836dd1361d83b30f06997">Parser::ConnectEvents()</a>, <a class="el" href="classParser.xhtml#add2772018ff041223f0d259031c03caa">Parser::DisconnectEvents()</a>, and <a class="el" href="classParser.xhtml#a1fdd7a2304dc66b5a469ca0ebf26476f">Parser::OnAllThreadsDone()</a>.</p>

</div>
</div>
<a class="anchor" id="a6719c00db33ad55026471eafd6a845fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcbThreadPool_1_1cbThreadedTaskElement.xhtml">cbThreadPool::cbThreadedTaskElement</a> cbThreadPool::GetNextTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the next task to run</p>
<dl class="section return"><dt>Returns</dt><dd>Next task to run, or a NULL task (set in .task) if none </dd></dl>

<p>References <a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a>, and <a class="el" href="classcbThreadPool.xhtml#abdf43b1e2415efaf8e199796890d9400">m_tasksQueue</a>.</p>

</div>
</div>
<a class="anchor" id="a5a39495772bd50d7beff8390325f802a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbThreadPool::SetConcurrentThreads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>concurrentThreads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the number of threads in the pool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">concurrentThreads</td><td>New number of threads. -1 or 0 means current CPU count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If tasks are running, it'll delay it until they're all done. </dd></dl>

<p>References <a class="el" href="classcbThreadPool.xhtml#a456ce2e9e7e26e9cfad7078399b84065">_SetConcurrentThreads()</a>, <a class="el" href="classcbThreadPool.xhtml#ad795dc459b74be6a3455de3f24cadb32">m_concurrentThreads</a>, <a class="el" href="classcbThreadPool.xhtml#aa1516ed39ec647bd4133375b21d9ddf8">m_concurrentThreadsSchedule</a>, and <a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a>.</p>

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a410ba875cd41fa884cd22391acbaba8a">cbThreadPool()</a>, and <a class="el" href="classParser.xhtml#a6b921aa0d93bce972abc5da93b990c09">Parser::SetMaxThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="a615deb87b87df9b1432a262c96b24441"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cbThreadPool::TaskDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcbThreadPool_1_1cbWorkerThread.xhtml">cbWorkerThread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by a Worker Thread to inform a single task has finished, this will send a cbEVT_THREADTASK_ENDED event</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The Worker Thread </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="sdk__events_8h.xhtml#aef665864fee9ae18d05b18eb62c4b57a">cbEVT_THREADTASK_ENDED</a>, <a class="el" href="classcbThreadPool.xhtml#a42760ffb005c34832e2cbf15ef642144">m_ID</a>, and <a class="el" href="classcbThreadPool.xhtml#a25fe7ba24172c29abc0b47c18d518f76">m_pOwner</a>.</p>

</div>
</div>
<a class="anchor" id="a6d30d5ce1f2e6930b54a50c89df62a26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cbThreadPool::WaitingThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mechanism for the threads to tell the Pool they're done and will go to idle, so we can assign another task to this thread.</p>
<dl class="section return"><dt>Returns</dt><dd>true if everything is OK, false if we should abort, this usually happens we need to set a scheduled m_concurrentThreads value. </dd></dl>

<p>References <a class="el" href="classcbThreadPool.xhtml#a456ce2e9e7e26e9cfad7078399b84065">_SetConcurrentThreads()</a>, <a class="el" href="sdk__events_8h.xhtml#a556a76ea1283420db1c53cb9bc2da1bf">cbEVT_THREADTASK_ALLDONE</a>, <a class="el" href="classcbThreadPool.xhtml#aa1516ed39ec647bd4133375b21d9ddf8">m_concurrentThreadsSchedule</a>, <a class="el" href="classcbThreadPool.xhtml#a42760ffb005c34832e2cbf15ef642144">m_ID</a>, <a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a>, <a class="el" href="classcbThreadPool.xhtml#a25fe7ba24172c29abc0b47c18d518f76">m_pOwner</a>, <a class="el" href="classcbThreadPool.xhtml#a810a0448ebb198e02502b413cccbafd8">m_semaphore</a>, <a class="el" href="classcbThreadPool.xhtml#ad48ac7048eab2e87f3324d952f5c4c84">m_taskAdded</a>, <a class="el" href="classcbThreadPool.xhtml#abdf43b1e2415efaf8e199796890d9400">m_tasksQueue</a>, and <a class="el" href="classcbThreadPool.xhtml#a352cdd00957d729e5e37d1895d8e3dad">m_workingThreads</a>.</p>

</div>
</div>
<a class="anchor" id="a3e2d4b57d490b1f7680db022ac9796d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cbThreadPool::WorkingThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mechanism for the threads to tell the Pool they're running, a thread is switch from the idle mode to working mode. This is triggered by semaphore released somewhere </p>

<p>References <a class="el" href="classcbThreadPool.xhtml#a69199fbb98970a3d16bc0a54fbd29cfa">m_Mutex</a>, and <a class="el" href="classcbThreadPool.xhtml#a352cdd00957d729e5e37d1895d8e3dad">m_workingThreads</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a518ba3d520b04b3459bba18146d1d51d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcbThreadPool_1_1cbWorkerThread.xhtml">cbWorkerThread</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a456ce2e9e7e26e9cfad7078399b84065">_SetConcurrentThreads()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a0fbccda9298660730efed413e8b84750"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cbThreadPool::m_batching</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a25eaa422e66369ebf78bcb0dbd36029f">AddTask()</a>, <a class="el" href="classcbThreadPool.xhtml#a9fefa088d9022fdb08b6001c18b1a357">BatchBegin()</a>, and <a class="el" href="classcbThreadPool.xhtml#aae7ac1651ebd8e2d2a046b0a0260a105">BatchEnd()</a>.</p>

</div>
</div>
<a class="anchor" id="ad795dc459b74be6a3455de3f24cadb32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cbThreadPool::m_concurrentThreads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a456ce2e9e7e26e9cfad7078399b84065">_SetConcurrentThreads()</a>, <a class="el" href="classcbThreadPool.xhtml#a25eaa422e66369ebf78bcb0dbd36029f">AddTask()</a>, <a class="el" href="classcbThreadPool.xhtml#a2a6fb53db233bca4d16589193d0c92ea">AwakeNeeded()</a>, <a class="el" href="classcbThreadPool.xhtml#a359b3827cdfbd4fff10d1aa4b6fa0dae">Broadcast()</a>, <a class="el" href="classcbThreadPool.xhtml#a1a28b9a6ac7fb3dff239ded95ca2b597">GetConcurrentThreads()</a>, and <a class="el" href="classcbThreadPool.xhtml#a5a39495772bd50d7beff8390325f802a">SetConcurrentThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1516ed39ec647bd4133375b21d9ddf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cbThreadPool::m_concurrentThreadsSchedule</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a456ce2e9e7e26e9cfad7078399b84065">_SetConcurrentThreads()</a>, <a class="el" href="classcbThreadPool.xhtml#a1a28b9a6ac7fb3dff239ded95ca2b597">GetConcurrentThreads()</a>, <a class="el" href="classcbThreadPool.xhtml#a5a39495772bd50d7beff8390325f802a">SetConcurrentThreads()</a>, and <a class="el" href="classcbThreadPool.xhtml#a6d30d5ce1f2e6930b54a50c89df62a26">WaitingThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a42760ffb005c34832e2cbf15ef642144"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cbThreadPool::m_ID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a615deb87b87df9b1432a262c96b24441">TaskDone()</a>, and <a class="el" href="classcbThreadPool.xhtml#a6d30d5ce1f2e6930b54a50c89df62a26">WaitingThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a69199fbb98970a3d16bc0a54fbd29cfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxMutex cbThreadPool::m_Mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a3477c26b54ed024450576fc3fa7f865f">AbortAllTasks()</a>, <a class="el" href="classcbThreadPool.xhtml#a25eaa422e66369ebf78bcb0dbd36029f">AddTask()</a>, <a class="el" href="classcbThreadPool.xhtml#a9fefa088d9022fdb08b6001c18b1a357">BatchBegin()</a>, <a class="el" href="classcbThreadPool.xhtml#aae7ac1651ebd8e2d2a046b0a0260a105">BatchEnd()</a>, <a class="el" href="classcbThreadPool.xhtml#ac19335d0513fa16c010ac61d3f458d05">Done()</a>, <a class="el" href="classcbThreadPool.xhtml#a1a28b9a6ac7fb3dff239ded95ca2b597">GetConcurrentThreads()</a>, <a class="el" href="classcbThreadPool.xhtml#a6719c00db33ad55026471eafd6a845fb">GetNextTask()</a>, <a class="el" href="classcbThreadPool.xhtml#a5a39495772bd50d7beff8390325f802a">SetConcurrentThreads()</a>, <a class="el" href="classcbThreadPool.xhtml#a6d30d5ce1f2e6930b54a50c89df62a26">WaitingThread()</a>, <a class="el" href="classcbThreadPool.xhtml#a3e2d4b57d490b1f7680db022ac9796d5">WorkingThread()</a>, and <a class="el" href="classcbThreadPool.xhtml#a947eb1874b38fcdbe954f45be70d8f5f">~cbThreadPool()</a>.</p>

</div>
</div>
<a class="anchor" id="a25fe7ba24172c29abc0b47c18d518f76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wxEvtHandler* cbThreadPool::m_pOwner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a615deb87b87df9b1432a262c96b24441">TaskDone()</a>, and <a class="el" href="classcbThreadPool.xhtml#a6d30d5ce1f2e6930b54a50c89df62a26">WaitingThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a810a0448ebb198e02502b413cccbafd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcbThreadPool_1_1CountedPtr.xhtml">CountedPtr</a>&lt;wxSemaphore&gt; cbThreadPool::m_semaphore</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a456ce2e9e7e26e9cfad7078399b84065">_SetConcurrentThreads()</a>, <a class="el" href="classcbThreadPool.xhtml#a2a6fb53db233bca4d16589193d0c92ea">AwakeNeeded()</a>, <a class="el" href="classcbThreadPool.xhtml#a359b3827cdfbd4fff10d1aa4b6fa0dae">Broadcast()</a>, <a class="el" href="classcbThreadPool_1_1cbWorkerThread.xhtml#a2b83f597e4c40785c163648791c695b4">cbThreadPool::cbWorkerThread::Entry()</a>, and <a class="el" href="classcbThreadPool.xhtml#a6d30d5ce1f2e6930b54a50c89df62a26">WaitingThread()</a>.</p>

</div>
</div>
<a class="anchor" id="ad2152884ee6df9ad1772dfe2c879906b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cbThreadPool::m_stackSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a456ce2e9e7e26e9cfad7078399b84065">_SetConcurrentThreads()</a>.</p>

</div>
</div>
<a class="anchor" id="ad48ac7048eab2e87f3324d952f5c4c84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cbThreadPool::m_taskAdded</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a25eaa422e66369ebf78bcb0dbd36029f">AddTask()</a>, and <a class="el" href="classcbThreadPool.xhtml#a6d30d5ce1f2e6930b54a50c89df62a26">WaitingThread()</a>.</p>

</div>
</div>
<a class="anchor" id="abdf43b1e2415efaf8e199796890d9400"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcbThreadPool.xhtml#a76b8e09dfd610b36e62c92e3ef6e194b">TasksQueue</a> cbThreadPool::m_tasksQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a3477c26b54ed024450576fc3fa7f865f">AbortAllTasks()</a>, <a class="el" href="classcbThreadPool.xhtml#a25eaa422e66369ebf78bcb0dbd36029f">AddTask()</a>, <a class="el" href="classcbThreadPool.xhtml#a2a6fb53db233bca4d16589193d0c92ea">AwakeNeeded()</a>, <a class="el" href="classcbThreadPool.xhtml#a6719c00db33ad55026471eafd6a845fb">GetNextTask()</a>, <a class="el" href="classcbThreadPool.xhtml#a6d30d5ce1f2e6930b54a50c89df62a26">WaitingThread()</a>, and <a class="el" href="classcbThreadPool.xhtml#a947eb1874b38fcdbe954f45be70d8f5f">~cbThreadPool()</a>.</p>

</div>
</div>
<a class="anchor" id="aa8e5c264770f8934e49211febd399da4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcbThreadPool.xhtml#ac2fb989a07ad9a99ff99be235d32e5dc">WorkerThreadsArray</a> cbThreadPool::m_threads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a456ce2e9e7e26e9cfad7078399b84065">_SetConcurrentThreads()</a>, <a class="el" href="classcbThreadPool.xhtml#a3477c26b54ed024450576fc3fa7f865f">AbortAllTasks()</a>, and <a class="el" href="classcbThreadPool.xhtml#a947eb1874b38fcdbe954f45be70d8f5f">~cbThreadPool()</a>.</p>

</div>
</div>
<a class="anchor" id="a352cdd00957d729e5e37d1895d8e3dad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cbThreadPool::m_workingThreads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classcbThreadPool.xhtml#a456ce2e9e7e26e9cfad7078399b84065">_SetConcurrentThreads()</a>, <a class="el" href="classcbThreadPool.xhtml#a25eaa422e66369ebf78bcb0dbd36029f">AddTask()</a>, <a class="el" href="classcbThreadPool.xhtml#a2a6fb53db233bca4d16589193d0c92ea">AwakeNeeded()</a>, <a class="el" href="classcbThreadPool.xhtml#a359b3827cdfbd4fff10d1aa4b6fa0dae">Broadcast()</a>, <a class="el" href="classcbThreadPool.xhtml#ac19335d0513fa16c010ac61d3f458d05">Done()</a>, <a class="el" href="classcbThreadPool.xhtml#a6d30d5ce1f2e6930b54a50c89df62a26">WaitingThread()</a>, and <a class="el" href="classcbThreadPool.xhtml#a3e2d4b57d490b1f7680db022ac9796d5">WorkingThread()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="cbthreadpool_8h_source.xhtml">cbthreadpool.h</a></li>
<li><a class="el" href="cbthreadpool_8cpp.xhtml">cbthreadpool.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
